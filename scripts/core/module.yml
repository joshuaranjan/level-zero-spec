#
# Copyright (C) 2019 Intel Corporation
#
# SPDX-License-Identifier: MIT
#
# See YaML.md for syntax definition
#
--- #--------------------------------------------------------------------------
type: header
desc: "Intel $OneApi Level-Zero APIs for Module"
--- #--------------------------------------------------------------------------
type: enum
desc: "Supported module creation input formats"
class: $xModule
name: $x_module_format_t
etors:
    - name: IL_SPIRV
      value: "0"
      desc: "Format is SPIRV IL format"
    - name: NATIVE
      desc: "Format is device native format"
--- #--------------------------------------------------------------------------
type: struct
desc: "Specialization constants - User defined constants"
class: $xModule
name: $x_module_constants_t
members:
    - type: "uint32_t"
      name: numConstants
      desc: "[in] Number of specialization constants."
    - type: "const uint32_t*"
      name: pConstantIds
      desc: "[in] Pointer to array of IDs that is sized to numConstants."
    - type: "const uint64_t*"
      name: pConstantValues
      desc: "[in] Pointer to array of values that is sized to numConstants."
--- #--------------------------------------------------------------------------
type: struct
desc: "Module descriptor"
class: $xModule
name: $x_module_desc_t
base: $x_base_desc_t
members:
    - type: "$x_module_format_t"
      name: format
      desc: "[in] Module format passed in with pInputModule"
    - type: "size_t"
      name: inputSize
      desc: "[in] size of input IL or ISA from pInputModule."
      init: "0"
    - type: "const uint8_t*"
      name: pInputModule
      desc: "[in] pointer to IL or ISA"
      init: nullptr
    - type: "const char*"
      name: pBuildFlags
      desc: "[in][optional] string containing compiler flags. See programming guide for build flags."
      init: nullptr
    - type: "const $x_module_constants_t*"
      name: pConstants
      desc: "[in][optional] pointer to specialization constants. Valid only for SPIR-V input. This must be set to nullptr if no specialization constants are provided."
      init: nullptr
--- #--------------------------------------------------------------------------
type: function
desc: "Creates module object from an input IL or native binary."
class: $xModule
name: Create
decl: static
ordinal: "0"
details:
    - "Compiles the module for execution on the device."
    - "The module can only be used on the device on which it was created."
    - "The module can be copied to other devices within the same driver instance by using $xModuleGetNativeBinary."
    - "The following build options are supported:":
        - "\"-$x-opt-disable\" - Disable optimizations"
        - "\"-$x-opt-greater-than-4GB-buffer-required\" - Use 64-bit offset calculations for buffers."
        - "\"-$x-opt-large-register-file\" - Increase number of registers available to threads."
    - "A build log can optionally be returned to the caller. The caller is responsible for destroying build log using $xModuleBuildLogDestroy."
    - "The module descriptor constants are only supported for SPIR-V specialization constants."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $x_device_handle_t
      name: hDevice
      desc: "[in] handle of the device"
    - type: "const $x_module_desc_t*"
      name: desc
      desc: "[in] pointer to module descriptor"
    - type: "$x_module_handle_t*"
      name: phModule
      desc: "[out] pointer to handle of module object created"
    - type: "$x_module_build_log_handle_t*"
      name: phBuildLog
      desc: "[out][optional] pointer to handle of module's build log."
returns:
    - $X_RESULT_ERROR_INVALID_NATIVE_BINARY
    - $X_RESULT_ERROR_INVALID_SIZE:
        - "`0 == desc->inputSize`"
    - $X_RESULT_ERROR_OUT_OF_HOST_MEMORY
    - $X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY
    - $X_RESULT_ERROR_MODULE_BUILD_FAILURE
--- #--------------------------------------------------------------------------
type: function
desc: "Destroys module"
class: $xModule
name: Destroy
decl: static
ordinal: "0"
details:
    - "The application must destroy all kernel and build log handles created from the module before destroying the module itself"
    - "The application must ensure the device is not currently referencing the module before it is deleted"
    - "The implementation of this function may immediately free all Host and Device allocations associated with this module"
    - "The application must **not** call this function from simultaneous threads with the same module handle."
    - "The implementation of this function should be lock-free."
params:
    - type: "$x_module_handle_t"
      name: hModule
      desc: "[in][release] handle of the module"
returns:
    - $X_RESULT_ERROR_HANDLE_OBJECT_IN_USE
--- #--------------------------------------------------------------------------
type: function
desc: "Dynamically link modules together that share import/export linkage dependencies."
class: $xModule
name: DynamicLink
decl: static
details:
    - "Modules support import and export linkage for functions and global variables."
    - "Modules that have imports can be dynamically linked to export modules that satisfy those import requirements."
    - "Modules can have both import and export linkages."
    - "Modules that do not have any imports or exports do not need to be linked."
    - "Modules cannot be partially linked. All modules needed to satisfy all import dependencies for a module must be passed in or $X_RESULT_ERROR_MODULE_LINK_FAILURE will returned."
    - "Modules with imports need to be linked before kernel objects can be created from them."
    - "Modules will only be linked once. A module can be used in multiple link calls if it has exports but it's imports will not be re-linked."
    - "Ambiguous dependencies, where multiple modules satisfy the import dependencies for another module, is not allowed."
    - "ModuleGetNativeBinary can be called on any module regardless of whether it is linked or not."
    - "A link log can optionally be returned to the caller. The caller is responsible for destroying build log using $xModuleBuildLogDestroy."
    - "See SPIR-V specification for linkage details."
    - "The application may call this function from simultaneous threads as long as the import modules being linked are not the same."
    - "The implementation of this function should be lock-free."
params:
    - type: uint32_t
      name: numModules
      desc: "[in] number of modules to be linked pointed to by phModules."
    - type: "$x_module_handle_t*"
      name: phModules
      desc: "[in][range(0, numModules)] pointer to an array of modules to dynamically link together."
    - type: "$x_module_build_log_handle_t*"
      name: phLinkLog
      desc: "[out][optional] pointer to handle of dynamic link log."
returns:
    - $X_RESULT_ERROR_MODULE_LINK_FAILURE
--- #--------------------------------------------------------------------------
type: function
desc: "Destroys module build log object"
class: $xModuleBuildLog
name: Destroy
decl: static
ordinal: "0"
details:
    - "The implementation of this function may immediately free all Host allocations associated with this object"
    - "The application must **not** call this function from simultaneous threads with the same build log handle."
    - "The implementation of this function should be lock-free."
    - "This function can be called before or after $xModuleDestroy for the associated module."
params:
    - type: "$x_module_build_log_handle_t"
      name: hModuleBuildLog
      desc: "[in][release] handle of the module build log object."
returns:
    - $X_RESULT_ERROR_HANDLE_OBJECT_IN_USE
--- #--------------------------------------------------------------------------
type: function
desc: "Retrieves text string for build log."
class: $xModuleBuildLog
name: GetString
details:
    - "The caller can pass nullptr for pBuildLog when querying only for size."
    - "The caller must provide memory for build log."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $x_module_build_log_handle_t
      name: hModuleBuildLog
      desc: "[in] handle of the module build log object."
    - type: "size_t*"
      name: pSize
      desc: "[in,out] size of build log string."
    - type: "char*"
      name: pBuildLog
      desc: "[in,out][optional] pointer to null-terminated string of the log."
--- #--------------------------------------------------------------------------
type: function
desc: "Retrieve native binary from Module."
class: $xModule
name: GetNativeBinary
details:
    - "The native binary output can be cached to disk and new modules can be later constructed from the cached copy."
    - "The native binary will retain debugging information that is associated with a module."
    - "The caller can pass nullptr for pModuleNativeBinary when querying only for size."
    - "The implementation will copy the native binary into a buffer supplied by the caller."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $x_module_handle_t
      name: hModule
      desc: "[in] handle of the module"
    - type: "size_t*"
      name: pSize
      desc: "[in,out] size of native binary in bytes."
    - type: "uint8_t*"
      name: pModuleNativeBinary
      desc: "[in,out][optional] byte pointer to native binary"
--- #--------------------------------------------------------------------------
type: function
desc: "Retrieve global variable pointer from Module."
class: $xModule
name: GetGlobalPointer
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $x_module_handle_t
      name: hModule
      desc: "[in] handle of the module"
    - type: "const char*"
      name: pGlobalName
      desc: "[in] name of global variable in module"
    - type: "void**"
      name: pptr
      desc: "[out] device visible pointer"
returns:
    - $X_RESULT_ERROR_INVALID_GLOBAL_NAME
--- #--------------------------------------------------------------------------
type: function
desc: "Retrieve all kernel names in the module."
class: $xModule
name: GetKernelNames
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $x_module_handle_t
      name: hModule
      desc: "[in] handle of the module"
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of names.
            if count is zero, then the driver will update the value with the total number of names available.
            if count is non-zero, then driver will only retrieve that number of names.
            if count is larger than the number of names available, then the driver will update the value with the correct number of names available.
    - type: "const char**"
      name: pNames
      desc: "[in,out][optional][range(0, *pCount)] array of names of functions"
--- #--------------------------------------------------------------------------
type: enum
desc: "Supported kernel creation flags"
class: $xKernel
name: $x_kernel_flags_t
etors:
    - name: FORCE_RESIDENCY
      desc: "force all device allocations to be resident during execution"
    - name: EXPLICIT_RESIDENCY
      desc: |
            application is responsible for all residency of device allocations.
            driver may disable implicit residency management.
--- #--------------------------------------------------------------------------
type: struct
desc: "Kernel descriptor"
class: $xKernel
name: $x_kernel_desc_t
base: $x_base_desc_t
members:
    - type: "$x_kernel_flags_t"
      name: flags
      desc: |
            [in] creation flags.
            must be 0 (default) or a valid combination of $x_kernel_flag_t;
            default behavior may use driver-based residency.
      init: "0"
    - type: "const char*"
      name: pKernelName
      desc: "[in] null-terminated name of kernel in module"
      init: nullptr
--- #--------------------------------------------------------------------------
type: function
desc: "Create a kernel object from a module by name"
class: $xKernel
name: Create
decl: static
ordinal: "0"
details:
    - "Modules that have unresolved imports need to be dynamically linked before a kernel can be created from them. (See $xModuleDynamicLink)"
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: "$x_module_handle_t"
      name: hModule
      desc: "[in] handle of the module"
    - type: "const $x_kernel_desc_t*"
      name: desc
      desc: "[in] pointer to kernel descriptor"
    - type: "$x_kernel_handle_t*"
      name:  phKernel
      desc: "[out] handle of the Function object"
returns:
    - $X_RESULT_ERROR_INVALID_NULL_POINTER:
        - "`nullptr == desc->pKernelName`"
    - $X_RESULT_ERROR_INVALID_KERNEL_NAME
    - $X_RESULT_ERROR_INVALID_MODULE_UNLINKED
--- #--------------------------------------------------------------------------
type: function
desc: "Destroys a kernel object"
class: $xKernel
name: Destroy
decl: static
ordinal: "0"
details:
    - "The application must ensure the device is not currently referencing the kernel before it is deleted"
    - "The implementation of this function may immediately free all Host and Device allocations associated with this kernel"
    - "The application must **not** call this function from simultaneous threads with the same kernel handle."
    - "The implementation of this function should be lock-free."
params:
    - type: "$x_kernel_handle_t"
      name: hKernel
      desc: "[in][release] handle of the kernel object"  
returns:
    - $X_RESULT_ERROR_HANDLE_OBJECT_IN_USE
--- #--------------------------------------------------------------------------
type: function
desc: "Retrieve a function pointer from a module by name"
class: $xModule
name: GetFunctionPointer
details:
    - "The function pointer is unique for the device on which the module was created."
    - "The function pointer is no longer valid if module is destroyed."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: "$x_module_handle_t"
      name: hModule
      desc: "[in] handle of the module"
    - type: "const char*"
      name: pFunctionName
      desc: "[in] Name of function to retrieve function pointer for."
    - type: "void**"
      name:  pfnFunction
      desc: "[out] pointer to function."
returns:
    - $X_RESULT_ERROR_INVALID_FUNCTION_NAME
--- #--------------------------------------------------------------------------
type: function
desc: "Set group size for a kernel"
class: $xKernel
name: SetGroupSize
details:
    - "The application must **not** call this function from simultaneous threads with the same kernel handle."
    - "The implementation of this function should be lock-free."
    - "The implementation will copy the group size information into a command list when the function is appended."
params:
    - type: "$x_kernel_handle_t"
      name: hKernel
      desc: "[in] handle of the kernel object" 
    - type: "uint32_t"
      name: groupSizeX
      desc: "[in] group size for X dimension to use for this kernel"
    - type: "uint32_t"
      name: groupSizeY
      desc: "[in] group size for Y dimension to use for this kernel"
    - type: "uint32_t"
      name: groupSizeZ
      desc: "[in] group size for Z dimension to use for this kernel"
returns:
    - $X_RESULT_ERROR_INVALID_GROUP_SIZE_DIMENSION
--- #--------------------------------------------------------------------------
type: function
desc: "Query a suggested group size for a kernel given a global size for each dimension."
class: $xKernel
name: SuggestGroupSize
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
    - "This function ignores the group size that is set using $xKernelSetGroupSize."
params:
    - type: "$x_kernel_handle_t"
      name: hKernel
      desc: "[in] handle of the kernel object" 
    - type: "uint32_t"
      name: globalSizeX
      desc: "[in] global width for X dimension"
    - type: "uint32_t"
      name: globalSizeY
      desc: "[in] global width for Y dimension"
    - type: "uint32_t"
      name: globalSizeZ
      desc: "[in] global width for Z dimension"
    - type: "uint32_t*"
      name: groupSizeX
      desc: "[out] recommended size of group for X dimension"
    - type: "uint32_t*"
      name: groupSizeY
      desc: "[out] recommended size of group for Y dimension"
    - type: "uint32_t*"
      name: groupSizeZ
      desc: "[out] recommended size of group for Z dimension"
returns:
    - $X_RESULT_ERROR_INVALID_GLOBAL_WIDTH_DIMENSION
--- #--------------------------------------------------------------------------
type: function
desc: "Query a suggested max group count for a cooperative kernel."
class: $xKernel
name: SuggestMaxCooperativeGroupCount
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: "$x_kernel_handle_t"
      name: hKernel
      desc: "[in] handle of the kernel object" 
    - type: "uint32_t*"
      name: totalGroupCount
      desc: "[out] recommended total group count."
--- #--------------------------------------------------------------------------
type: function
desc: "Set kernel argument used on kernel launch."
class: $xKernel
name: SetArgumentValue
details:
    - "This function may **not** be called from simultaneous threads with the same function handle."
    - "The implementation of this function should be lock-free."
    - "The implementation will copy the arguments into a command list when the function is appended."
params:
    - type: "$x_kernel_handle_t"
      name: hKernel
      desc: "[in] handle of the kernel object"
    - type: "uint32_t"
      name: argIndex
      desc: "[in] argument index in range [0, num args - 1]"
    - type: "size_t"
      name: argSize
      desc: "[in] size of argument type"
    - type: "const void*"
      name: pArgValue
      desc: "[in][optional] argument value represented as matching arg type. If null then argument value is considered null."
returns:
    - $X_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_INDEX
    - $X_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_SIZE
--- #--------------------------------------------------------------------------
type: enum
desc: "Kernel attributes"
class: $xKernel
name: $x_kernel_attribute_t
analogue:
    - "**cl_kernel_exec_info**"
etors:
    - name: INDIRECT_HOST_ACCESS
      value: "0"
      desc: "Indicates that the function accesses host allocations indirectly (default: false, type: bool_t)"
    - name: INDIRECT_DEVICE_ACCESS
      desc: "Indicates that the function accesses device allocations indirectly (default: false, type: bool_t)"
    - name: INDIRECT_SHARED_ACCESS
      desc: "Indicates that the function accesses shared allocations indirectly (default: false, type: bool_t)"
    - name: SOURCE_ATTRIBUTE
      desc: "Declared kernel attributes (i.e. can be specified with __attribute__ in runtime language). (type: char[]) Returned as a null-terminated string and each attribute is separated by a space. $xKernelSetAttribute is not supported for this."
--- #--------------------------------------------------------------------------
type: function
desc: "Sets a kernel attribute"
class: $xKernel
name: SetAttribute
analogue:
    - "**clSetKernelExecInfo**"
details:
    - "This function may **not** be called from simultaneous threads with the same function handle."
    - "The implementation of this function should be lock-free."
params:
    - type: "$x_kernel_handle_t"
      name: hKernel
      desc: "[in] handle of the kernel object"
    - type: "$x_kernel_attribute_t"
      name: attr
      desc: "[in] attribute to set"
    - type: "uint32_t"
      name: size
      desc: "[in] size in bytes of kernel attribute value."
    - type: "const void*"
      name: pValue
      desc: "[in][optional] pointer to attribute value."
returns:
    - $X_RESULT_ERROR_INVALID_KERNEL_ATTRIBUTE_VALUE
--- #--------------------------------------------------------------------------
type: function
desc: "Gets a kernel attribute"
class: $xKernel
name: GetAttribute
details:
    - "This function may **not** be called from simultaneous threads with the same function handle."
    - "The implementation of this function should be lock-free."
    - "The caller sets pValue to nullptr when querying only for size."
    - "The caller must provide memory for pValue querying when querying size."
params:
    - type: "$x_kernel_handle_t"
      name: hKernel
      desc: "[in] handle of the kernel object"
    - type: "$x_kernel_attribute_t"
      name: attr
      desc: "[in] attribute to get. Documentation for $x_kernel_attribute_t for return type information for pValue."
    - type: "uint32_t*"
      name: pSize
      desc: "[in,out] size in bytes needed for kernel attribute value. If pValue is nullptr then the size needed for pValue memory will be written to pSize. Only need to query size for arbitrary sized attributes."
    - type: "void*"
      name: pValue
      desc: "[in,out][optional] pointer to attribute value result."
returns:
    - $X_RESULT_ERROR_INVALID_KERNEL_ATTRIBUTE_VALUE
--- #--------------------------------------------------------------------------
type: function
desc: "Sets the preferred Intermediate cache configuration for a kernel."
class: $xKernel
name: SetIntermediateCacheConfig
ordinal: "2"
details:
    - "The application must **not** call this function from simultaneous threads with the same kernel handle."
params:
    - type: "$x_kernel_handle_t"
      name: hKernel
      desc: "[in] handle of the kernel object" 
    - type: "$x_cache_config_flags_t"
      name: flags
      desc: |
            [in] cache configuration. 
            must be 0 (default configuration) or a valid combination of $x_cache_config_flag_t.
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE
--- #--------------------------------------------------------------------------
type: macro
desc: "Maximum kernel name string size"
name: $X_MAX_KERNEL_NAME
value: "256"
--- #--------------------------------------------------------------------------
type: macro
desc: "Maximum kernel universal unique id (UUID) size in bytes"
name: $X_MAX_KERNEL_UUID_SIZE
value: "16"
--- #--------------------------------------------------------------------------
type: macro
desc: "Maximum module universal unique id (UUID) size in bytes"
name: $X_MAX_MODULE_UUID_SIZE
value: "16"
--- #--------------------------------------------------------------------------
type: struct
desc: "Kernel universal unique id (UUID)"
name: "$x_kernel_uuid_t"
members:
    - type: uint8_t
      name: "kid[$X_MAX_KERNEL_UUID_SIZE]"
      desc: "[out] opaque data representing a kernel UUID"
    - type: uint8_t
      name: "mid[$X_MAX_MODULE_UUID_SIZE]"
      desc: "[out] opaque data representing the kernel's module UUID"
--- #--------------------------------------------------------------------------
type: struct
desc: "Kernel properties"
class: $xKernel
name: $x_kernel_properties_t
base: $x_base_properties_t
members:
    - type: "uint32_t"
      name: numKernelArgs
      desc: "[out] number of kernel arguments."
    - type: "uint32_t"
      name: requiredGroupSizeX
      desc: |
            [out] required group size in the X dimension,
            or zero if there is no required group size
    - type: "uint32_t"
      name: requiredGroupSizeY
      desc: |
            [out] required group size in the Y dimension,
            or zero if there is no required group size
    - type: "uint32_t"
      name: requiredGroupSizeZ
      desc: |
            [out] required group size in the Z dimension,
            or zero if there is no required group size
    - type: "uint32_t"
      name: requiredNumSubGroups
      desc: |
            [out] required number of subgroups per thread group,
            or zero if there is no required number of subgroups
    - type: "uint32_t"
      name: requiredSubgroupSize
      desc: |
            [out] required subgroup size,
            or zero if there is no required subgroup size
    - type: "uint32_t"
      name: maxSubgroupSize
      desc: "[out] maximum subgroup size"
    - type: "uint32_t"
      name: maxNumSubgroups
      desc: "[out] maximum number of subgroups per thread group"
    - type: "uint32_t"
      name: localMemSize
      desc: "[out] local memory size used by each thread group"
    - type: "uint32_t"
      name: privateMemSize
      desc: "[out] private memory size allocated by compiler used by each thread"
    - type: "uint32_t"
      name: spillMemSize
      desc: "[out] spill memory size allocated by compiler"
    - type: $x_kernel_uuid_t
      name: uuid
      desc: "[out] universal unique identifier."
    - type: char
      name: "name[$X_MAX_KERNEL_NAME]"
      desc: "[out] kernel name"
--- #--------------------------------------------------------------------------
type: function
desc: "Retrieve kernel properties."
class: $xKernel
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: "$x_kernel_handle_t"
      name: hKernel
      desc: "[in] handle of the kernel object"
    - type: "$x_kernel_properties_t*"
      name: pKernelProperties
      desc: "[in,out] query result for kernel properties."
--- #--------------------------------------------------------------------------
type: struct
desc: "Kernel dispatch group count."
class: $xCommandList
name: $x_group_count_t
members:
    - type: "uint32_t"
      name: groupCountX
      desc: "[in] number of thread groups in X dimension"
      init: "0"
    - type: "uint32_t"
      name: groupCountY
      desc: "[in] number of thread groups in Y dimension"
      init: "0"
    - type: "uint32_t"
      name: groupCountZ
      desc: "[in] number of thread groups in Z dimension"
      init: "0"
--- #--------------------------------------------------------------------------
type: function
desc: "Launch kernel over one or more work groups."
class: $xCommandList
name: AppendLaunchKernel
details:
    - "This may **only** be called for a command list created with command queue group ordinal that supports compute."
    - "This function may **not** be called from simultaneous threads with the same command list handle."
    - "The implementation of this function should be lock-free."
params:
    - type: "$x_command_list_handle_t"
      name: hCommandList
      desc: "[in] handle of the command list"
    - type: "$x_kernel_handle_t"
      name: hKernel
      desc: "[in] handle of the kernel object"
    - type: "const $x_group_count_t*"
      name: pLaunchFuncArgs
      desc: "[in] thread group launch arguments"
    - type: $x_event_handle_t
      name: hSignalEvent
      desc: "[in][optional] handle of the event to signal on completion"
    - type: uint32_t
      name: numWaitEvents
      desc: "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`"
    - type: "$x_event_handle_t*"
      name: phWaitEvents
      desc: "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching"
returns:
    - $X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT
    - $X_RESULT_ERROR_INVALID_SIZE:
        - "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
--- #--------------------------------------------------------------------------
type: function
desc: "Launch kernel cooperatively over one or more work groups."
class: $xCommandList
name: AppendLaunchCooperativeKernel
details:
    - "This may **only** be called for a command list created with command queue group ordinal that supports compute."
    - "This may only be used for a command list that are submitted to command queue with cooperative flag set."
    - "This function may **not** be called from simultaneous threads with the same command list handle."
    - "The implementation of this function should be lock-free."
    - "Use $xKernelSuggestMaxCooperativeGroupCount to recommend max group count for device for cooperative functions that device supports."
params:
    - type: "$x_command_list_handle_t"
      name: hCommandList
      desc: "[in] handle of the command list"
    - type: "$x_kernel_handle_t"
      name: hKernel
      desc: "[in] handle of the kernel object"
    - type: "const $x_group_count_t*"
      name: pLaunchFuncArgs
      desc: "[in] thread group launch arguments"
    - type: $x_event_handle_t
      name: hSignalEvent
      desc: "[in][optional] handle of the event to signal on completion"
    - type: uint32_t
      name: numWaitEvents
      desc: "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`"
    - type: "$x_event_handle_t*"
      name: phWaitEvents
      desc: "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching"      
returns:
    - $X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT
    - $X_RESULT_ERROR_INVALID_SIZE:
        - "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
--- #--------------------------------------------------------------------------
type: function
desc: "Launch kernel over one or more work groups using indirect arguments."
class: $xCommandList
name: AppendLaunchKernelIndirect
details:
    - "The launch arguments need to be device visible."
    - "The launch arguments buffer may not be reused until the function has completed on the device."
    - "This may **only** be called for a command list created with command queue group ordinal that supports compute."
    - "This function may **not** be called from simultaneous threads with the same command list handle."
    - "The implementation of this function should be lock-free."
params:
    - type: "$x_command_list_handle_t"
      name: hCommandList
      desc: "[in] handle of the command list"
    - type: "$x_kernel_handle_t"
      name: hKernel
      desc: "[in] handle of the kernel object"
    - type: "const $x_group_count_t*"
      name: pLaunchArgumentsBuffer
      desc: "[in] pointer to device buffer that will contain thread group launch arguments"
    - type: $x_event_handle_t
      name: hSignalEvent
      desc: "[in][optional] handle of the event to signal on completion"
    - type: uint32_t
      name: numWaitEvents
      desc: "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`"
    - type: "$x_event_handle_t*"
      name: phWaitEvents
      desc: "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching"
returns:
    - $X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT
    - $X_RESULT_ERROR_INVALID_SIZE:
        - "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
--- #--------------------------------------------------------------------------
type: function
desc: "Launch multiple kernels over one or more work groups using an array of indirect arguments."
class: $xCommandList
name: AppendLaunchMultipleKernelsIndirect
details:
    - "The array of launch arguments need to be device visible."
    - "The array of launch arguments buffer may not be reused until the kernel has completed on the device."
    - "This may **only** be called for a command list created with command queue group ordinal that supports compute."
    - "This function may **not** be called from simultaneous threads with the same command list handle."
    - "The implementation of this function should be lock-free."
params:
    - type: "$x_command_list_handle_t"
      name: hCommandList
      desc: "[in] handle of the command list"
    - type: uint32_t
      name: numKernels
      desc: "[in] maximum number of kernels to launch"
    - type: "$x_kernel_handle_t*"
      name: phKernels
      desc: "[in][range(0, numKernels)] handles of the kernel objects"
    - type: "const uint32_t*"
      name: pCountBuffer
      desc: "[in] pointer to device memory location that will contain the actual number of kernels to launch; value must be less-than or equal-to numKernels"
    - type: "const $x_group_count_t*"
      name: pLaunchArgumentsBuffer
      desc: "[in][range(0, numKernels)] pointer to device buffer that will contain a contiguous array of thread group launch arguments"
    - type: $x_event_handle_t
      name: hSignalEvent
      desc: "[in][optional] handle of the event to signal on completion"
    - type: uint32_t
      name: numWaitEvents
      desc: "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`"
    - type: "$x_event_handle_t*"
      name: phWaitEvents
      desc: "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching"
returns:
    - $X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT
    - $X_RESULT_ERROR_INVALID_SIZE:
        - "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for module"
name: $xModule
owner: $xDevice
members:
    - type: $x_module_handle_t
      name: handle
      desc: "[in] handle of module object"
    - type: $xDevice*
      name: pDevice
      desc: "[in] pointer to owner object"
    - type: $x_module_desc_t
      name: desc
      desc: "[in] descriptor of the module object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for buildlog"
name: $xModuleBuildLog
owner: $xModule
members:
    - type: $x_module_build_log_handle_t
      name: handle
      desc: "[in] handle of the buildlog object"
    - type: $xModule*
      name: pModule
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for kernel"
name: $xKernel
owner: $xModule
members:
    - type: $x_kernel_handle_t
      name: handle
      desc: "[in] handle of kernel object"
    - type: $xModule*
      name: pModule
      desc: "[in] pointer to owner object"
    - type: $x_kernel_desc_t
      name: desc
      desc: "[in] descriptor of the kernel object"