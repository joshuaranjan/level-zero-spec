#
# Copyright (C) 2019 Intel Corporation
#
# SPDX-License-Identifier: MIT
#
# See YaML.md for syntax definition
#
--- #--------------------------------------------------------------------------
type: header
desc: "Intel $OneApi Level-Zero Tool APIs for System Resource Management (Sysman) - Frequency domains"
--- #--------------------------------------------------------------------------
type: enum
desc: "Frequency domains."
class: $sDevice
name: $s_freq_domain_t
etors:
    - name: GPU
      value: "0"
      desc: "GPU Core Domain."
    - name: MEMORY
      desc: "Local Memory Domain."
--- #--------------------------------------------------------------------------
type: struct
desc: "Frequency properties"
class: $sFrequency
name: $s_freq_properties_t
base: $s_base_properties_t
details:
    - "Indicates if this frequency domain can be overclocked (if true, functions such as $sFrequencyOcSetConfig() are supported)."
    - "The min/max hardware frequencies are specified for non-overclock configurations. For overclock configurations, use $sFrequencyOcGetConfig() to determine the maximum frequency that can be requested."
members:
    - type: $s_freq_domain_t
      name: "type"
      desc: "[out] The hardware block that this frequency domain controls (GPU, memory, ...)"
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $x_bool_t
      name: canControl
      desc: "[out] Indicates if software can control the frequency of this domain assuming the user has permissions"
    - type: $x_bool_t
      name: isThrottleEventSupported
      desc: "[out] Indicates if software can register to receive event $S_EVENT_TYPE_FLAG_FREQ_THROTTLED"
    - type: double
      name: min
      desc: "[out] The minimum hardware clock frequency in units of MHz"
    - type: double
      name: max
      desc: "[out] The maximum non-overclock hardware clock frequency in units of MHz."
--- #--------------------------------------------------------------------------
type: struct
desc: "Frequency range between which the hardware can operate."
class: $sFrequency
name: $s_freq_range_t
members:
    - type: double
      name: "min"
      desc: "[in,out] The min frequency in MHz below which hardware frequency management will not request frequencies. Setting to 0 will use the hardware default value."
    - type: double
      name: "max"
      desc: "[in,out] The max frequency in MHz above which hardware frequency management will not request frequencies. Setting to 0 will use the hardware default value."
--- #--------------------------------------------------------------------------
type: enum
desc: "Frequency throttle reasons"
class: $sFrequency
name: $s_freq_throttle_reason_flags_t
etors:
    - name: AVE_PWR_CAP
      desc: "frequency throttled due to average power excursion (PL1)"
    - name: BURST_PWR_CAP
      desc: "frequency throttled due to burst power excursion (PL2)"
    - name: CURRENT_LIMIT
      desc: "frequency throttled due to current excursion (PL4)"
    - name: THERMAL_LIMIT
      desc: "frequency throttled due to thermal excursion (T > TjMax)"
    - name: PSU_ALERT
      desc: "frequency throttled due to power supply assertion"
    - name: SW_RANGE
      desc: "frequency throttled due to software supplied frequency range"
    - name: HW_RANGE
      desc: "frequency throttled due to a sub block that has a lower frequency range when it receives clocks"
--- #--------------------------------------------------------------------------
type: struct
desc: "Frequency state"
class: $sFrequency
name: $s_freq_state_t
members:
    - type: double
      name: "request"
      desc: "[out] The current frequency request in MHz."
    - type: double
      name: "tdp"
      desc: "[out] The maximum frequency in MHz supported under the current TDP conditions"
    - type: double
      name: "efficient"
      desc: "[out] The efficient minimum frequency in MHz"
    - type: double
      name: "actual"
      desc: "[out] The resolved frequency in MHz"
    - type: $s_freq_throttle_reason_flags_t
      name: "throttleReasons"
      desc: |
            [out] The reasons that the frequency is being limited by the hardware.
            Returns 0 (frequency not throttled) or a combination of $s_freq_throttle_reason_flag_t.
--- #--------------------------------------------------------------------------
type: struct
desc: "Frequency throttle time snapshot"
class: $sFrequency
name: $s_freq_throttle_time_t
details:
    - "Percent time throttled is calculated by taking two snapshots (s1, s2) and using the equation: %throttled = (s2.throttleTime - s1.throttleTime) / (s2.timestamp - s1.timestamp)"
members:
    - type: uint64_t
      name: "throttleTime"
      desc: "[out] The monotonic counter of time in microseconds that the frequency has been limited by the hardware."
    - type: uint64_t
      name: "timestamp"
      desc: |
            [out] Microsecond timestamp when throttleTime was captured.
            No assumption should be made about the absolute value of the timestamp.
            It should only be used to calculate delta time between two snapshots of the same structure.
            Never take the delta of this timestamp with the timestamp from a different structure.
--- #--------------------------------------------------------------------------
type: enum
desc: "Overclocking modes"
class: $sFrequency
name: $s_oc_mode_t
etors:
    - name: "OFF"
      value: "0"
      desc: "Overclocking if off - hardware is running using factory default voltages/frequencies."
    - name: OVERRIDE
      desc: "Overclock override mode - In this mode, a fixed user-supplied voltage is applied independent of the frequency request. The maximum permitted frequency can also be increased."
    - name: INTERPOLATIVE
      desc: "Overclock interpolative mode - In this mode, the voltage/frequency curve can be extended with a new voltage/frequency point that will be interpolated. The existing voltage/frequency points can also be offset (up or down) by a fixed voltage."
--- #--------------------------------------------------------------------------
type: struct
desc: "Overclocking properties"
class: $sFrequency
name: $s_oc_capabilities_t
details:
    - "Provides all the overclocking capabilities and properties supported by the device for the frequency domain."
members:
    - type: $x_bool_t
      name: isOcSupported
      desc: "[out] Indicates if any overclocking features are supported on this frequency domain."
    - type: double
      name: maxFactoryDefaultFrequency
      desc: "[out] Factory default non-overclock maximum frequency in Mhz."
    - type: double
      name: maxFactoryDefaultVoltage
      desc: "[out] Factory default voltage used for the non-overclock maximum frequency in MHz."
    - type: double
      name: maxOcFrequency
      desc: "[out] Maximum hardware overclocking frequency limit in Mhz."
    - type: double
      name: minOcVoltageOffset
      desc: "[out] The minimum voltage offset that can be applied to the voltage/frequency curve. Note that this number can be negative."
    - type: double
      name: maxOcVoltageOffset
      desc: "[out] The maximum voltage offset that can be applied to the voltage/frequency curve."
    - type: double
      name: maxOcVoltage
      desc: "[out] The maximum overclock voltage that hardware supports."
    - type: $x_bool_t
      name: isTjMaxSupported
      desc: "[out] Indicates if the maximum temperature limit (TjMax) can be changed for this frequency domain."
    - type: $x_bool_t
      name: isIccMaxSupported
      desc: "[out] Indicates if the maximum current (IccMax) can be changed for this frequency domain."
    - type: $x_bool_t
      name: isHighVoltModeCapable
      desc: "[out] Indicates if this frequency domains supports a feature to set very high voltages."
    - type: $x_bool_t
      name: isHighVoltModeEnabled
      desc: "[out] Indicates if very high voltages are permitted on this frequency domain."
--- #--------------------------------------------------------------------------
type: struct
desc: "Overclocking configuration"
class: $sFrequency
name: $s_oc_config_t
details:
    - "Overclock settings"
members:
    - type: $s_oc_mode_t
      name: mode
      desc: "[in,out] Overclock Mode $s_oc_mode_t."
    - type: double
      name: frequency
      desc: "[in,out] Overclocking Frequency in MHz. This cannot be greater than $s_oc_capabilities_t.maxOcFrequency."
    - type: double
      name: voltageTarget
      desc: "[in,out] Overclock voltage in Volts. This cannot be greater than $s_oc_capabilities_t.maxOcVoltage."
    - type: double
      name: voltageOffset
      desc: "[in,out] This voltage offset is applied to all points on the voltage/frequency curve, include the new overclock voltageTarget. It can be in the range ($s_oc_capabilities_t.minOcVoltageOffset, $s_oc_capabilities_t.maxOcVoltageOffset)."
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of frequency domains"
class: $sDevice
name: EnumFrequencyDomains
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_device_handle_t
      name: hDevice
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$s_freq_handle_t*"
      name: phFrequency
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get frequency properties - available frequencies"
class: $sFrequency
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $s_freq_properties_t*
      name: pProperties
      desc: "[in,out] The frequency properties for the specified domain."
--- #--------------------------------------------------------------------------
type: function
desc: "Get available non-overclocked hardware clock frequencies for the frequency domain"
class: $sFrequency
name: GetAvailableClocks
details:
    - "The list of available frequencies is returned in order of slowest to fastest."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_freq_handle_t
      name: hFrequency
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of frequencies.
            If count is zero, then the driver will update the value with the total number of frequencies available.
            If count is non-zero, then driver will only retrieve that number of frequencies.
            If count is larger than the number of frequencies available, then the driver will update the value with the correct number of frequencies available.
    - type: "double*"
      name: phFrequency
      desc: "[in,out][optional][range(0, *pCount)] array of frequencies in units of MHz and sorted from slowest to fastest"
--- #--------------------------------------------------------------------------
type: function
desc: "Get current frequency limits"
class: $sFrequency
name: GetRange
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $s_freq_range_t*
      name: pLimits
      desc: "[in,out] The range between which the hardware can operate for the specified domain."
--- #--------------------------------------------------------------------------
type: function
desc: "Set frequency range between which the hardware can operate."
class: $sFrequency
name: SetRange
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: const $s_freq_range_t*
      name: pLimits
      desc: "[in] The limits between which the hardware can operate for the specified domain."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make these modifications."
--- #--------------------------------------------------------------------------
type: function
desc: "Get current frequency state - frequency request, actual frequency, TDP limits"
class: $sFrequency
name: GetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $s_freq_state_t*
      name: pState
      desc: "[in,out] Frequency state for the specified domain."
--- #--------------------------------------------------------------------------
type: function
desc: "Get frequency throttle time"
class: $sFrequency
name: GetThrottleTime
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $s_freq_throttle_time_t*
      name: pThrottleTime
      desc: "[in,out] Will contain a snapshot of the throttle time counters for the specified domain."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the overclocking capabilities."
class: $sFrequency
name: OcGetCapabilities
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $s_oc_capabilities_t*
      name: pOcCapabilities
      desc: "[in,out] Pointer to the capabilities structure $s_oc_capabilities_t."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the current overclocking configuration."
class: $sFrequency
name: OcGetConfig
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $s_oc_config_t*
      name: pOcConfiguration
      desc: "[in,out] Pointer to the configuration structure $s_oc_config_t."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Overclocking is not supported on this frequency domain ($s_oc_capabilities_t.isOcSupported)"
--- #--------------------------------------------------------------------------
type: function
desc: "Change the overclocking configuration."
class: $sFrequency
name: OcSetConfig
details:
    - "If $s_oc_config_t.mode is set to $S_OC_MODE_OFF, overclocking will be turned off and the hardware returned to run with factory voltages/frequencies. Call $sFrequencyOcSetIccMax() and $sFrequencyOcSetTjMax() separately with 0.0 to return those settings to factory defaults."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $s_oc_config_t*
      name: pOcConfiguration
      desc: "[in] Pointer to the configuration structure $s_oc_config_t."
    - type: $x_bool_t*
      name: pDeviceRestart
      desc: "[in,out] This will be set to true if the device needs to be restarted in order to enable the new overclock settings."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Overclocking is not supported on this frequency domain ($s_oc_capabilities_t.isOcSupported)"
        - "The specified voltage and/or frequency overclock settings exceed the hardware values (see $s_oc_capabilities_t.maxOcFrequency, $s_oc_capabilities_t.maxOcVoltage, $s_oc_capabilities_t.minOcVoltageOffset, $s_oc_capabilities_t.maxOcVoltageOffset)."
        - "Requested voltage overclock is very high but $s_oc_capabilities_t.isHighVoltModeEnabled is not enabled for the device."
    - $X_RESULT_ERROR_NOT_AVAILABLE:
        - "Overclocking feature is locked on this frequency domain"
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make these modifications."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the maximum current limit setting."
class: $sFrequency
name: OcGetIccMax
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: double*
      name: pOcIccMax
      desc: "[in,out] Will contain the maximum current limit in Amperes on successful return."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Overclocking is not supported on this frequency domain ($s_oc_capabilities_t.isOcSupported)"
        - "Capability $s_oc_capabilities_t.isIccMaxSupported is false for this frequency domain"
--- #--------------------------------------------------------------------------
type: function
desc: "Change the maximum current limit setting."
class: $sFrequency
name: OcSetIccMax
details:
    - "Setting ocIccMax to 0.0 will return the value to the factory default."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: double
      name: ocIccMax
      desc: "[in] The new maximum current limit in Amperes."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Overclocking is not supported on this frequency domain ($s_oc_capabilities_t.isOcSupported)"
        - "Capability $s_oc_capabilities_t.isIccMaxSupported is false for this frequency domain"
    - $X_RESULT_ERROR_NOT_AVAILABLE:
        - "Overclocking feature is locked on this frequency domain"
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The specified current limit is too low or too high"
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make these modifications."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the maximum temperature limit setting."
class: $sFrequency
name: OcGetTjMax
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: double*
      name: pOcTjMax
      desc: "[in,out] Will contain the maximum temperature limit in degrees Celsius on successful return."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Overclocking is not supported on this frequency domain ($s_oc_capabilities_t.isOcSupported)"
--- #--------------------------------------------------------------------------
type: function
desc: "Change the maximum temperature limit setting."
class: $sFrequency
name: OcSetTjMax
details:
    - "Setting ocTjMax to 0.0 will return the value to the factory default."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: double
      name: ocTjMax
      desc: "[in] The new maximum temperature limit in degrees Celsius."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Overclocking is not supported on this frequency domain ($s_oc_capabilities_t.isOcSupported)"
        - "Capability $s_oc_capabilities_t.isTjMaxSupported is false for this frequency domain"
    - $X_RESULT_ERROR_NOT_AVAILABLE:
        - "Overclocking feature is locked on this frequency domain"
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The specified temperature limit is too high"
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make these modifications."
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device frequency domain"
name: $sFrequency
owner: $sDevice
members:
    - type: $s_freq_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $sDevice*
      name: pDevice
      desc: "[in] pointer to owner object"
