#
# Copyright (C) 2019 Intel Corporation
#
# SPDX-License-Identifier: MIT
#
# See YaML.md for syntax definition
#
--- #--------------------------------------------------------------------------
type: header
desc: "Intel $OneApi Level-Zero Tool APIs for System Resource Management (Sysman)"
--- #--------------------------------------------------------------------------
type: enum
desc: "API version of Sysman"
class: $sSysman
name: $s_sysman_version_t
etors:
    - name: $S_SYSMAN_VERSION_CURRENT
      value: "$X_MAKE_VERSION( 0, 91 )"
      desc: "version 0.91"
--- #--------------------------------------------------------------------------
type: function
desc: "Get the handle to access Sysman features for a device"
class: $sSysman
name: Get
decl: static
details:
    - "The returned handle is unique."
    - "$s_device_handle_t returned by $xDeviceGetSubDevices() are not support. Only use handles returned by $xDeviceGet(). All resources on sub-devices can be enumerated through the primary device."
params:
    - type: "$s_device_handle_t"
      name: hDevice
      desc: "[in] Handle of the device"
    - type: "$s_sysman_version_t"
      name: version
      desc: "[in] Sysman version that application was built with"
    - type: "$s_sysman_handle_t*"
      name: phSysman
      desc: "[out] Handle for accessing Sysman features"
--- #--------------------------------------------------------------------------
type: macro
desc: "Maximum number of characters in string properties."
name: $S_STRING_PROPERTY_SIZE
value: "64"
--- #--------------------------------------------------------------------------
type: enum
desc: "Types of accelerator engines"
class: $sSysman
name: $s_engine_type_t
etors:
    - name: $S_ENGINE_TYPE_OTHER
      value: "0"
      desc: "Undefined types of accelerators."
    - name: $S_ENGINE_TYPE_COMPUTE
      desc: "Engines that process compute kernels."
    - name: $S_ENGINE_TYPE_3D
      desc: "Engines that process 3D content"
    - name: $S_ENGINE_TYPE_MEDIA
      desc: "Engines that process media workloads"
    - name: $S_ENGINE_TYPE_DMA
      desc: "Engines that copy blocks of data"
--- #--------------------------------------------------------------------------
type: enum
desc: "Device repair status"
class: $sSysman
name: $s_repair_status_t
etors:
    - name: $S_REPAIR_STATUS_UNSUPPORTED
      value: "0"
      desc: "The device does not support in-field repairs."
    - name: $S_REPAIR_STATUS_NOT_PERFORMED
      desc: "The device has never been repaired."
    - name: $S_REPAIR_STATUS_PERFORMED
      desc: "The device has been repaired."
--- #--------------------------------------------------------------------------
type: enum
desc: "Device reset reasons"
class: $sSysman
name: $s_reset_reasons_t
etors:
    - name: $S_RESET_REASONS_NONE
      value: "0"
      desc: "The device does not need to be reset"
    - name: $S_RESET_REASONS_WEDGED
      value: "$X_BIT( 0 )"
      desc: "The device needs to be reset because one or more parts of the hardware is wedged"
    - name: $S_RESET_REASONS_REPAIR
      value: "$X_BIT( 1 )"
      desc: "The device needs to be reset in order to complete in-field repairs"
--- #--------------------------------------------------------------------------
type: struct
desc: "Device state"
class: $sSysman
name: $s_sysman_state_t
members:
    - type: uint32_t
      name: reset
      desc: "[out] Indicates if the device needs to be reset and for what reasons (bitfield of $s_reset_reasons_t)"
    - type: $s_repair_status_t
      name: repaired
      desc: "[out] Indicates if the device has been repaired"
--- #--------------------------------------------------------------------------
type: struct
desc: "Device properties"
class: $sSysman
name: $s_sysman_properties_t
members:
    - type: $x_device_properties_t
      name: core
      desc: "[out] Core device properties"
    - type: uint32_t
      name: "numSubdevices"
      desc: "[out] Number of sub-devices"
    - type: int8_t
      name: "serialNumber[$S_STRING_PROPERTY_SIZE]"
      desc: "[out] Manufacturing serial number (NULL terminated string value)"
    - type: int8_t
      name: "boardNumber[$S_STRING_PROPERTY_SIZE]"
      desc: "[out] Manufacturing board number (NULL terminated string value)"
    - type: int8_t
      name: "brandName[$S_STRING_PROPERTY_SIZE]"
      desc: "[out] Brand name of the device (NULL terminated string value)"
    - type: int8_t
      name: "modelName[$S_STRING_PROPERTY_SIZE]"
      desc: "[out] Model name of the device (NULL terminated string value)"
    - type: int8_t
      name: "vendorName[$S_STRING_PROPERTY_SIZE]"
      desc: "[out] Vendor name of the device (NULL terminated string value)"
    - type: int8_t
      name: "driverVersion[$S_STRING_PROPERTY_SIZE]"
      desc: "[out] Installed driver version (NULL terminated string value)"
--- #--------------------------------------------------------------------------
type: function
desc: "Get properties about the device"
class: $sSysman
name: DeviceGetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: $s_sysman_properties_t*
      name: pProperties
      desc: "[in,out] Structure that will contain information about the device."
--- #--------------------------------------------------------------------------
type: function
desc: "Get information about the state of the device - if a reset is required, reasons for the reset and if the device has been repaired"
class: $sSysman
name: DeviceGetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: $s_sysman_state_t*
      name: pState
      desc: "[in,out] Structure that will contain information about the device."
--- #--------------------------------------------------------------------------
type: function
desc: "Reset device"
class: $sSysman
name: DeviceReset
details:
    - "Performs a PCI bus reset of the device. This will result in all current device state being lost."
    - "All applications using the device should be stopped before calling this function."
    - "If the force argument is specified, all applications using the device will be forcibly killed."
    - "The function will block until the device has restarted or a timeout occurred waiting for the reset to complete."
params:
    - type: $s_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle for the device"
    - type: $x_bool_t
      name: force
      desc: "[in] If set to true, all applications that are currently using the device will be forcibly killed."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to perform this operation."
    - $X_RESULT_ERROR_HANDLE_OBJECT_IN_USE
        - "Reset cannot be performed because applications are using this device."
    - $X_RESULT_ERROR_UNKNOWN
        - "There were problems unloading the device driver, performing a bus reset or reloading the device driver."
--- #--------------------------------------------------------------------------
type: enum
desc: "Scheduler mode"
class: $sSysman
name: $s_sched_mode_t
etors:
    - name: $S_SCHED_MODE_TIMEOUT
      value: "0"
      desc: "Multiple applications or contexts are submitting work to the hardware. When higher priority work arrives, the scheduler attempts to pause the current executing work within some timeout interval, then submits the other work."
    - name: $S_SCHED_MODE_TIMESLICE
      desc: "The scheduler attempts to fairly timeslice hardware execution time between multiple contexts submitting work to the hardware concurrently."
    - name: $S_SCHED_MODE_EXCLUSIVE
      desc: "Any application or context can run indefinitely on the hardware without being preempted or terminated. All pending work for other contexts must wait until the running context completes with no further submitted work."
    - name: $S_SCHED_MODE_COMPUTE_UNIT_DEBUG
      desc: "Scheduler ensures that submission of workloads to the hardware is optimized for compute unit debugging."
--- #--------------------------------------------------------------------------
type: struct
desc: "Properties related to scheduler component"
class: $sSysmanScheduler
name: $s_sched_properties_t
members:
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $x_bool_t
      name: "canControl"
      desc: "[out] Software can change the scheduler component configuration assuming the user has permissions."
    - type: uint64_t
      name: "engines"
      desc: "[out] Bitfield of accelerator engines that are controlled by this scheduler component (bitfield of 1<<$s_engine_type_t)."
    - type: uint32_t
      name: "supportedModes"
      desc: "[out] Bitfield of scheduler modes that can be configured for this scheduler component (bitfield of 1<<$s_sched_mode_t)."
--- #--------------------------------------------------------------------------
type: macro
desc: "Disable forward progress guard timeout."
name: $S_SCHED_WATCHDOG_DISABLE
value: "(~(0ULL))"
--- #--------------------------------------------------------------------------
type: struct
desc: "Configuration for timeout scheduler mode ($S_SCHED_MODE_TIMEOUT)"
class: $sSysman
name: $s_sched_timeout_properties_t
members:
    - type: uint64_t
      name: "watchdogTimeout"
      desc: "[in,out] The maximum time in microseconds that the scheduler will wait for a batch of work submitted to a hardware engine to complete or to be preempted so as to run another context. "
      desc: |
            [in,out] The maximum time in microseconds that the scheduler will wait for a batch of work submitted to a hardware engine to complete or to be preempted so as to run another context.
            If this time is exceeded, the hardware engine is reset and the context terminated.
            If set to $S_SCHED_WATCHDOG_DISABLE, a running workload can run as long as it wants without being terminated, but preemption attempts to run other contexts are permitted but not enforced.
--- #--------------------------------------------------------------------------
type: struct
desc: "Configuration for timeslice scheduler mode ($S_SCHED_MODE_TIMESLICE)"
class: $sSysman
name: $s_sched_timeslice_properties_t
members:
    - type: uint64_t
      name: "interval"
      desc: "[in,out] The average interval in microseconds that a submission for a context will run on a hardware engine before being preempted out to run a pending submission for another context."
    - type: uint64_t
      name: "yieldTimeout"
      desc: "[in,out] The maximum time in microseconds that the scheduler will wait to preempt a workload running on an engine before deciding to reset the hardware engine and terminating the associated context."
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle to a scheduler component"
class: $sSysman
name: SchedulerGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$s_sysman_sched_handle_t*"
      name: phScheduler
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get properties related to a scheduler component"
class: $sSysmanScheduler
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_sched_handle_t
      name: hScheduler
      desc: "[in] Handle for the component."
    - type: $s_sched_properties_t*
      name: pProperties
      desc: "[in,out] Structure that will contain property data."
--- #--------------------------------------------------------------------------
type: function
desc: "Get current scheduling mode in effect on a scheduler component."
class: $sSysmanScheduler
name: GetCurrentMode
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_sched_handle_t
      name: hScheduler
      desc: "[in] Sysman handle for the component."
    - type: $s_sched_mode_t*
      name: pMode
      desc: "[in,out] Will contain the current scheduler mode."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "This scheduler component does not support scheduler modes."
--- #--------------------------------------------------------------------------
type: function
desc: "Get scheduler config for mode $S_SCHED_MODE_TIMEOUT"
class: $sSysmanScheduler
name: GetTimeoutModeProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_sched_handle_t
      name: hScheduler
      desc: "[in] Sysman handle for the component."
    - type: $x_bool_t
      name: getDefaults
      desc: "[in] If TRUE, the driver will return the system default properties for this mode, otherwise it will return the current properties."
    - type: $s_sched_timeout_properties_t*
      name: pConfig
      desc: "[in,out] Will contain the current parameters for this mode."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "This scheduler component does not support scheduler modes."
--- #--------------------------------------------------------------------------
type: function
desc: "Get scheduler config for mode $S_SCHED_MODE_TIMESLICE"
class: $sSysmanScheduler
name: GetTimesliceModeProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_sched_handle_t
      name: hScheduler
      desc: "[in] Sysman handle for the component."
    - type: $x_bool_t
      name: getDefaults
      desc: "[in] If TRUE, the driver will return the system default properties for this mode, otherwise it will return the current properties."
    - type: $s_sched_timeslice_properties_t*
      name: pConfig
      desc: "[in,out] Will contain the current parameters for this mode."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "This scheduler component does not support scheduler modes."
--- #--------------------------------------------------------------------------
type: function
desc: "Change scheduler mode to $S_SCHED_MODE_TIMEOUT or update scheduler mode parameters if already running in this mode."
class: $sSysmanScheduler
name: SetTimeoutMode
details:
    - "This mode is optimized for multiple applications or contexts submitting work to the hardware. When higher priority work arrives, the scheduler attempts to pause the current executing work within some timeout interval, then submits the other work."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_sched_handle_t
      name: hScheduler
      desc: "[in] Sysman handle for the component."
    - type: $s_sched_timeout_properties_t*
      name: pProperties
      desc: "[in] The properties to use when configurating this mode."
    - type: $x_bool_t*
      name: pNeedReload
      desc: "[in,out] Will be set to TRUE if a device driver reload is needed to apply the new scheduler mode."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "This scheduler component does not support scheduler modes."
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make this modification."
--- #--------------------------------------------------------------------------
type: function
desc: "Change scheduler mode to $S_SCHED_MODE_TIMESLICE or update scheduler mode parameters if already running in this mode."
class: $sSysmanScheduler
name: SetTimesliceMode
details:
    - "This mode is optimized to provide fair sharing of hardware execution time between multiple contexts submitting work to the hardware concurrently."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_sched_handle_t
      name: hScheduler
      desc: "[in] Sysman handle for the component."
    - type: $s_sched_timeslice_properties_t*
      name: pProperties
      desc: "[in] The properties to use when configurating this mode."
    - type: $x_bool_t*
      name: pNeedReload
      desc: "[in,out] Will be set to TRUE if a device driver reload is needed to apply the new scheduler mode."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "This scheduler component does not support scheduler modes."
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make this modification."
--- #--------------------------------------------------------------------------
type: function
desc: "Change scheduler mode to $S_SCHED_MODE_EXCLUSIVE"
class: $sSysmanScheduler
name: SetExclusiveMode
details:
    - "This mode is optimized for single application/context use-cases. It permits a context to run indefinitely on the hardware without being preempted or terminated. All pending work for other contexts must wait until the running context completes with no further submitted work."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_sched_handle_t
      name: hScheduler
      desc: "[in] Sysman handle for the component."
    - type: $x_bool_t*
      name: pNeedReload
      desc: "[in,out] Will be set to TRUE if a device driver reload is needed to apply the new scheduler mode."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "This scheduler component does not support scheduler modes."
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make this modification."
--- #--------------------------------------------------------------------------
type: function
desc: "Change scheduler mode to $S_SCHED_MODE_COMPUTE_UNIT_DEBUG"
class: $sSysmanScheduler
name: SetComputeUnitDebugMode
details:
    - "This mode is optimized for application debug. It ensures that only one command queue can execute work on the hardware at a given time. Work is permitted to run as long as needed without enforcing any scheduler fairness policies."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_sched_handle_t
      name: hScheduler
      desc: "[in] Sysman handle for the component."
    - type: $x_bool_t*
      name: pNeedReload
      desc: "[in,out] Will be set to TRUE if a device driver reload is needed to apply the new scheduler mode."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "This scheduler component does not support scheduler modes."
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make this modification."

--- #--------------------------------------------------------------------------
type: struct
desc: "Static information about a Performance Factor domain"
class: $sSysmanPerformanceFactor
name: $s_perf_properties_t
members:
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if this Performance Factor affects accelerators located on a sub-device"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: uint64_t
      name: "engines"
      desc: "[out] Bitfield of accelerator engines that are affected by this Performance Factor (bitfield of 1<<$s_engine_type_t)."
--- #--------------------------------------------------------------------------
type: function
desc: "Get handles to accelerator domains whose performance can be optimized via a Performance Factor"
class: $sSysman
name: PerformanceFactorGet
details:
    - "A Performance Factor should be tuned for each workload."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$s_sysman_perf_handle_t*"
      name: phPerf
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get properties about a Performance Factor domain"
class: $sSysmanPerformanceFactor
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_perf_handle_t
      name: hPerf
      desc: "[in] Handle for the Performance Factor domain."
    - type: $s_perf_properties_t*
      name: pProperties
      desc: "[in,out] Will contain information about the specified Performance Factor domain."
--- #--------------------------------------------------------------------------
type: function
desc: "Get current Performance Factor for a given domain"
class: $sSysmanPerformanceFactor
name: GetConfig
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_perf_handle_t
      name: hPerf
      desc: "[in] Handle for the Performance Factor domain."
    - type: double*
      name: pFactor
      desc: "[in,out] Will contain the actual Performance Factor being used by the hardware (may not be the same as the requested Performance Factor)."
--- #--------------------------------------------------------------------------
type: function
desc: "Change the performance factor for a domain"
class: $sSysmanPerformanceFactor
name: SetConfig
details:
    - "The Performance Factor is a number between 0 and 100."
    - "A Performance Factor is a hint to the hardware. Depending on the hardware, the request may not be granted. Follow up this function with a call to $sSysmanPerformanceFactorGetConfig() to determine the actual factor being used by the hardware."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_perf_handle_t
      name: hPerf
      desc: "[in] Handle for the Performance Factor domain."
    - type: double
      name: factor
      desc: "[in] The new Performance Factor."

--- #--------------------------------------------------------------------------
type: struct
desc: "Contains information about a process that has an open connection with this device"
class: $sSysman
name: $s_process_state_t
details:
    - "The application can use the process ID to query the OS for the owner and the path to the executable."
members:
    - type: uint32_t
      name: "processId"
      desc: "[out] Host OS process ID."
    - type: int64_t
      name: "memSize"
      desc: "[out] Device memory size in bytes allocated by this process (may not necessarily be resident on the device at the time of reading)."
    - type: uint64_t
      name: "engines"
      desc: "[out] Bitfield of accelerator engines being used by this process (or 1<<$s_engine_type_t together)."
--- #--------------------------------------------------------------------------
type: function
desc: "Get information about host processes using the device"
class: $sSysman
name: ProcessesGetState
details:
    - "The number of processes connected to the device is dynamic. This means that between a call to determine the correct value of pCount and the subsequent call, the number of processes may have increased. It is recommended that a large array be passed in so as to avoid receiving the error $X_RESULT_ERROR_INVALID_SIZE."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle for the device"
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of processes.
            if count is zero, then the driver will update the value with the total number of processes currently using the device.
            if count is non-zero but less than the number of processes, the driver will set to the number of processes currently using the device and return the error $X_RESULT_ERROR_INVALID_SIZE.
            if count is larger than the number of processes, then the driver will update the value with the correct number of processes that are returned.
    - type: "$s_process_state_t*"
      name: pProcesses
      desc: "[in,out][optional][range(0, *pCount)] array of process information, one for each process currently using the device"
returns:
    - $X_RESULT_ERROR_INVALID_SIZE:
        - "The provided value of pCount is not big enough to store information about all the processes currently attached to the device."
--- #--------------------------------------------------------------------------
type: struct
desc: "PCI address"
class: $sSysman
name: $s_pci_address_t
members:
    - type: uint32_t
      name: "domain"
      desc: "[out] BDF domain"
    - type: uint32_t
      name: "bus"
      desc: "[out] BDF bus"
    - type: uint32_t
      name: "device"
      desc: "[out] BDF device"
    - type: uint32_t
      name: "function"
      desc: "[out] BDF function"
--- #--------------------------------------------------------------------------
type: struct
desc: "PCI speed"
class: $sSysman
name: $s_pci_speed_t
members:
    - type: uint32_t
      name: "gen"
      desc: "[out] The link generation"
    - type: uint32_t
      name: "width"
      desc: "[out] The number of lanes"
    - type: uint64_t
      name: "maxBandwidth"
      desc: "[out] The maximum bandwidth in bytes/sec"
--- #--------------------------------------------------------------------------
type: struct
desc: "Static PCI properties"
class: $sSysman
name: $s_pci_properties_t
members:
    - type: $s_pci_address_t
      name: "address"
      desc: "[out] The BDF address"
    - type: $s_pci_speed_t
      name: "maxSpeed"
      desc: "[out] Fastest port configuration supported by the device."
--- #--------------------------------------------------------------------------
type: enum
desc: "PCI link status"
class: $sSysman
name: $s_pci_link_status_t
etors:
    - name: $S_PCI_LINK_STATUS_GREEN
      value: "0"
      desc: "The link is up and operating as expected"
    - name: $S_PCI_LINK_STATUS_YELLOW
      desc: "The link is up but has quality and/or bandwidth degradation"
    - name: $S_PCI_LINK_STATUS_RED
      desc: "The link has stability issues and preventing workloads making forward progress"
--- #--------------------------------------------------------------------------
type: enum
desc: "PCI link quality degradation reasons"
class: $sSysman
name: $s_pci_link_qual_issues_t
etors:
    - name: $S_PCI_LINK_QUAL_ISSUES_NONE
      value: "0"
      desc: "There are no quality issues with the link at this time"
    - name: $S_PCI_LINK_QUAL_ISSUES_REPLAYS
      value: "$X_BIT( 0 )"
      desc: "An significant number of replays are occurring"
    - name: $S_PCI_LINK_QUAL_ISSUES_SPEED
      value: "$X_BIT( 1 )"
      desc: "There is a degradation in the maximum bandwidth of the link"
--- #--------------------------------------------------------------------------
type: enum
desc: "PCI link stability issues"
class: $sSysman
name: $s_pci_link_stab_issues_t
etors:
    - name: $S_PCI_LINK_STAB_ISSUES_NONE
      value: "0"
      desc: "There are no connection stability issues at this time"
    - name: $S_PCI_LINK_STAB_ISSUES_RETRAINING
      value: "$X_BIT( 0 )"
      desc: "Link retraining has occurred to deal with quality issues"
--- #--------------------------------------------------------------------------
type: struct
desc: "Dynamic PCI state"
class: $sSysman
name: $s_pci_state_t
members:
    - type: $s_pci_link_status_t
      name: "status"
      desc: "[out] The current status of the port"
    - type: $s_pci_link_qual_issues_t
      name: "qualityIssues"
      desc: "[out] If status is $S_PCI_LINK_STATUS_YELLOW, this gives a bitfield of quality issues that have been detected"
    - type: $s_pci_link_stab_issues_t
      name: "stabilityIssues"
      desc: "[out] If status is $S_PCI_LINK_STATUS_RED, this gives a bitfield of reasons for the connection instability"
    - type: $s_pci_speed_t
      name: "speed"
      desc: "[out] The current port configure speed"
--- #--------------------------------------------------------------------------
type: enum
desc: "PCI bar types"
class: $sSysman
name: $s_pci_bar_type_t
etors:
    - name: $S_PCI_BAR_TYPE_MMIO
      value: "0"
      desc: "MMIO registers"
    - name: $S_PCI_BAR_TYPE_ROM
      desc: "ROM aperture"
    - name: $S_PCI_BAR_TYPE_MEM
      desc: "Device memory"
--- #--------------------------------------------------------------------------
type: struct
desc: "Properties of a pci bar"
class: $sSysman
name: $s_pci_bar_properties_t
members:
    - type: $s_pci_bar_type_t
      name: "type"
      desc: "[out] The type of bar"
    - type: uint32_t
      name: "index"
      desc: "[out] The index of the bar"
    - type: uint64_t
      name: "base"
      desc: "[out] Base address of the bar."
    - type: uint64_t
      name: "size"
      desc: "[out] Size of the bar."
--- #--------------------------------------------------------------------------
type: struct
desc: "PCI stats counters"
class: $sSysman
name: $s_pci_stats_t
details:
    - "Percent throughput is calculated by taking two snapshots (s1, s2) and using the equation: %bw = 10^6 * ((s2.rxCounter - s1.rxCounter) + (s2.txCounter - s1.txCounter)) / (s2.maxBandwidth * (s2.timestamp - s1.timestamp))"
    - "Percent replays is calculated by taking two snapshots (s1, s2) and using the equation: %replay = 10^6 * (s2.replayCounter - s1.replayCounter) / (s2.maxBandwidth * (s2.timestamp - s1.timestamp))"
members:
    - type: uint64_t
      name: "timestamp"
      desc: |
            [out] Monotonic timestamp counter in microseconds when the measurement was made.
            No assumption should be made about the absolute value of the timestamp.
            It should only be used to calculate delta time between two snapshots of the same structure.
            Never take the delta of this timestamp with the timestamp from a different structure.
    - type: uint64_t
      name: "replayCounter"
      desc: "[out] Monotonic counter for the number of replay packets"
    - type: uint64_t
      name: "packetCounter"
      desc: "[out] Monotonic counter for the number of packets"
    - type: uint64_t
      name: "rxCounter"
      desc: "[out] Monotonic counter for the number of bytes received"
    - type: uint64_t
      name: "txCounter"
      desc: "[out] Monotonic counter for the number of bytes transmitted (including replays)"
    - type: $s_pci_speed_t
      name: "speed"
      desc: "[out] The current speed of the link"
--- #--------------------------------------------------------------------------
type: function
desc: "Get PCI properties - address, max speed"
class: $sSysman
name: PciGetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: $s_pci_properties_t*
      name: pProperties
      desc: "[in,out] Will contain the PCI properties."
--- #--------------------------------------------------------------------------
type: function
desc: "Get current PCI state - current speed"
class: $sSysman
name: PciGetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: $s_pci_state_t*
      name: pState
      desc: "[in,out] Will contain the PCI properties."
--- #--------------------------------------------------------------------------
type: function
desc: "Get information about each configured bar"
class: $sSysman
name: PciGetBars
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of PCI bars.
            if count is zero, then the driver will update the value with the total number of bars.
            if count is non-zero, then driver will only retrieve that number of bars.
            if count is larger than the number of bar, then the driver will update the value with the correct number of bars that are returned.
    - type: "$s_pci_bar_properties_t*"
      name: pProperties
      desc: "[in,out][optional][range(0, *pCount)] array of bar properties"
--- #--------------------------------------------------------------------------
type: function
desc: "Get PCI stats - bandwidth, number of packets, number of replays"
class: $sSysman
name: PciGetStats
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: $s_pci_stats_t*
      name: pStats
      desc: "[in,out] Will contain a snapshot of the latest stats."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to query this telemetry."
--- #--------------------------------------------------------------------------
type: struct
desc: "Properties related to device power settings"
class: $sSysmanPower
name: $s_power_properties_t
members:
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $x_bool_t
      name: "canControl"
      desc: "[out] Software can change the power limits of this domain assuming the user has permissions."
    - type: $x_bool_t
      name: "isEnergyThresholdSupported"
      desc: "[out] Indicates if this power domain supports the energy threshold event ($S_SYSMAN_EVENT_TYPE_ENERGY_THRESHOLD_CROSSED)."
    - type: uint32_t
      name: "defaultLimit"
      desc: "[out] The factory default TDP power limit of the part in milliwatts."  
    - type: uint32_t
      name: "minLimit"
      desc: "[out] The minimum power limit in milliwatts that can be requested."  
    - type: uint32_t
      name: "maxLimit"
      desc: "[out] The maximum power limit in milliwatts that can be requested."  
--- #--------------------------------------------------------------------------
type: struct
desc: "Energy counter snapshot"
class: $sSysmanPower
name: $s_power_energy_counter_t
details:
    - "Average power is calculated by taking two snapshots (s1, s2) and using the equation: PowerWatts = (s2.energy - s1.energy) / (s2.timestamp - s1.timestamp)"
members:
    - type: uint64_t
      name: "energy"
      desc: "[out] The monotonic energy counter in microjoules."
    - type: uint64_t
      name: "timestamp"
      desc: |
            [out] Microsecond timestamp when energy was captured.
            No assumption should be made about the absolute value of the timestamp.
            It should only be used to calculate delta time between two snapshots of the same structure.
            Never take the delta of this timestamp with the timestamp from a different structure.
--- #--------------------------------------------------------------------------
type: struct
desc: "Sustained power limits"
class: $sSysmanPower
name: $s_power_sustained_limit_t
details:
    - "The power controller (Punit) will throttle the operating frequency if the power averaged over a window (typically seconds) exceeds this limit."
members:
    - type: $x_bool_t
      name: enabled
      desc: "[in,out] indicates if the limit is enabled (true) or ignored (false)"
    - type: uint32_t
      name: power
      desc: "[in,out] power limit in milliwatts"
    - type: uint32_t
      name: interval
      desc: "[in,out] power averaging window (Tau) in milliseconds"
--- #--------------------------------------------------------------------------
type: struct
desc: "Burst power limit"
class: $sSysmanPower
name: $s_power_burst_limit_t
details:
    - "The power controller (Punit) will throttle the operating frequency of the device if the power averaged over a few milliseconds exceeds a limit known as PL2. Typically PL2 > PL1 so that it permits the frequency to burst higher for short periods than would be otherwise permitted by PL1."
members:
    - type: $x_bool_t
      name: enabled
      desc: "[in,out] indicates if the limit is enabled (true) or ignored (false)"
    - type: uint32_t
      name: power
      desc: "[in,out] power limit in milliwatts"
--- #--------------------------------------------------------------------------
type: struct
desc: "Peak power limit"
class: $sSysmanPower
name: $s_power_peak_limit_t
details:
    - "The power controller (Punit) will preemptively throttle the operating frequency of the device when the instantaneous power exceeds this limit. The limit is known as PL4. It expresses the maximum power that can be drawn from the power supply."
    - "If this power limit is removed or set too high, the power supply will generate an interrupt when it detects an overcurrent condition and the power controller will throttle the device frequencies down to min. It is thus better to tune the PL4 value in order to avoid such excursions."
members:
    - type: uint32_t
      name: powerAC
      desc: "[in,out] power limit in milliwatts for the AC power source."
    - type: uint32_t
      name: powerDC
      desc: "[in,out] power limit in milliwatts for the DC power source. This is ignored if the product does not have a battery."
--- #--------------------------------------------------------------------------
type: struct
desc: "Energy threshold"
class: $sSysmanPower
name: $s_energy_threshold_t
details:
    - "."
members:
    - type: $x_bool_t
      name: enable
      desc: "[in,out] Indicates if the energy threshold is enabled."
    - type: double
      name: threshold
      desc: "[in,out] The energy threshold in Joules. Will be 0.0 if no threshold has been set."
    - type: uint32_t
      name: processId
      desc: "[in,out] The host process ID that set the energy threshold. Will be 0xFFFFFFFF if no threshold has been set."
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of power domains"
class: $sSysman
name: PowerGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$s_sysman_pwr_handle_t*"
      name: phPower
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get properties related to a power domain"
class: $sSysmanPower
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_pwr_handle_t
      name: hPower
      desc: "[in] Handle for the component."
    - type: $s_power_properties_t*
      name: pProperties
      desc: "[in,out] Structure that will contain property data."
--- #--------------------------------------------------------------------------
type: function
desc: "Get energy counter"
class: $sSysmanPower
name: GetEnergyCounter
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_pwr_handle_t
      name: hPower
      desc: "[in] Handle for the component."
    - type: $s_power_energy_counter_t*
      name: pEnergy
      desc: "[in,out] Will contain the latest snapshot of the energy counter and timestamp when the last counter value was measured."
--- #--------------------------------------------------------------------------
type: function
desc: "Get power limits"
class: $sSysmanPower
name: GetLimits
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_pwr_handle_t
      name: hPower
      desc: "[in] Handle for the component."
    - type: $s_power_sustained_limit_t*
      name: pSustained
      desc: "[in,out][optional] The sustained power limit."
    - type: $s_power_burst_limit_t*
      name: pBurst
      desc: "[in,out][optional] The burst power limit."
    - type: $s_power_peak_limit_t*
      name: pPeak
      desc: "[in,out][optional] The peak power limit."
--- #--------------------------------------------------------------------------
type: function
desc: "Set power limits"
class: $sSysmanPower
name: SetLimits
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_pwr_handle_t
      name: hPower
      desc: "[in] Handle for the component."
    - type: const $s_power_sustained_limit_t*
      name: pSustained
      desc: "[in][optional] The sustained power limit."
    - type: const $s_power_burst_limit_t*
      name: pBurst
      desc: "[in][optional] The burst power limit."
    - type: const $s_power_peak_limit_t*
      name: pPeak
      desc: "[in][optional] The peak power limit."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make these modifications."
    - $X_RESULT_ERROR_NOT_AVAILABLE:
        - "The device is in use, meaning that the GPU is under Over clocking, applying power limits under overclocking is not supported."
--- #--------------------------------------------------------------------------
type: function
desc: "Get energy threshold"
class: $sSysmanPower
name: GetEnergyThreshold
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_pwr_handle_t
      name: hPower
      desc: "[in] Handle for the component."
    - type: $s_energy_threshold_t*
      name: pThreshold
      desc: "[in,out] Returns information about the energy threshold setting - enabled/energy threshold/process ID."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Energy threshold not supported on this power domain (check $s_power_properties_t.isEnergyThresholdSupported)."
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to request this feature."
--- #--------------------------------------------------------------------------
type: function
desc: "Set energy threshold"
class: $sSysmanPower
name: SetEnergyThreshold
details:
    - "An event $S_SYSMAN_EVENT_TYPE_ENERGY_THRESHOLD_CROSSED will be generated when the delta energy consumed starting from this call exceeds the specified threshold. Use the function $sSysmanEventSetConfig() to start receiving the event."
    - "Only one running process can control the energy threshold at a given time. If another process attempts to change the energy threshold, the error $X_RESULT_ERROR_NOT_AVAILABLE will be returned. The function $sSysmanPowerGetEnergyThreshold() to determine the process ID currently controlling this setting."
    - "Calling this function will remove any pending energy thresholds and start counting from the time of this call."
    - "Once the energy threshold has been reached and the event generated, the threshold is automatically removed. It is up to the application to request a new threshold."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_pwr_handle_t
      name: hPower
      desc: "[in] Handle for the component."
    - type: double
      name: threshold
      desc: "[in] The energy threshold to be set in joules."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Energy threshold not supported on this power domain (check $s_power_properties_t.isEnergyThresholdSupported)."
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to request this feature."
    - $X_RESULT_ERROR_NOT_AVAILABLE:
        - "Another running process has set the energy threshold."
--- #--------------------------------------------------------------------------
type: enum
desc: "Frequency domains."
class: $sSysman
name: $s_freq_domain_t
etors:
    - name: $S_FREQ_DOMAIN_GPU
      value: "0"
      desc: "GPU Core Domain."
    - name: $S_FREQ_DOMAIN_MEMORY
      desc: "Local Memory Domain."
--- #--------------------------------------------------------------------------
type: struct
desc: "Frequency properties"
class: $sSysmanFrequency
name: $s_freq_properties_t
details:
    - "Indicates if this frequency domain can be overclocked (if true, functions such as $sSysmanFrequencyOcSetConfig() are supported)."
    - "The min/max hardware frequencies are specified for non-overclock configurations. For overclock configurations, use $sSysmanFrequencyOcGetConfig() to determine the maximum frequency that can be requested."
    - "If step is non-zero, the available frequencies are (min, min + step, min + 2xstep, ..., max). Otherwise, call $sSysmanFrequencyGetAvailableClocks() to get the list of frequencies that can be requested."
members:
    - type: $s_freq_domain_t
      name: "type"
      desc: "[out] The hardware block that this frequency domain controls (GPU, memory, ...)"
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $x_bool_t
      name: canControl
      desc: "[out] Indicates if software can control the frequency of this domain assuming the user has permissions"
    - type: $x_bool_t
      name: isThrottleEventSupported
      desc: "[out] Indicates if software can register to receive event $S_SYSMAN_EVENT_TYPE_FREQ_THROTTLED"
    - type: double
      name: min
      desc: "[out] The minimum hardware clock frequency in units of MHz"
    - type: double
      name: max
      desc: "[out] The maximum non-overclock hardware clock frequency in units of MHz."
    - type: double
      name: step
      desc: "[out] The minimum step-size for clock frequencies in units of MHz. The hardware will clamp intermediate frequencies to lowest multiplier of this number."
--- #--------------------------------------------------------------------------
type: struct
desc: "Frequency range between which the hardware can operate."
class: $sSysmanFrequency
name: $s_freq_range_t
members:
    - type: double
      name: "min"
      desc: "[in,out] The min frequency in MHz below which hardware frequency management will not request frequencies. Setting to 0 will use the hardware default value."
    - type: double
      name: "max"
      desc: "[in,out] The max frequency in MHz above which hardware frequency management will not request frequencies. Setting to 0 will use the hardware default value."
--- #--------------------------------------------------------------------------
type: enum
desc: "Frequency throttle reasons"
class: $sSysmanFrequency
name: $s_freq_throttle_reasons_t
etors:
    - name: $S_FREQ_THROTTLE_REASONS_NONE
      value: "0"
      desc: "frequency not throttled"
    - name: $S_FREQ_THROTTLE_REASONS_AVE_PWR_CAP
      value: "$X_BIT( 0 )"
      desc: "frequency throttled due to average power excursion (PL1)"
    - name: $S_FREQ_THROTTLE_REASONS_BURST_PWR_CAP
      value: "$X_BIT( 1 )"
      desc: "frequency throttled due to burst power excursion (PL2)"
    - name: $S_FREQ_THROTTLE_REASONS_CURRENT_LIMIT
      value: "$X_BIT( 2 )"
      desc: "frequency throttled due to current excursion (PL4)"
    - name: $S_FREQ_THROTTLE_REASONS_THERMAL_LIMIT
      value: "$X_BIT( 3 )"
      desc: "frequency throttled due to thermal excursion (T > TjMax)"
    - name: $S_FREQ_THROTTLE_REASONS_PSU_ALERT
      value: "$X_BIT( 4 )"
      desc: "frequency throttled due to power supply assertion"
    - name: $S_FREQ_THROTTLE_REASONS_SW_RANGE
      value: "$X_BIT( 5 )"
      desc: "frequency throttled due to software supplied frequency range"
    - name: $S_FREQ_THROTTLE_REASONS_HW_RANGE
      value: "$X_BIT( 6 )"
      desc: "frequency throttled due to a sub block that has a lower frequency range when it receives clocks"
--- #--------------------------------------------------------------------------
type: struct
desc: "Frequency state"
class: $sSysmanFrequency
name: $s_freq_state_t
members:
    - type: double
      name: "request"
      desc: "[out] The current frequency request in MHz."
    - type: double
      name: "tdp"
      desc: "[out] The maximum frequency in MHz supported under the current TDP conditions"
    - type: double
      name: "efficient"
      desc: "[out] The efficient minimum frequency in MHz"
    - type: double
      name: "actual"
      desc: "[out] The resolved frequency in MHz"
    - type: uint32_t
      name: "throttleReasons"
      desc: "[out] The reasons that the frequency is being limited by the hardware (Bitfield of $s_freq_throttle_reasons_t)."
--- #--------------------------------------------------------------------------
type: struct
desc: "Frequency throttle time snapshot"
class: $sSysmanFrequency
name: $s_freq_throttle_time_t
details:
    - "Percent time throttled is calculated by taking two snapshots (s1, s2) and using the equation: %throttled = (s2.throttleTime - s1.throttleTime) / (s2.timestamp - s1.timestamp)"
members:
    - type: uint64_t
      name: "throttleTime"
      desc: "[out] The monotonic counter of time in microseconds that the frequency has been limited by the hardware."
    - type: uint64_t
      name: "timestamp"
      desc: |
            [out] Microsecond timestamp when throttleTime was captured.
            No assumption should be made about the absolute value of the timestamp.
            It should only be used to calculate delta time between two snapshots of the same structure.
            Never take the delta of this timestamp with the timestamp from a different structure.
--- #--------------------------------------------------------------------------
type: enum
desc: "Overclocking modes"
class: $sSysmanFrequency
name: $s_oc_mode_t
etors:
    - name: $S_OC_MODE_OFF
      value: "0"
      desc: "Overclocking if off - hardware is running using factory default voltages/frequencies."
    - name: $S_OC_MODE_OVERRIDE
      desc: "Overclock override mode - In this mode, a fixed user-supplied voltage is applied independent of the frequency request. The maximum permitted frequency can also be increased."
    - name: $S_OC_MODE_INTERPOLATIVE
      desc: "Overclock interpolative mode - In this mode, the voltage/frequency curve can be extended with a new voltage/frequency point that will be interpolated. The existing voltage/frequency points can also be offset (up or down) by a fixed voltage."
--- #--------------------------------------------------------------------------
type: struct
desc: "Overclocking properties"
class: $sSysmanFrequency
name: $s_oc_capabilities_t
details:
    - "Provides all the overclocking capabilities and properties supported by the device for the frequency domain."
members:
    - type: $x_bool_t
      name: isOcSupported
      desc: "[out] Indicates if any overclocking features are supported on this frequency domain."
    - type: double
      name: maxFactoryDefaultFrequency
      desc: "[out] Factory default non-overclock maximum frequency in Mhz."
    - type: double
      name: maxFactoryDefaultVoltage
      desc: "[out] Factory default voltage used for the non-overclock maximum frequency in MHz."
    - type: double
      name: maxOcFrequency
      desc: "[out] Maximum hardware overclocking frequency limit in Mhz."
    - type: double
      name: minOcVoltageOffset
      desc: "[out] The minimum voltage offset that can be applied to the voltage/frequency curve. Note that this number can be negative."
    - type: double
      name: maxOcVoltageOffset
      desc: "[out] The maximum voltage offset that can be applied to the voltage/frequency curve."
    - type: double
      name: maxOcVoltage
      desc: "[out] The maximum overclock voltage that hardware supports."
    - type: $x_bool_t
      name: isTjMaxSupported
      desc: "[out] Indicates if the maximum temperature limit (TjMax) can be changed for this frequency domain."
    - type: $x_bool_t
      name: isIccMaxSupported
      desc: "[out] Indicates if the maximum current (IccMax) can be changed for this frequency domain."
    - type: $x_bool_t
      name: isHighVoltModeCapable
      desc: "[out] Indicates if this frequency domains supports a feature to set very high voltages."
    - type: $x_bool_t
      name: isHighVoltModeEnabled
      desc: "[out] Indicates if very high voltages are permitted on this frequency domain."
--- #--------------------------------------------------------------------------
type: struct
desc: "Overclocking configuration"
class: $sSysmanFrequency
name: $s_oc_config_t
details:
    - "Overclock settings"
members:
    - type: $s_oc_mode_t
      name: mode
      desc: "[in,out] Overclock Mode $s_oc_mode_t."
    - type: double
      name: frequency
      desc: "[in,out] Overclocking Frequency in MHz. This cannot be greater than $s_oc_capabilities_t.maxOcFrequency."
    - type: double
      name: voltageTarget
      desc: "[in,out] Overclock voltage in Volts. This cannot be greater than $s_oc_capabilities_t.maxOcVoltage."
    - type: double
      name: voltageOffset
      desc: "[in,out] This voltage offset is applied to all points on the voltage/frequency curve, include the new overclock voltageTarget. It can be in the range ($s_oc_capabilities_t.minOcVoltageOffset, $s_oc_capabilities_t.maxOcVoltageOffset)."
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of frequency domains"
class: $sSysman
name: FrequencyGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$s_sysman_freq_handle_t*"
      name: phFrequency
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get frequency properties - available frequencies"
class: $sSysmanFrequency
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $s_freq_properties_t*
      name: pProperties
      desc: "[in,out] The frequency properties for the specified domain."
--- #--------------------------------------------------------------------------
type: function
desc: "Get available non-overclocked hardware clock frequencies for the frequency domain"
class: $sSysmanFrequency
name: GetAvailableClocks
details:
    - "The list of available frequencies is returned in order of slowest to fastest."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of frequencies.
            If count is zero, then the driver will update the value with the total number of frequencies available.
            If count is non-zero, then driver will only retrieve that number of frequencies.
            If count is larger than the number of frequencies available, then the driver will update the value with the correct number of frequencies available.
    - type: "double*"
      name: phFrequency
      desc: "[in,out][optional][range(0, *pCount)] array of frequencies in units of MHz and sorted from slowest to fastest"
--- #--------------------------------------------------------------------------
type: function
desc: "Get current frequency limits"
class: $sSysmanFrequency
name: GetRange
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $s_freq_range_t*
      name: pLimits
      desc: "[in,out] The range between which the hardware can operate for the specified domain."
--- #--------------------------------------------------------------------------
type: function
desc: "Set frequency range between which the hardware can operate."
class: $sSysmanFrequency
name: SetRange
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: const $s_freq_range_t*
      name: pLimits
      desc: "[in] The limits between which the hardware can operate for the specified domain."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make these modifications."
--- #--------------------------------------------------------------------------
type: function
desc: "Get current frequency state - frequency request, actual frequency, TDP limits"
class: $sSysmanFrequency
name: GetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $s_freq_state_t*
      name: pState
      desc: "[in,out] Frequency state for the specified domain."
--- #--------------------------------------------------------------------------
type: function
desc: "Get frequency throttle time"
class: $sSysmanFrequency
name: GetThrottleTime
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $s_freq_throttle_time_t*
      name: pThrottleTime
      desc: "[in,out] Will contain a snapshot of the throttle time counters for the specified domain."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the overclocking capabilities."
class: $sSysmanFrequency
name: OcGetCapabilities
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $s_oc_capabilities_t*
      name: pOcCapabilities
      desc: "[in,out] Pointer to the capabilities structure $s_oc_capabilities_t."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the current overclocking configuration."
class: $sSysmanFrequency
name: OcGetConfig
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $s_oc_config_t*
      name: pOcConfiguration
      desc: "[in,out] Pointer to the configuration structure $s_oc_config_t."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Overclocking is not supported on this frequency domain ($s_oc_capabilities_t.isOcSupported)"
--- #--------------------------------------------------------------------------
type: function
desc: "Change the overclocking configuration."
class: $sSysmanFrequency
name: OcSetConfig
details:
    - "If $s_oc_config_t.mode is set to $S_OC_MODE_OFF, overclocking will be turned off and the hardware returned to run with factory voltages/frequencies. Call $sSysmanFrequencyOcSetIccMax() and $sSysmanFrequencyOcSetTjMax() separately with 0.0 to return those settings to factory defaults."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $s_oc_config_t*
      name: pOcConfiguration
      desc: "[in] Pointer to the configuration structure $s_oc_config_t."
    - type: $x_bool_t*
      name: pDeviceRestart
      desc: "[in,out] This will be set to true if the device needs to be restarted in order to enable the new overclock settings."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Overclocking is not supported on this frequency domain ($s_oc_capabilities_t.isOcSupported)"
        - "The specified voltage and/or frequency overclock settings exceed the hardware values (see $s_oc_capabilities_t.maxOcFrequency, $s_oc_capabilities_t.maxOcVoltage, $s_oc_capabilities_t.minOcVoltageOffset, $s_oc_capabilities_t.maxOcVoltageOffset)."
        - "Requested voltage overclock is very high but $s_oc_capabilities_t.isHighVoltModeEnabled is not enabled for the device."
    - $X_RESULT_ERROR_NOT_AVAILABLE:
        - "Overclocking feature is locked on this frequency domain"
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make these modifications."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the maximum current limit setting."
class: $sSysmanFrequency
name: OcGetIccMax
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: double*
      name: pOcIccMax
      desc: "[in,out] Will contain the maximum current limit in Amperes on successful return."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Overclocking is not supported on this frequency domain ($s_oc_capabilities_t.isOcSupported)"
        - "Capability $s_oc_capabilities_t.isIccMaxSupported is false for this frequency domain"
--- #--------------------------------------------------------------------------
type: function
desc: "Change the maximum current limit setting."
class: $sSysmanFrequency
name: OcSetIccMax
details:
    - "Setting ocIccMax to 0.0 will return the value to the factory default."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: double
      name: ocIccMax
      desc: "[in] The new maximum current limit in Amperes."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Overclocking is not supported on this frequency domain ($s_oc_capabilities_t.isOcSupported)"
        - "Capability $s_oc_capabilities_t.isIccMaxSupported is false for this frequency domain"
    - $X_RESULT_ERROR_NOT_AVAILABLE:
        - "Overclocking feature is locked on this frequency domain"
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The specified current limit is too low or too high"
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make these modifications."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the maximum temperature limit setting."
class: $sSysmanFrequency
name: OcGetTjMax
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: double*
      name: pOcTjMax
      desc: "[in,out] Will contain the maximum temperature limit in degrees Celsius on successful return."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Overclocking is not supported on this frequency domain ($s_oc_capabilities_t.isOcSupported)"
--- #--------------------------------------------------------------------------
type: function
desc: "Change the maximum temperature limit setting."
class: $sSysmanFrequency
name: OcSetTjMax
details:
    - "Setting ocTjMax to 0.0 will return the value to the factory default."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: double
      name: ocTjMax
      desc: "[in] The new maximum temperature limit in degrees Celsius."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Overclocking is not supported on this frequency domain ($s_oc_capabilities_t.isOcSupported)"
        - "Capability $s_oc_capabilities_t.isTjMaxSupported is false for this frequency domain"
    - $X_RESULT_ERROR_NOT_AVAILABLE:
        - "Overclocking feature is locked on this frequency domain"
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The specified temperature limit is too high"
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make these modifications."

--- #--------------------------------------------------------------------------
type: enum
desc: "Accelerator engine groups"
class: $sSysmanEngine
name: $s_engine_group_t
etors:
    - name: $S_ENGINE_GROUP_ALL
      value: "0"
      desc: "Access information about all engines combined."
    - name: $S_ENGINE_GROUP_COMPUTE_ALL
      desc: "Access information about all compute engines combined."
    - name: $S_ENGINE_GROUP_MEDIA_ALL
      desc: "Access information about all media engines combined."
    - name: $S_ENGINE_GROUP_COPY_ALL
      desc: "Access information about all copy (blitter) engines combined."
--- #--------------------------------------------------------------------------
type: struct
desc: "Engine group properties"
class: $sSysmanEngine
name: $s_engine_properties_t
members:
    - type: $s_engine_group_t
      name: "type"
      desc: "[out] The engine group"
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
--- #--------------------------------------------------------------------------
type: struct
desc: "Engine activity counters"
details:
    - "Percent utilization is calculated by taking two snapshots (s1, s2) and using the equation: %util = (s2.activeTime - s1.activeTime) / (s2.timestamp - s1.timestamp)"
class: $sSysmanEngine
name: $s_engine_stats_t
members:
    - type: uint64_t
      name: "activeTime"
      desc: "[out] Monotonic counter for time in microseconds that this resource is actively running workloads."
    - type: uint64_t
      name: "timestamp"
      desc: |
            [out] Monotonic timestamp counter in microseconds when activeTime counter was sampled.
            No assumption should be made about the absolute value of the timestamp.
            It should only be used to calculate delta time between two snapshots of the same structure.
            Never take the delta of this timestamp with the timestamp from a different structure.
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of engine groups"
class: $sSysman
name: EngineGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$s_sysman_engine_handle_t*"
      name: phEngine
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get engine group properties"
class: $sSysmanEngine
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_engine_handle_t
      name: hEngine
      desc: "[in] Handle for the component."
    - type: $s_engine_properties_t*
      name: pProperties
      desc: "[in,out] The properties for the specified engine group."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the activity stats for an engine group"
class: $sSysmanEngine
name: GetActivity
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_engine_handle_t
      name: hEngine
      desc: "[in] Handle for the component."
    - type: $s_engine_stats_t*
      name: pStats
      desc: "[in,out] Will contain a snapshot of the engine group activity counters."

--- #--------------------------------------------------------------------------
type: enum
desc: "Standby hardware components"
class: $sSysmanStandby
name: $s_standby_type_t
etors:
    - name: $S_STANDBY_TYPE_GLOBAL
      value: "0"
      desc: "Control the overall standby policy of the device/sub-device"
--- #--------------------------------------------------------------------------
type: struct
desc: "Standby hardware component properties"
class: $sSysmanStandby
name: $s_standby_properties_t
members:
    - type: $s_standby_type_t
      name: "type"
      desc: "[out] Which standby hardware component this controls"
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
--- #--------------------------------------------------------------------------
type: enum
desc: "Standby promotion modes"
class: $sSysmanStandby
name: $s_standby_promo_mode_t
etors:
    - name: $S_STANDBY_PROMO_MODE_DEFAULT
      value: "0"
      desc: "Best compromise between performance and energy savings."
    - name: $S_STANDBY_PROMO_MODE_NEVER
      desc: "The device/component will never shutdown. This can improve performance but uses more energy."
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of standby controls"
class: $sSysman
name: StandbyGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$s_sysman_standby_handle_t*"
      name: phStandby
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get standby hardware component properties"
class: $sSysmanStandby
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_standby_handle_t
      name: hStandby
      desc: "[in] Handle for the component."
    - type: $s_standby_properties_t*
      name: pProperties
      desc: "[in,out] Will contain the standby hardware properties."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the current standby promotion mode"
class: $sSysmanStandby
name: GetMode
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_standby_handle_t
      name: hStandby
      desc: "[in] Handle for the component."
    - type: $s_standby_promo_mode_t*
      name: pMode
      desc: "[in,out] Will contain the current standby mode."
--- #--------------------------------------------------------------------------
type: function
desc: "Set standby promotion mode"
class: $sSysmanStandby
name: SetMode
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_standby_handle_t
      name: hStandby
      desc: "[in] Handle for the component."
    - type: $s_standby_promo_mode_t
      name: mode
      desc: "[in] New standby mode."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make these modifications."
--- #--------------------------------------------------------------------------
type: struct
desc: "Firmware properties"
class: $sSysmanFirmware
name: $s_firmware_properties_t
members:
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $x_bool_t
      name: "canControl"
      desc: "[out] Indicates if software can flash the firmware assuming the user has permissions"
    - type: int8_t
      name: "name[$S_STRING_PROPERTY_SIZE]"
      desc: "[out] NULL terminated string value"
    - type: int8_t
      name: "version[$S_STRING_PROPERTY_SIZE]"
      desc: "[out] NULL terminated string value"
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of firmwares"
class: $sSysman
name: FirmwareGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$s_sysman_firmware_handle_t*"
      name: phFirmware
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get firmware properties"
class: $sSysmanFirmware
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_firmware_handle_t
      name: hFirmware
      desc: "[in] Handle for the component."
    - type: $s_firmware_properties_t*
      name: pProperties
      desc: "[in,out] Pointer to an array that will hold the properties of the firmware"
--- #--------------------------------------------------------------------------
type: function
desc: "Get firmware checksum"
class: $sSysmanFirmware
name: GetChecksum
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_firmware_handle_t
      name: hFirmware
      desc: "[in] Handle for the component."
    - type: uint32_t*
      name: pChecksum
      desc: "[in,out] Calculated checksum of the installed firmware."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to perform this operation."
--- #--------------------------------------------------------------------------
type: function
desc: "Flash a new firmware image"
class: $sSysmanFirmware
name: Flash
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_firmware_handle_t
      name: hFirmware
      desc: "[in] Handle for the component."
    - type: void*
      name: pImage
      desc: "[in] Image of the new firmware to flash."
    - type: uint32_t
      name: size
      desc: "[in] Size of the flash image."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to perform this operation."
--- #--------------------------------------------------------------------------
type: enum
desc: "Memory module types"
class: $sSysmanMemory
name: $s_mem_type_t
etors:
    - name: $S_MEM_TYPE_HBM
      value: "0"
      desc: "HBM memory"
    - name: $S_MEM_TYPE_DDR
      desc: "DDR memory"
    - name: $S_MEM_TYPE_SRAM
      desc: "SRAM memory"
    - name: $S_MEM_TYPE_L1
      desc: "L1 cache"
    - name: $S_MEM_TYPE_L3
      desc: "L3 cache"
    - name: $S_MEM_TYPE_GRF
      desc: "Execution unit register file"
    - name: $S_MEM_TYPE_SLM
      desc: "Execution unit shared local memory"
--- #--------------------------------------------------------------------------
type: enum
desc: "Memory health"
class: $sSysmanMemory
name: $s_mem_health_t
etors:
    - name: $S_MEM_HEALTH_OK
      value: "0"
      desc: "All memory channels are healthy"
    - name: $S_MEM_HEALTH_DEGRADED
      desc: "Excessive correctable errors have been detected on one or more channels. Device should be reset."
    - name: $S_MEM_HEALTH_CRITICAL
      desc: "Operating with reduced memory to cover banks with too many uncorrectable errors."
    - name: $S_MEM_HEALTH_REPLACE
      desc: "Device should be replaced due to excessive uncorrectable errors."
--- #--------------------------------------------------------------------------
type: struct
desc: "Memory properties"
class: $sSysmanMemory
name: $s_mem_properties_t
members:
    - type: $s_mem_type_t
      name: type
      desc: "[out] The memory type"
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: uint64_t
      name: physicalSize
      desc: "[out] Physical memory size in bytes"
--- #--------------------------------------------------------------------------
type: struct
desc: "Memory state - health, allocated"
class: $sSysmanMemory
name: $s_mem_state_t
details:
    - "Percent allocation is given by 100 * allocatedSize / maxSize."
    - "Percent free is given by 100 * (maxSize - allocatedSize) / maxSize."
members:
    - type: $s_mem_health_t
      name: health
      desc: "[out] Indicates the health of the memory"
    - type: uint64_t
      name: free
      desc: "[out] The free memory in bytes"
    - type: uint64_t
      name: size
      desc: "[out] The total allocatable memory in bytes (can be less than $s_mem_properties_t.physicalSize)"
--- #--------------------------------------------------------------------------
type: struct
desc: "Memory bandwidth"
class: $sSysmanMemory
name: $s_mem_bandwidth_t
details:
    - "Percent bandwidth is calculated by taking two snapshots (s1, s2) and using the equation: %bw = 10^6 * ((s2.readCounter - s1.readCounter) + (s2.writeCounter - s1.writeCounter)) / (s2.maxBandwidth * (s2.timestamp - s1.timestamp))"
members:
    - type: uint64_t
      name: readCounter
      desc: "[out] Total bytes read from memory"
    - type: uint64_t
      name: writeCounter
      desc: "[out] Total bytes written to memory"
    - type: uint64_t
      name: maxBandwidth
      desc: "[out] Current maximum bandwidth in units of bytes/sec"
    - type: uint64_t
      name: timestamp
      desc: |
            [out] The timestamp when these measurements were sampled.
            No assumption should be made about the absolute value of the timestamp.
            It should only be used to calculate delta time between two snapshots of the same structure.
            Never take the delta of this timestamp with the timestamp from a different structure.
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of memory modules"
class: $sSysman
name: MemoryGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$s_sysman_mem_handle_t*"
      name: phMemory
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get memory properties"
class: $sSysmanMemory
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_mem_handle_t
      name: hMemory
      desc: "[in] Handle for the component."
    - type: $s_mem_properties_t*
      name: pProperties
      desc: "[in,out] Will contain memory properties."
--- #--------------------------------------------------------------------------
type: function
desc: "Get memory state - health, allocated"
class: $sSysmanMemory
name: GetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_mem_handle_t
      name: hMemory
      desc: "[in] Handle for the component."
    - type: $s_mem_state_t*
      name: pState
      desc: "[in,out] Will contain the current health and allocated memory."
--- #--------------------------------------------------------------------------
type: function
desc: "Get memory bandwidth"
class: $sSysmanMemory
name: GetBandwidth
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_mem_handle_t
      name: hMemory
      desc: "[in] Handle for the component."
    - type: $s_mem_bandwidth_t*
      name: pBandwidth
      desc: "[in,out] Will contain the current health, free memory, total memory size."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to query this telemetry."
--- #--------------------------------------------------------------------------
type: macro
desc: "Maximum Fabric port model string size"
name: $S_MAX_FABRIC_PORT_MODEL_SIZE
value: "256"
--- #--------------------------------------------------------------------------
type: macro
desc: "Maximum size of the buffer that will return information about link types"
name: $S_MAX_FABRIC_LINK_TYPE_SIZE
value: "256"
--- #--------------------------------------------------------------------------
type: enum
desc: "Fabric port status"
class: $sSysmanFabricPort
name: $s_fabric_port_status_t
etors:
    - name: $S_FABRIC_PORT_STATUS_GREEN
      value: "0"
      desc: "The port is up and operating as expected"
    - name: $S_FABRIC_PORT_STATUS_YELLOW
      desc: "The port is up but has quality and/or speed degradation"
    - name: $S_FABRIC_PORT_STATUS_RED
      desc: "Port connection instabilities are preventing workloads making forward progress"
    - name: $S_FABRIC_PORT_STATUS_BLACK
      desc: "The port is configured down"
--- #--------------------------------------------------------------------------
type: enum
desc: "Fabric port quality degradation reasons"
class: $sSysmanFabricPort
name: $s_fabric_port_qual_issues_t
etors:
    - name: $S_FABRIC_PORT_QUAL_ISSUES_NONE
      value: "0"
      desc: "There are no quality issues with the link at this time"
    - name: $S_FABRIC_PORT_QUAL_LINK_ERRORS
      value: "$X_BIT( 0 )"
      desc: "Excessive link errors are occurring"
    - name: $S_FABRIC_PORT_QUAL_ISSUES_SPEED
      value: "$X_BIT( 1 )"
      desc: "There is a degradation in the bitrate and/or width of the link"
--- #--------------------------------------------------------------------------
type: enum
desc: "Fabric port stability issues"
class: $sSysmanFabricPort
name: $s_fabric_port_stab_issues_t
etors:
    - name: $S_FABRIC_PORT_STAB_ISSUES_NONE
      value: "0"
      desc: "There are no connection stability issues at this time"
    - name: $S_FABRIC_PORT_STAB_ISSUES_FAILED
      value: "$X_BIT( 0 )"
      desc: "A previously operating link has failed. Hardware will automatically retrain this port. This state will persist until either the physical connection is removed or the link trains successfully."
    - name: $S_FABRIC_PORT_STAB_ISSUES_TRAINING_TIMEOUT
      value: "$X_BIT( 1 )"
      desc: "A connection has not been established within an expected time. Hardware will continue to attempt port training. This status will persist until either the physical connection is removed or the link successfully trains."
    - name: $S_FABRIC_PORT_STAB_ISSUES_FLAPPING
      value: "$X_BIT( 2 )"
      desc: "Port has excessively trained and then transitioned down for some period of time. Driver will allow port to continue to train, but will not enable the port for use until the port has been disabled and subsequently re-enabled using $sSysmanFabricPortSetConfig()."
--- #--------------------------------------------------------------------------
type: struct
desc: "Unique identifier for a fabric port"
class: $sSysmanFabricPort
name: $s_fabric_port_id_t
details:
    - "This not a universal identifier. The identified is garanteed to be unique for the current hardware configuration of the system. Changes in the hardware may result in a different identifier for a given port."
    - "The main purpose of this identifier to build up an instantaneous topology map of system connectivity. An application should enumerate all fabric ports and match $s_fabric_port_state_t.remotePortId to $s_fabric_port_properties_t.portId."
members:
    - type: uint32_t
      name: "fabricId"
      desc: "[out] Unique identifier for the fabric end-point"
    - type: uint32_t
      name: "attachId"
      desc: "[out] Unique identifier for the device attachment point"
    - type: uint8_t
      name: "portNumber"
      desc: "[out] The logical port number (this is typically marked somewhere on the physical device)"
--- #--------------------------------------------------------------------------
type: struct
desc: "Fabric port speed in one direction"
class: $sSysmanFabricPort
name: $s_fabric_port_speed_t
members:
    - type: uint64_t
      name: "bitRate"
      desc: "[out] Bits/sec that the link is operating at"
    - type: uint32_t
      name: "width"
      desc: "[out] The number of lanes"
--- #--------------------------------------------------------------------------
type: struct
desc: "Fabric port properties"
class: $sSysmanFabricPort
name: $s_fabric_port_properties_t
members:
    - type: int8_t
      name: "model[$S_MAX_FABRIC_PORT_MODEL_SIZE]"
      desc: "[out] Description of port technology"
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the port is located on a sub-device; false means that the port is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $s_fabric_port_id_t
      name: "portId"
      desc: "[out] The unique port identifier"
    - type: $s_fabric_port_speed_t
      name: "maxRxSpeed"
      desc: "[out] Maximum speed supported by the receive side of the port"
    - type: $s_fabric_port_speed_t
      name: "maxTxSpeed"
      desc: "[out] Maximum speed supported by the transmit side of the port"
--- #--------------------------------------------------------------------------
type: struct
desc: "Provides information about the fabric link attached to a port"
class: $sSysmanFabricPort
name: $s_fabric_link_type_t
members:
    - type: int8_t
      name: "desc[$S_MAX_FABRIC_LINK_TYPE_SIZE]"
      desc: "[out] This provides a static textural description of the physic attachment type"
--- #--------------------------------------------------------------------------
type: struct
desc: "Fabric port configuration"
class: $sSysmanFabricPort
name: $s_fabric_port_config_t
members:
    - type: $x_bool_t
      name: "enabled"
      desc: "[in,out] Port is configured up/down"
    - type: $x_bool_t
      name: "beaconing"
      desc: "[in,out] Beaconing is configured on/off"
--- #--------------------------------------------------------------------------
type: struct
desc: "Fabric port state"
class: $sSysmanFabricPort
name: $s_fabric_port_state_t
members:
    - type: $s_fabric_port_status_t
      name: "status"
      desc: "[out] The current status of the port"
    - type: $s_fabric_port_qual_issues_t
      name: "qualityIssues"
      desc: "[out] If status is $S_FABRIC_PORT_STATUS_YELLOW, this gives a bitfield of quality issues that have been detected"
    - type: $s_fabric_port_stab_issues_t
      name: "stabilityIssues"
      desc: "[out] If status is $S_FABRIC_PORT_STATUS_RED, this gives a bitfield of reasons for the connection instability"
    - type: $s_fabric_port_id_t
      name: "remotePortId"
      desc: "[out] The unique port identifier for the remote connection point"
    - type: $s_fabric_port_speed_t
      name: "rxSpeed"
      desc: "[out] Current maximum receive speed"
    - type: $s_fabric_port_speed_t
      name: "txSpeed"
      desc: "[out] Current maximum transmit speed"
--- #--------------------------------------------------------------------------
type: struct
desc: "Fabric port throughput."
class: $sSysmanFabricPort
name: $s_fabric_port_throughput_t
members:
    - type: uint64_t
      name: "timestamp"
      desc: |
            [out] Monotonic timestamp counter in microseconds when the measurement was made.
            No assumption should be made about the absolute value of the timestamp.
            It should only be used to calculate delta time between two snapshots of the same structure.
            Never take the delta of this timestamp with the timestamp from a different structure.
    - type: uint64_t
      name: "rxCounter"
      desc: "[out] Monotonic counter for the number of bytes received. This includes all protocol overhead, not only the GPU traffic."
    - type: uint64_t
      name: "txCounter"
      desc: "[out] Monotonic counter for the number of bytes transmitted. This includes all protocol overhead, not only the GPU traffic."
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of Fabric ports in a device"
class: $sSysman
name: FabricPortGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$s_sysman_fabric_port_handle_t*"
      name: phPort
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get Fabric port properties"
class: $sSysmanFabricPort
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_fabric_port_handle_t
      name: hPort
      desc: "[in] Handle for the component."
    - type: $s_fabric_port_properties_t*
      name: pProperties
      desc: "[in,out] Will contain properties of the Fabric Port."
--- #--------------------------------------------------------------------------
type: function
desc: "Get Fabric port link type"
class: $sSysmanFabricPort
name: GetLinkType
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_fabric_port_handle_t
      name: hPort
      desc: "[in] Handle for the component."
    - type: $x_bool_t
      name: verbose
      desc: "[in] Set to true to get a more detailed report."
    - type: $s_fabric_link_type_t*
      name: pLinkType
      desc: "[in,out] Will contain details about the link attached to the Fabric port."
--- #--------------------------------------------------------------------------
type: function
desc: "Get Fabric port configuration"
class: $sSysmanFabricPort
name: GetConfig
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_fabric_port_handle_t
      name: hPort
      desc: "[in] Handle for the component."
    - type: $s_fabric_port_config_t*
      name: pConfig
      desc: "[in,out] Will contain configuration of the Fabric Port."
--- #--------------------------------------------------------------------------
type: function
desc: "Set Fabric port configuration"
class: $sSysmanFabricPort
name: SetConfig
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_fabric_port_handle_t
      name: hPort
      desc: "[in] Handle for the component."
    - type: const $s_fabric_port_config_t*
      name: pConfig
      desc: "[in] Contains new configuration of the Fabric Port."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make these modifications."
--- #--------------------------------------------------------------------------
type: function
desc: "Get Fabric port state - status (green/yellow/red/black), reasons for link degradation or instability, current rx/tx speed"
class: $sSysmanFabricPort
name: GetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_fabric_port_handle_t
      name: hPort
      desc: "[in] Handle for the component."
    - type: $s_fabric_port_state_t*
      name: pState
      desc: "[in,out] Will contain the current state of the Fabric Port"
--- #--------------------------------------------------------------------------
type: function
desc: "Get Fabric port throughput"
class: $sSysmanFabricPort
name: GetThroughput
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_fabric_port_handle_t
      name: hPort
      desc: "[in] Handle for the component."
    - type: $s_fabric_port_throughput_t*
      name: pThroughput
      desc: "[in,out] Will contain the Fabric port throughput counters."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to query this telemetry."
--- #--------------------------------------------------------------------------
type: enum
desc: "Temperature sensors"
class: $sSysmanTemperature
name: $s_temp_sensors_t
etors:
    - name: $S_TEMP_SENSORS_GLOBAL
      value: "0"
      desc: "The maximum temperature across all device sensors"
    - name: $S_TEMP_SENSORS_GPU
      desc: "The maximum temperature across all sensors in the GPU"
    - name: $S_TEMP_SENSORS_MEMORY
      desc: "The maximum temperature across all sensors in the local memory"
--- #--------------------------------------------------------------------------
type: struct
desc: "Temperature sensor properties"
class: $sSysmanTemperature
name: $s_temp_properties_t
members:
    - type: $s_temp_sensors_t
      name: "type"
      desc: "[out] Which part of the device the temperature sensor measures"
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $x_bool_t
      name: "isCriticalTempSupported"
      desc: "[out] Indicates if the critical temperature event $S_SYSMAN_EVENT_TYPE_TEMP_CRITICAL is supported"
    - type: $x_bool_t
      name: "isThreshold1Supported"
      desc: "[out] Indicates if the temperature threshold 1 event $S_SYSMAN_EVENT_TYPE_TEMP_THRESHOLD1 is supported"
    - type: $x_bool_t
      name: "isThreshold2Supported"
      desc: "[out] Indicates if the temperature threshold 2 event $S_SYSMAN_EVENT_TYPE_TEMP_THRESHOLD2 is supported"
--- #--------------------------------------------------------------------------
type: struct
desc: "Temperature sensor threshold"
class: $sSysmanTemperature
name: $s_temp_threshold_t
members:
    - type: $x_bool_t
      name: "enableLowToHigh"
      desc: "[in,out] Trigger an event when the temperature crosses from below the threshold to above."
    - type: $x_bool_t
      name: "enableHighToLow"
      desc: "[in,out] Trigger an event when the temperature crosses from above the threshold to below."
    - type: double
      name: "threshold"
      desc: "[in,out] The threshold in degrees Celsius."
--- #--------------------------------------------------------------------------
type: struct
desc: "Temperature configuration - which events should be triggered and the trigger conditions."
class: $sSysmanTemperature
name: $s_temp_config_t
members:
    - type: $x_bool_t
      name: "enableCritical"
      desc: "[in,out] Indicates if event $S_SYSMAN_EVENT_TYPE_TEMP_CRITICAL should be triggered by the driver."
    - type: $s_temp_threshold_t
      name: "threshold1"
      desc: "[in,out] Configuration controlling if and when event $S_SYSMAN_EVENT_TYPE_TEMP_THRESHOLD1 should be triggered by the driver."
    - type: $s_temp_threshold_t
      name: "threshold2"
      desc: "[in,out] Configuration controlling if and when event $S_SYSMAN_EVENT_TYPE_TEMP_THRESHOLD2 should be triggered by the driver."
    - type: uint32_t
      name: "processId"
      desc: "[out] Host processId that set this configuration (ignored when setting the configuration)."
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of temperature sensors"
class: $sSysman
name: TemperatureGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$s_sysman_temp_handle_t*"
      name: phTemperature
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get temperature sensor properties"
class: $sSysmanTemperature
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_temp_handle_t
      name: hTemperature
      desc: "[in] Handle for the component."
    - type: $s_temp_properties_t*
      name: pProperties
      desc: "[in,out] Will contain the temperature sensor properties."
--- #--------------------------------------------------------------------------
type: function
desc: "Get temperature configuration for this sensor - which events are triggered and the trigger conditions"
class: $sSysmanTemperature
name: GetConfig
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_temp_handle_t
      name: hTemperature
      desc: "[in] Handle for the component."
    - type: $s_temp_config_t*
      name: pConfig
      desc: "[in,out] Returns current configuration."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Temperature thresholds are not supported on this temperature sensor. Generally this is only supported for temperature sensor $S_TEMP_SENSORS_GLOBAL"
        - "One or both of the thresholds is not supported - check $s_temp_properties_t.isThreshold1Supported and $s_temp_properties_t.isThreshold2Supported"
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to request this feature."
--- #--------------------------------------------------------------------------
type: function
desc: "Set temperature configuration for this sensor - indicates which events are triggered and the trigger conditions"
class: $sSysmanTemperature
name: SetConfig
details:
    - "Events $S_SYSMAN_EVENT_TYPE_TEMP_CRITICAL will be triggered when temperature reaches the critical range. Use the function $sSysmanEventSetConfig() to start receiving this event."
    - "Events $S_SYSMAN_EVENT_TYPE_TEMP_THRESHOLD1 and $S_SYSMAN_EVENT_TYPE_TEMP_THRESHOLD2 will be generated when temperature cross the thresholds set using this function. Use the function $sSysmanEventSetConfig() to start receiving these events."
    - "Only one running process can set the temperature configuration at a time. If another process attempts to change the configuration, the error $X_RESULT_ERROR_NOT_AVAILABLE will be returned. The function $sSysmanTemperatureGetConfig() will return the process ID currently controlling these settings."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_temp_handle_t
      name: hTemperature
      desc: "[in] Handle for the component."
    - type: "const $s_temp_config_t*"
      name: pConfig
      desc: "[in] New configuration."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Temperature thresholds are not supported on this temperature sensor. Generally they are only supported for temperature sensor $S_TEMP_SENSORS_GLOBAL"
        - "Enabling the critical temperature event is not supported - check $s_temp_properties_t.isCriticalTempSupported"
        - "One or both of the thresholds is not supported - check $s_temp_properties_t.isThreshold1Supported and $s_temp_properties_t.isThreshold2Supported"
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to request this feature."
    - $X_RESULT_ERROR_NOT_AVAILABLE:
        - "Another running process is controlling these settings."
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "One or both the thresholds is above TjMax (see $sSysmanFrequencyOcGetTjMax()). Temperature thresholds must be below this value."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the temperature from a specified sensor"
class: $sSysmanTemperature
name: GetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_temp_handle_t
      name: hTemperature
      desc: "[in] Handle for the component."
    - type: double*
      name: pTemperature
      desc: "[in,out] Will contain the temperature read from the specified sensor in degrees Celsius."
--- #--------------------------------------------------------------------------
type: enum
desc: "PSU voltage status"
class: $sSysmanPsu
name: $s_psu_voltage_status_t
etors:
    - name: $S_PSU_VOLTAGE_STATUS_NORMAL
      value: "0"
      desc: "No unusual voltages have been detected"
    - name: $S_PSU_VOLTAGE_STATUS_OVER
      desc: "Over-voltage has occurred"
    - name: $S_PSU_VOLTAGE_STATUS_UNDER
      desc: "Under-voltage has occurred"
--- #--------------------------------------------------------------------------
type: struct
desc: "Static properties of the power supply"
class: $sSysmanPsu
name: $s_psu_properties_t
members:
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $x_bool_t
      name: "haveFan"
      desc: "[out] True if the power supply has a fan"
    - type: uint32_t
      name: "ampLimit"
      desc: "[out] The maximum electrical current in amperes that can be drawn"
--- #--------------------------------------------------------------------------
type: struct
desc: "Dynamic state of the power supply"
class: $sSysmanPsu
name: $s_psu_state_t
members:
    - type: $s_psu_voltage_status_t
      name: "voltStatus"
      desc: "[out] The current PSU voltage status"
    - type: $x_bool_t
      name: "fanFailed"
      desc: "[out] Indicates if the fan has failed"
    - type: uint32_t
      name: "temperature"
      desc: "[out] Read the current heatsink temperature in degrees Celsius."
    - type: uint32_t
      name: "current"
      desc: "[out] The amps being drawn in amperes"
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of power supplies"
class: $sSysman
name: PsuGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$s_sysman_psu_handle_t*"
      name: phPsu
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get power supply properties"
class: $sSysmanPsu
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_psu_handle_t
      name: hPsu
      desc: "[in] Handle for the component."
    - type: $s_psu_properties_t*
      name: pProperties
      desc: "[in,out] Will contain the properties of the power supply."
--- #--------------------------------------------------------------------------
type: function
desc: "Get current power supply state"
class: $sSysmanPsu
name: GetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_psu_handle_t
      name: hPsu
      desc: "[in] Handle for the component."
    - type: $s_psu_state_t*
      name: pState
      desc: "[in,out] Will contain the current state of the power supply."

--- #--------------------------------------------------------------------------
type: enum
desc: "Fan resource speed mode"
class: $sSysmanFan
name: $s_fan_speed_mode_t
etors:
    - name: $S_FAN_SPEED_MODE_DEFAULT
      value: "0"
      desc: "The fan speed is operating using the hardware default settings"
    - name: $S_FAN_SPEED_MODE_FIXED
      desc: "The fan speed is currently set to a fixed value"
    - name: $S_FAN_SPEED_MODE_TABLE
      desc: "The fan speed is currently controlled dynamically by hardware based on a temp/speed table"
--- #--------------------------------------------------------------------------
type: enum
desc: "Fan speed units"
class: $sSysmanFan
name: $s_fan_speed_units_t
etors:
    - name: $S_FAN_SPEED_UNITS_RPM
      value: "0"
      desc: "The fan speed is in units of revolutions per minute (rpm)"
    - name: $S_FAN_SPEED_UNITS_PERCENT
      desc: "The fan speed is a percentage of the maximum speed of the fan"
--- #--------------------------------------------------------------------------
type: struct
desc: "Fan temperature/speed pair"
class: $sSysmanFan
name: $s_fan_temp_speed_t
members:
    - type: uint32_t
      name: "temperature"
      desc: "[in,out] Temperature in degrees Celsius."
    - type: uint32_t
      name: "speed"
      desc: "[in,out] The speed of the fan"
    - type: $s_fan_speed_units_t
      name: "units"
      desc: "[in,out] The units of the member speed"
--- #--------------------------------------------------------------------------
type: macro
desc: "Maximum number of fan temperature/speed pairs in the fan speed table."
name: $S_FAN_TEMP_SPEED_PAIR_COUNT
value: "32"
--- #--------------------------------------------------------------------------
type: struct
desc: "Fan properties"
class: $sSysmanFan
name: $s_fan_properties_t
members:
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $x_bool_t
      name: "canControl"
      desc: "[out] Indicates if software can control the fan speed assuming the user has permissions"
    - type: uint32_t
      name: "maxSpeed"
      desc: "[out] The maximum RPM of the fan"
    - type: uint32_t
      name: "maxPoints"
      desc: "[out] The maximum number of points in the fan temp/speed table"
--- #--------------------------------------------------------------------------
type: struct
desc: "Fan configuration"
class: $sSysmanFan
name: $s_fan_config_t
members:
    - type: $s_fan_speed_mode_t
      name: "mode"
      desc: "[in,out] The fan speed mode (fixed, temp-speed table)"
    - type: uint32_t
      name: "speed"
      desc: "[in,out] The fixed fan speed setting"
    - type: $s_fan_speed_units_t
      name: "speedUnits"
      desc: "[in,out] The units of the fixed fan speed setting"
    - type: uint32_t
      name: "numPoints"
      desc: "[in,out] The number of valid points in the fan speed table"
    - type: $s_fan_temp_speed_t
      name: "table[$S_FAN_TEMP_SPEED_PAIR_COUNT]"
      desc: "[in,out] Array of temperature/fan speed pairs"
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of fans"
class: $sSysman
name: FanGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$s_sysman_fan_handle_t*"
      name: phFan
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get fan properties"
class: $sSysmanFan
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_fan_handle_t
      name: hFan
      desc: "[in] Handle for the component."
    - type: $s_fan_properties_t*
      name: pProperties
      desc: "[in,out] Will contain the properties of the fan."
--- #--------------------------------------------------------------------------
type: function
desc: "Get current fan configuration"
class: $sSysmanFan
name: GetConfig
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_fan_handle_t
      name: hFan
      desc: "[in] Handle for the component."
    - type: $s_fan_config_t*
      name: pConfig
      desc: "[in,out] Will contain the current configuration of the fan."
--- #--------------------------------------------------------------------------
type: function
desc: "Set fan configuration"
class: $sSysmanFan
name: SetConfig
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_fan_handle_t
      name: hFan
      desc: "[in] Handle for the component."
    - type: const $s_fan_config_t*
      name: pConfig
      desc: "[in] New fan configuration."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make these modifications."
--- #--------------------------------------------------------------------------
type: function
desc: "Get current state of a fan - current mode and speed"
class: $sSysmanFan
name: GetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_fan_handle_t
      name: hFan
      desc: "[in] Handle for the component."
    - type: $s_fan_speed_units_t
      name: units
      desc: "[in] The units in which the fan speed should be returned."
    - type: uint32_t*
      name: pSpeed
      desc: "[in,out] Will contain the current speed of the fan in the units requested."

--- #--------------------------------------------------------------------------
type: struct
desc: "LED properties"
class: $sSysmanLed
name: $s_led_properties_t
members:
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $x_bool_t
      name: "canControl"
      desc: "[out] Indicates if software can control the LED assuming the user has permissions"
    - type: $x_bool_t
      name: "haveRGB"
      desc: "[out] Indicates if the LED is RGB capable"
--- #--------------------------------------------------------------------------
type: struct
desc: "LED state"
class: $sSysmanLed
name: $s_led_state_t
members:
    - type: $x_bool_t
      name: isOn
      desc: "[in,out] Indicates if the LED is on or off"
    - type: uint8_t
      name: "red"
      desc: "[in,out][range(0, 255)] The LED red value"
    - type: uint8_t
      name: "green"
      desc: "[in,out][range(0, 255)] The LED green value"
    - type: uint8_t
      name: "blue"
      desc: "[in,out][range(0, 255)] The LED blue value"
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of LEDs"
class: $sSysman
name: LedGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$s_sysman_led_handle_t*"
      name: phLed
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get LED properties"
class: $sSysmanLed
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_led_handle_t
      name: hLed
      desc: "[in] Handle for the component."
    - type: $s_led_properties_t*
      name: pProperties
      desc: "[in,out] Will contain the properties of the LED."
--- #--------------------------------------------------------------------------
type: function
desc: "Get current state of a LED - on/off, color"
class: $sSysmanLed
name: GetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_led_handle_t
      name: hLed
      desc: "[in] Handle for the component."
    - type: $s_led_state_t*
      name: pState
      desc: "[in,out] Will contain the current state of the LED."
--- #--------------------------------------------------------------------------
type: function
desc: "Set state of a LED - on/off, color"
class: $sSysmanLed
name: SetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_led_handle_t
      name: hLed
      desc: "[in] Handle for the component."
    - type: const $s_led_state_t*
      name: pState
      desc: "[in] New state of the LED."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make these modifications."
--- #--------------------------------------------------------------------------
type: enum
desc: "RAS error type"
class: $sSysmanRas
name: $s_ras_error_type_t
etors:
    - name: $S_RAS_ERROR_TYPE_CORRECTABLE
      value: "0"
      desc: "Errors were corrected by hardware"
    - name: $S_RAS_ERROR_TYPE_UNCORRECTABLE
      desc: "Error were not corrected"
--- #--------------------------------------------------------------------------
type: struct
desc: "RAS properties"
class: $sSysmanRas
name: $s_ras_properties_t
members:
    - type: $s_ras_error_type_t
      name: "type"
      desc: "[out] The type of RAS error"
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
--- #--------------------------------------------------------------------------
type: struct
desc: "RAS error details"
class: $sSysmanRas
name: $s_ras_details_t
members:
    - type: uint64_t
      name: "numResets"
      desc: "[out] The number of device resets that have taken place"
    - type: uint64_t
      name: "numProgrammingErrors"
      desc: "[out] The number of hardware exceptions generated by the way workloads have programmed the hardware"
    - type: uint64_t
      name: "numDriverErrors"
      desc: "[out] The number of low level driver communication errors have occurred"
    - type: uint64_t
      name: "numComputeErrors"
      desc: "[out] The number of errors that have occurred in the compute accelerator hardware"
    - type: uint64_t
      name: "numNonComputeErrors"
      desc: "[out] The number of errors that have occurred in the fixed-function accelerator hardware"
    - type: uint64_t
      name: "numCacheErrors"
      desc: "[out] The number of errors that have occurred in caches (L1/L3/register file/shared local memory/sampler)"
    - type: uint64_t
      name: "numDisplayErrors"
      desc: "[out] The number of errors that have occurred in the display"
--- #--------------------------------------------------------------------------
type: struct
desc: "RAS error configuration - thresholds used for triggering RAS events ($S_SYSMAN_EVENT_TYPE_RAS_CORRECTABLE_ERRORS, $S_SYSMAN_EVENT_TYPE_RAS_UNCORRECTABLE_ERRORS)"
class: $sSysmanRas
name: $s_ras_config_t
details:
    - "The driver maintains a total counter which is updated every time a hardware block covered by the corresponding RAS error set notifies that an error has occurred. When this total count goes above the totalThreshold specified below, a RAS event is triggered."
    - "The driver also maintains a counter for each category of RAS error (see $s_ras_details_t for a breakdown). Each time a hardware block of that category notifies that an error has occurred, that corresponding category counter is updated. When it goes above the threshold specified in detailedThresholds, a RAS event is triggered."
members:
    - type: uint64_t
      name: "totalThreshold"
      desc: "[in,out] If the total RAS errors exceeds this threshold, the event will be triggered. A value of 0ULL disables triggering the event based on the total counter."
    - type: $s_ras_details_t
      name: detailedThresholds
      desc: "[in,out] If the RAS errors for each category exceed the threshold for that category, the event will be triggered. A value of 0ULL will disable an event being triggered for that category."
    - type: uint32_t
      name: "processId"
      desc: "[out] Host processId that set this configuration (ignored when setting the configuration)."
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of all RAS error sets on a device"
class: $sSysman
name: RasGet
details:
    - "A RAS error set is a collection of RAS error counters of a given type (correctable/uncorrectable) from hardware blocks contained within a sub-device or within the device."
    - "A device without sub-devices will typically return two handles, one for correctable errors sets and one for uncorrectable error sets."
    - "A device with sub-devices will return RAS error sets for each sub-device and possibly RAS error sets for hardware blocks outside the sub-devices."
    - "If the function completes successfully but pCount is set to 0, RAS features are not available/enabled on this device."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$s_sysman_ras_handle_t*"
      name: phRas
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get RAS properties of a given RAS error set - this enables discovery of the type of RAS error set (correctable/uncorrectable) and if located on a sub-device"
class: $sSysmanRas
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_ras_handle_t
      name: hRas
      desc: "[in] Handle for the component."
    - type: $s_ras_properties_t*
      name: pProperties
      desc: "[in,out] Structure describing RAS properties"
--- #--------------------------------------------------------------------------
type: function
desc: "Get RAS error thresholds that control when RAS events are generated"
class: $sSysmanRas
name: GetConfig
details:
    - "The driver maintains counters for all RAS error sets and error categories. Events are generated when errors occur. The configuration enables setting thresholds to limit when events are sent."
    - "When a particular RAS correctable error counter exceeds the configured threshold, the event $S_SYSMAN_EVENT_TYPE_RAS_CORRECTABLE_ERRORS will be triggered."
    - "When a particular RAS uncorrectable error counter exceeds the configured threshold, the event $S_SYSMAN_EVENT_TYPE_RAS_UNCORRECTABLE_ERRORS will be triggered."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_ras_handle_t
      name: hRas
      desc: "[in] Handle for the component."
    - type: "$s_ras_config_t*"
      name: pConfig
      desc: "[in,out] Will be populed with the current RAS configuration - thresholds used to trigger events"
--- #--------------------------------------------------------------------------
type: function
desc: "Set RAS error thresholds that control when RAS events are generated"
class: $sSysmanRas
name: SetConfig
details:
    - "The driver maintains counters for all RAS error sets and error categories. Events are generated when errors occur. The configuration enables setting thresholds to limit when events are sent."
    - "When a particular RAS correctable error counter exceeds the specified threshold, the event $S_SYSMAN_EVENT_TYPE_RAS_CORRECTABLE_ERRORS will be generated."
    - "When a particular RAS uncorrectable error counter exceeds the specified threshold, the event $S_SYSMAN_EVENT_TYPE_RAS_UNCORRECTABLE_ERRORS will be generated."
    - "Call $sSysmanRasGetState() and set the clear flag to true to restart event generation once counters have exceeded thresholds."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_ras_handle_t
      name: hRas
      desc: "[in] Handle for the component."
    - type: "const $s_ras_config_t*"
      name: pConfig
      desc: "[in] Change the RAS configuration - thresholds used to trigger events"
returns:
    - $X_RESULT_ERROR_NOT_AVAILABLE:
        - "Another running process is controlling these settings."
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "Don't have permissions to set thresholds."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the current value of RAS error counters for a particular error set"
class: $sSysmanRas
name: GetState
details:
    - "Clearing errors will affect other threads/applications - the counter values will start from zero."
    - "Clearing errors requires write permissions."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_ras_handle_t
      name: hRas
      desc: "[in] Handle for the component."
    - type: $x_bool_t
      name: clear
      desc: "[in] Set to 1 to clear the counters of this type"
    - type: uint64_t*
      name: pTotalErrors
      desc: "[in,out] The number total number of errors that have occurred"
    - type: $s_ras_details_t*
      name: pDetails
      desc: "[in,out][optional] Breakdown of where errors have occurred"
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "Don't have permissions to clear error counters."
--- #--------------------------------------------------------------------------
type: enum
desc: "Event types"
class: $sSysman
name: $s_sysman_event_type_t
etors:
    - name: $S_SYSMAN_EVENT_TYPE_NONE
      value: "0"
      desc: "Specifies no events"
    - name: $S_SYSMAN_EVENT_TYPE_DEVICE_RESET
      value: "$X_BIT( 0 )"
      desc: "Event is triggered when the driver is going to reset the device"
    - name: $S_SYSMAN_EVENT_TYPE_DEVICE_SLEEP_STATE_ENTER
      value: "$X_BIT( 1 )"
      desc: "Event is triggered when the driver is about to put the device into a deep sleep state"
    - name: $S_SYSMAN_EVENT_TYPE_DEVICE_SLEEP_STATE_EXIT
      value: "$X_BIT( 2 )"
      desc: "Event is triggered when the driver is waking the device up from a deep sleep state"
    - name: $S_SYSMAN_EVENT_TYPE_FREQ_THROTTLED
      value: "$X_BIT( 3 )"
      desc: "Event is triggered when the frequency starts being throttled"
    - name: $S_SYSMAN_EVENT_TYPE_ENERGY_THRESHOLD_CROSSED
      value: "$X_BIT( 4 )"
      desc: "Event is triggered when the energy consumption threshold is reached (use $sSysmanPowerSetEnergyThreshold() to configure)."
    - name: $S_SYSMAN_EVENT_TYPE_TEMP_CRITICAL
      value: "$X_BIT( 5 )"
      desc: "Event is triggered when the critical temperature is reached (use $sSysmanTemperatureSetConfig() to configure - disabled by default)."
    - name: $S_SYSMAN_EVENT_TYPE_TEMP_THRESHOLD1
      value: "$X_BIT( 6 )"
      desc: "Event is triggered when the temperature crosses threshold 1 (use $sSysmanTemperatureSetConfig() to configure - disabled by default)."
    - name: $S_SYSMAN_EVENT_TYPE_TEMP_THRESHOLD2
      value: "$X_BIT( 7 )"
      desc: "Event is triggered when the temperature crosses threshold 2 (use $sSysmanTemperatureSetConfig() to configure - disabled by default)."
    - name: $S_SYSMAN_EVENT_TYPE_MEM_HEALTH
      value: "$X_BIT( 8 )"
      desc: "Event is triggered when the health of device memory changes."
    - name: $S_SYSMAN_EVENT_TYPE_FABRIC_PORT_HEALTH
      value: "$X_BIT( 9 )"
      desc: "Event is triggered when the health of fabric ports change."
    - name: $S_SYSMAN_EVENT_TYPE_PCI_LINK_HEALTH
      value: "$X_BIT( 10 )"
      desc: "Event is triggered when the health of the PCI link changes."
    - name: $S_SYSMAN_EVENT_TYPE_RAS_CORRECTABLE_ERRORS
      value: "$X_BIT( 11 )"
      desc: "Event is triggered when accelerator RAS correctable errors cross thresholds (use $sSysmanRasSetConfig() to configure - disabled by default)."
    - name: $S_SYSMAN_EVENT_TYPE_RAS_UNCORRECTABLE_ERRORS
      value: "$X_BIT( 12 )"
      desc: "Event is triggered when accelerator RAS uncorrectable errors cross thresholds (use $sSysmanRasSetConfig() to configure - disabled by default)."
    - name: $S_SYSMAN_EVENT_TYPE_DEVICE_RESET_REQUIRED
      value: "$X_BIT( 14 )"
      desc: "Event is triggered when the device needs to be reset (use $SysmanDeviceGetState() to determine the reasons for the reset)."
    - name: $S_SYSMAN_EVENT_TYPE_ALL
      value: "0x0FFF"
      desc: "Specifies all events"
--- #--------------------------------------------------------------------------
type: struct
desc: "Event configuration for a device"
class: $sSysmanEvent
name: $s_event_config_t
members:
    - type: uint32_t
      name: "registered"
      desc: "[in,out] List of registered events (Bitfield of events $s_sysman_event_type_t). $S_SYSMAN_EVENT_TYPE_NONE indicates there are no registered events. $S_SYSMAN_EVENT_TYPE_ALL indicates that all events are registered."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the event handle for the specified device"
class: $sSysman
name: EventGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle for the device"
    - type: "$s_sysman_event_handle_t*"
      name: phEvent
      desc: "[out] The event handle for the specified device."
--- #--------------------------------------------------------------------------
type: function
desc: "Find out which events are currently registered on the specified device event handler"
class: $sSysmanEvent
name: GetConfig
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_event_handle_t
      name: hEvent
      desc: "[in] The event handle for the device"
    - type: "$s_event_config_t*"
      name: pConfig
      desc: "[in,out] Will contain the current event configuration (list of registered events)."
--- #--------------------------------------------------------------------------
type: function
desc: "Set a new event configuration (list of registered events) on the specified device event handler"
class: $sSysmanEvent
name: SetConfig
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_event_handle_t
      name: hEvent
      desc: "[in] The event handle for the device"
    - type: "const $s_event_config_t*"
      name: pConfig
      desc: "[in] New event configuration (list of registered events)."
--- #--------------------------------------------------------------------------
type: function
desc: "Get events that have been triggered for a specific device"
class: $sSysmanEvent
name: GetState
details:
    - "If events have occurred on the specified device event handle, they are returned and the corresponding event status is cleared if the argument clear = true."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_event_handle_t
      name: hEvent
      desc: "[in] The event handle for the device."
    - type: $x_bool_t
      name: clear
      desc: "[in] Indicates if the event list for this device should be cleared."
    - type: "uint32_t*"
      name: pEvents
      desc: "[in,out] Bitfield of events $s_sysman_event_type_t that have been triggered by this device."
--- #--------------------------------------------------------------------------
type: macro
desc: "Don't wait - just check if there are any new events"
name: $S_EVENT_WAIT_NONE
value: "0x0"
--- #--------------------------------------------------------------------------
type: macro
desc: "Wait infinitely for events to arrive."
name: $S_EVENT_WAIT_INFINITE
value: "0xFFFFFFFF"
--- #--------------------------------------------------------------------------
type: function
desc: "Wait for the specified list of event handles to receive any registered events"
class: $sSysmanEvent
decl: static
name: Listen
details:
    - "If previous events arrived and were not cleared using $sSysmanEventGetState(), this call will return immediately."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $x_driver_handle_t
      name: hDriver
      desc: "[in] handle of the driver instance"
    - type: uint32_t
      name: timeout
      desc: "[in] How long to wait in milliseconds for events to arrive. Set to $S_EVENT_WAIT_NONE will check status and return immediately. Set to $S_EVENT_WAIT_INFINITE to block until events arrive."
    - type: uint32_t
      name: count
      desc: "[in] Number of handles in phEvents"
    - type: "$s_sysman_event_handle_t*"
      name: phEvents
      desc: "[in][range(0, count)] Handle of events that should be listened to"
    - type: "uint32_t*"
      name: pEvents
      desc: "[in,out] Bitfield of events $s_sysman_event_type_t that have been triggered by any of the supplied event handles. If timeout is not $S_EVENT_WAIT_INFINITE and this value is $S_SYSMAN_EVENT_TYPE_NONE, then a timeout has occurred."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to listen to events."
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "One or more of the supplied event handles are for devices that belong to a different driver handle."
--- #--------------------------------------------------------------------------
type: enum
desc: "Diagnostic test suite type"
class: $sSysmanDiagnostics
name: $s_diag_type_t
etors:
    - name: $S_DIAG_TYPE_SCAN
      value: "0"
      desc: "Run SCAN diagnostics"
    - name: $S_DIAG_TYPE_ARRAY
      desc: "Run Array diagnostics"
--- #--------------------------------------------------------------------------
type: enum
desc: "Diagnostic results"
class: $sSysmanDiagnostics
name: $s_diag_result_t
etors:
    - name: $S_DIAG_RESULT_NO_ERRORS
      value: "0"
      desc: "Diagnostic completed without finding errors to repair"
    - name: $S_DIAG_RESULT_ABORT
      desc: "Diagnostic had problems running tests"
    - name: $S_DIAG_RESULT_FAIL_CANT_REPAIR
      desc: "Diagnostic had problems setting up repairs"
    - name: $S_DIAG_RESULT_REBOOT_FOR_REPAIR
      desc: "Diagnostics found errors, setup for repair and reboot is required to complete the process"
--- #--------------------------------------------------------------------------
type: macro
desc: "Diagnostic test index to use for the very first test."
name: $S_DIAG_FIRST_TEST_INDEX
value: "0x0"
--- #--------------------------------------------------------------------------
type: macro
desc: "Diagnostic test index to use for the very last test."
name: $S_DIAG_LAST_TEST_INDEX
value: "0xFFFFFFFF"
--- #--------------------------------------------------------------------------
type: struct
desc: "Diagnostic test"
class: $sSysmanDiagnostics
name: $s_diag_test_t
members:
    - type: uint32_t
      name: "index"
      desc: "[out] Index of the test"
    - type: char
      name: "name[$S_STRING_PROPERTY_SIZE]"
      desc: "[out] Name of the test"
--- #--------------------------------------------------------------------------
type: struct
desc: "Diagnostics test suite properties"
class: $sSysmanDiagnostics
name: $s_diag_properties_t
members:
    - type: $s_diag_type_t
      name: "type"
      desc: "[out] The type of diagnostics test suite"
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: char
      name: "name[$S_STRING_PROPERTY_SIZE]"
      desc: "[out] Name of the diagnostics test suite"
    - type: $x_bool_t
      name: "haveTests"
      desc: "[out] Indicates if this test suite has individual tests which can be run separately (use the function $SysmanDiagnosticsGetTests() to get the list of these tests)"
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of diagnostics test suites"
class: $sSysman
name: DiagnosticsGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$s_sysman_diag_handle_t*"
      name: phDiagnostics
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get properties of a diagnostics test suite"
class: $sSysmanDiagnostics
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_diag_handle_t
      name: hDiagnostics
      desc: "[in] Handle for the component."
    - type: $s_diag_properties_t*
      name: pProperties
      desc: "[in,out] Structure describing the properties of a diagnostics test suite"
--- #--------------------------------------------------------------------------
type: function
desc: "Get individual tests that can be run separately. Not all test suites permit running individual tests - check $s_diag_properties_t.haveTests"
class: $sSysmanDiagnostics
name: GetTests
details:
    - "The list of available tests is returned in order of increasing test index $s_diag_test_t.index."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $s_sysman_diag_handle_t
      name: hDiagnostics
      desc: "[in] Handle for the component."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of tests.
            If count is zero, then the driver will update the value with the total number of tests available.
            If count is non-zero, then driver will only retrieve that number of tests.
            If count is larger than the number of tests available, then the driver will update the value with the correct number of tests available.
    - type: "$s_diag_test_t*"
      name: pTests
      desc: "[in,out][optional][range(0, *pCount)] Array of tests sorted by increasing value of $s_diag_test_t.index"
--- #--------------------------------------------------------------------------
type: function
desc: "Run a diagnostics test suite, either all tests or a subset of tests."
class: $sSysmanDiagnostics
name: RunTests
details:
    - "WARNING: Performancing diagnostics may destroy current device state information. Gracefully close any running workloads before initiating."
    - "To run all tests in a test suite, set start = $S_DIAG_FIRST_TEST_INDEX and end = $S_DIAG_LAST_TEST_INDEX."
    - "If the test suite permits running individual tests, $s_diag_properties_t.haveTests will be true. In this case, the function $sSysmanDiagnosticsGetTests() can be called to get the list of tests and corresponding indices that can be supplied to the arguments start and end in this function."
    - "This function will block until the diagnostics have completed."
params:
    - type: $s_sysman_diag_handle_t
      name: hDiagnostics
      desc: "[in] Handle for the component."
    - type: uint32_t
      name: start
      desc: "[in] The index of the first test to run. Set to $S_DIAG_FIRST_TEST_INDEX to start from the beginning."
    - type: uint32_t
      name: end
      desc: "[in] The index of the last test to run. Set to $S_DIAG_LAST_TEST_INDEX to complete all tests after the start test."
    - type: $s_diag_result_t*
      name: pResult
      desc: "[in,out] The result of the diagnostics"
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to perform diagnostics."
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device"
name: $sSysman
owner: $sDevice
members:
    - type: $s_sysman_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $sDevice*
      name: pDevice
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device scheduler queue"
name: $sSysmanScheduler
owner: $sSysman
members:
    - type: $s_sysman_sched_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $sSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device performance factor"
name: $sSysmanPerformanceFactor
owner: $sSysman
members:
    - type: $s_sysman_perf_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $sSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device power domain"
name: $sSysmanPower
owner: $sSysman
members:
    - type: $s_sysman_pwr_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $sSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device frequency domain"
name: $sSysmanFrequency
owner: $sSysman
members:
    - type: $s_sysman_freq_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $sSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device engine group"
name: $sSysmanEngine
owner: $sSysman
members:
    - type: $s_sysman_engine_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $sSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman standby control"
name: $sSysmanStandby
owner: $sSysman
members:
    - type: $s_sysman_standby_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $sSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device firmware"
name: $sSysmanFirmware
owner: $sSysman
members:
    - type: $s_sysman_firmware_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $sSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device memory module"
name: $sSysmanMemory
owner: $sSysman
members:
    - type: $s_sysman_mem_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $sSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device Fabric port"
name: $sSysmanFabricPort
owner: $sSysman
members:
    - type: $s_sysman_fabric_port_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $sSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device temperature sensor"
name: $sSysmanTemperature
owner: $sSysman
members:
    - type: $s_sysman_temp_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $sSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device power supply"
name: $sSysmanPsu
owner: $sSysman
members:
    - type: $s_sysman_psu_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $sSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device fan"
name: $sSysmanFan
owner: $sSysman
members:
    - type: $s_sysman_fan_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $sSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device LED"
name: $sSysmanLed
owner: $sSysman
members:
    - type: $s_sysman_led_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $sSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device RAS error set"
name: $sSysmanRas
owner: $sSysman
members:
    - type: $s_sysman_ras_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $sSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device diagnostic test suite"
name: $sSysmanDiagnostics
owner: $sSysman
members:
    - type: $s_sysman_diag_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $sSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device event"
name: $sSysmanEvent
owner: $sSysman
members:
    - type: $s_sysman_event_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $sSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
