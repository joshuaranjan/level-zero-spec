--- #--------------------------------------------------------------------------
type: header
desc: "Intel $OneApi Level-Zero Tool APIs for System Resource Management (SMI)"
--- #--------------------------------------------------------------------------
type: enum
desc: "API version of SMI"
class: $tSysman
name: $t_sysman_version_t
etors:
    - name: $T_SYSMAN_VERSION_CURRENT
      value: "$X_MAKE_VERSION( 1, 0 )"
      desc: "version 1.0"
--- #--------------------------------------------------------------------------
type: function
desc: "Get the handle to access SMI features for a device"
class: $tSysman
name: Get
decl: static
details:
    - "The returned handle is unique"
params:
    - type: "$t_device_handle_t"
      name: hDevice
      desc: "[in] Handle of the device"
    - type: "$t_sysman_version_t"
      name: version
      desc: "[in] SMI version that application was built with"
    - type: "$t_sysman_handle_t*"
      name: phSysman
      desc: "[out] Handle for accessing SMI features"

--- #--------------------------------------------------------------------------
type: macro
desc: "Maximum number of characters in string properties."
name: $T_STRING_PROPERTY_SIZE
value: "32"

--- #--------------------------------------------------------------------------
type: struct
desc: "Device properties"
class: $tSysman
name: $t_sysman_properties_t
members:
    - type: $x_device_properties_t
      name: core
      desc: "[out] Core device properties"
    - type: uint32_t
      name: "numSubdevices"
      desc: "[out] Number of sub-devices"
    - type: int8_t
      name: "serialNumber[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] Manufacturing serial number (NULL terminated string value)"
    - type: int8_t
      name: "boardNumber[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] Manufacturing board number (NULL terminated string value)"
    - type: int8_t
      name: "brandName[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] Brand name of the device (NULL terminated string value)"
    - type: int8_t
      name: "modelName[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] Model name of the device (NULL terminated string value)"
    - type: int8_t
      name: "vendorName[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] Vendor name of the device (NULL terminated string value)"
    - type: int8_t
      name: "driverVersion[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] Installed driver version (NULL terminated string value)"
--- #--------------------------------------------------------------------------
type: function
desc: "Get properties about the device"
class: $tSysman
name: DeviceGetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: $t_sysman_properties_t*
      name: pProperties
      desc: "[in] Structure that will contain information about the device."

--- #--------------------------------------------------------------------------
type: enum
desc: "Scheduler mode"
class: $tSysman
name: $t_sched_mode_t
etors:
    - name: $T_SCHED_MODE_CONCURRENT
      value: "0"
      desc: "Multiple applications or contexts are submitting work concurrently to the hardware. When work for one context completes or higher priority work arrives, the scheduler organizes to submit the new work to the hardware as soon as possible."
    - name: $T_SCHED_MODE_TIMESLICE
      desc: "The scheduler attempts to fairly timeslice hardware execution time between multiple contexts submitting work to the hardware concurrently."
    - name: $T_SCHED_MODE_EXCLUSIVE
      desc: "Any application or context can run indefinitely on the hardware without being preempted or terminated. All pending work for other contexts must wait until the running context completes with no further submitted work."
    - name: $T_SCHED_MODE_SINGLE_CMDQUEUE
      desc: "Only a single command queue can execute work at a given time. Work is permitted to run as long as needed without enforcing any scheduler fairness policies."
--- #--------------------------------------------------------------------------
type: macro
desc: "Disable forward progress guard timeout."
name: $T_SCHED_WATCHDOG_DISABLE
value: "(~(0ULL))"
--- #--------------------------------------------------------------------------
type: struct
desc: "Configuration for concurrent scheduler mode ($T_SCHED_MODE_CONCURRENT)"
class: $tSysman
name: $t_sched_concurrent_properties_t
members:
    - type: uint64_t
      name: "watchdogTimeout"
      desc: "[in,out] The maximum time in microseconds that the scheduler will wait for a batch of work submitted to a hardware engine to complete or to be preempted so as to run another context. "
      desc: |
            [in,out] The maximum time in microseconds that the scheduler will wait for a batch of work submitted to a hardware engine to complete or to be preempted so as to run another context.
            If this time is exceeded, the hardware engine is reset and the context terminated.
            If set to $T_SCHED_WATCHDOG_DISABLE, a running workload can run as long as it wants without being terminated, but preemption attempts to run other contexts are permitted but not enforced.
--- #--------------------------------------------------------------------------
type: struct
desc: "Configuration for timeslice scheduler mode ($T_SCHED_MODE_TIMESLICE)"
class: $tSysman
name: $t_sched_timeslice_properties_t
members:
    - type: uint64_t
      name: "interval"
      desc: "[in,out] The average interval in microseconds that a submission for a context will run on a hardware engine before being preempted out to run a pending submission for another context."
    - type: uint64_t
      name: "yieldTimeout"
      desc: "[in,out] The maximum time in microseconds that the scheduler will wait to preempt a workload running on an engine before deciding to reset the hardware engine and terminating the associated context."
--- #--------------------------------------------------------------------------
type: function
desc: "Get current scheduler mode"
class: $tSysman
name: SchedulerGetCurrentMode
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: $t_sched_mode_t*
      name: pMode
      desc: "[in] Will contain the current scheduler mode."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED:
        - "Device does not support scheduler modes."
--- #--------------------------------------------------------------------------
type: function
desc: "Get scheduler config for mode $T_SCHED_MODE_CONCURRENT"
class: $tSysman
name: SchedulerGetConcurrentModeProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: $x_bool_t
      name: getDefaults
      desc: "[in] If TRUE, the driver will return the system default properties for this mode, otherwise it will return the current properties."
    - type: $t_sched_concurrent_properties_t*
      name: pConfig
      desc: "[in] Will contain the current parameters for this mode."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED:
        - "This scheduler mode is not supported. Other modes may be supported unless $tSysmanSchedulerGetCurrentMode() returns the same error in which case no scheduler modes are supported on this device."
--- #--------------------------------------------------------------------------
type: function
desc: "Get scheduler config for mode $T_SCHED_MODE_TIMESLICE"
class: $tSysman
name: SchedulerGetTimesliceModeProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: $x_bool_t
      name: getDefaults
      desc: "[in] If TRUE, the driver will return the system default properties for this mode, otherwise it will return the current properties."
    - type: $t_sched_concurrent_properties_t*
      name: pConfig
      desc: "[in] Will contain the current parameters for this mode."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED:
        - "This scheduler mode is not supported. Other modes may be supported unless $tSysmanSchedulerGetCurrentMode() returns the same error in which case no scheduler modes are supported on this device."
--- #--------------------------------------------------------------------------
type: function
desc: "Change scheduler mode to $T_SCHED_MODE_CONCURRENT or update scheduler mode parameters if already running in this mode."
class: $tSysman
name: SchedulerSetConcurrentMode
details:
    - "This mode is optimized for multiple applications or contexts submitting work concurrently to the hardware. When work for one context completes or higher priority work arrives, the scheduler organizes to submit the new work to the hardware as soon as possible."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: $t_sched_concurrent_properties_t*
      name: pProperties
      desc: "[in] The properties to use when configurating this mode."
    - type: $x_bool_t*
      name: pNeedReboot
      desc: "[in] Will be set to TRUE if a system reboot is needed to apply the new scheduler mode."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED:
        - "This scheduler mode is not supported. Other modes may be supported unless $tSysmanSchedulerGetCurrentMode() returns the same error in which case no scheduler modes are supported on this device."
--- #--------------------------------------------------------------------------
type: function
desc: "Change scheduler mode to $T_SCHED_MODE_TIMESLICE or update scheduler mode parameters if already running in this mode."
class: $tSysman
name: SchedulerSetTimesliceMode
details:
    - "This mode is optimized to provide fair sharing of hardware execution time between multiple contexts submitting work to the hardware concurrently."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: $t_sched_concurrent_properties_t*
      name: pProperties
      desc: "[in] The properties to use when configurating this mode."
    - type: $x_bool_t*
      name: pNeedReboot
      desc: "[in] Will be set to TRUE if a system reboot is needed to apply the new scheduler mode."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED:
        - "This scheduler mode is not supported. Other modes may be supported unless $tSysmanSchedulerGetCurrentMode() returns the same error in which case no scheduler modes are supported on this device."
--- #--------------------------------------------------------------------------
type: function
desc: "Change scheduler mode to $T_SCHED_MODE_EXCLUSIVE"
class: $tSysman
name: SchedulerSetExclusiveMode
details:
    - "This mode is optimized for single application/context use-cases. It permits a context to run indefinitely on the hardware without being preempted or terminated. All pending work for other contexts must wait until the running context completes with no further submitted work."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: $x_bool_t*
      name: pNeedReboot
      desc: "[in] Will be set to TRUE if a system reboot is needed to apply the new scheduler mode."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED:
        - "This scheduler mode is not supported. Other modes may be supported unless $tSysmanSchedulerGetCurrentMode() returns the same error in which case no scheduler modes are supported on this device."
--- #--------------------------------------------------------------------------
type: function
desc: "Change scheduler mode to $T_SCHED_MODE_SINGLE_CMDQUEUE"
class: $tSysman
name: SchedulerSetSingleCmdQueueMode
details:
    - "This mode is optimized for application debug. It ensures that only one command queue can execute work on the hardware at a given time. Work is permitted to run as long as needed without enforcing any scheduler fairness policies."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: $x_bool_t*
      name: pNeedReboot
      desc: "[in] Will be set to TRUE if a system reboot is needed to apply the new scheduler mode."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED:
        - "This scheduler mode is not supported. Other modes may be supported unless $tSysmanSchedulerGetCurrentMode() returns the same error in which case no scheduler modes are supported on this device."

--- #--------------------------------------------------------------------------
type: function
desc: "Reset device"
class: $tSysman
name: DeviceReset
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle for the device"

--- #--------------------------------------------------------------------------
type: function
desc: "Find out if the device has been repaired (either by the manufacturer or by running diagnostics)"
class: $tSysman
name: DeviceWasRepaired
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle for the device"
    - type: $x_bool_t*
      name: pWasRepaired
      desc: "[in] Will indicate if the device was repaired"
returns:
    - $X_RESULT_ERROR_UNSUPPORTED:
        - "This device does not record this information or does not support repair features."

--- #--------------------------------------------------------------------------
type: struct
desc: "PCI address"
class: $tSysman
name: $t_pci_address_t
members:
    - type: uint32_t
      name: "domain"
      desc: "[out] BDF domain"
    - type: uint32_t
      name: "bus"
      desc: "[out] BDF bus"
    - type: uint32_t
      name: "device"
      desc: "[out] BDF device"
    - type: uint32_t
      name: "function"
      desc: "[out] BDF function"
--- #--------------------------------------------------------------------------
type: struct
desc: "PCI speed"
class: $tSysman
name: $t_pci_speed_t
members:
    - type: uint32_t
      name: "gen"
      desc: "[out] The link generation"
    - type: uint32_t
      name: "width"
      desc: "[out] The number of lanes"
    - type: uint32_t
      name: "maxBandwidth"
      desc: "[out] The maximum bandwidth in bytes/sec"
    - type: uint32_t
      name: "maxPacketSize"
      desc: "[out] Maximum packet size in bytes."
--- #--------------------------------------------------------------------------
type: struct
desc: "Static PCI properties"
class: $tSysman
name: $t_pci_properties_t
members:
    - type: $t_pci_address_t
      name: "address"
      desc: "[out] The BDF address"
    - type: uint32_t
      name: "numBars"
      desc: "[out] The number of configured bars"
    - type: $t_pci_speed_t
      name: "maxSpeed"
      desc: "[out] Fastest port configuration supported by the device."
--- #--------------------------------------------------------------------------
type: struct
desc: "Dynamic PCI state"
class: $tSysman
name: $t_pci_state_t
members:
    - type: $t_pci_speed_t
      name: "speed"
      desc: "[out] The current port configure speed"
--- #--------------------------------------------------------------------------
type: enum
desc: "PCI bar types"
class: $tSysman
name: $t_pci_bar_type_t
etors:
    - name: $T_PCI_BAR_TYPE_CONFIG
      value: "0"
      desc: "PCI configuration space"
    - name: $T_PCI_BAR_TYPE_MMIO
      desc: "MMIO registers"
    - name: $T_PCI_BAR_TYPE_VRAM
      desc: "VRAM aperture"
    - name: $T_PCI_BAR_TYPE_ROM
      desc: "ROM aperture"
    - name: $T_PCI_BAR_TYPE_VGA_IO
      desc: "Legacy VGA IO ports"
    - name: $T_PCI_BAR_TYPE_VGA_MEM
      desc: "Legacy VGA memory"
    - name: $T_PCI_BAR_TYPE_INDIRECT_IO
      desc: "Indirect IO port access"
    - name: $T_PCI_BAR_TYPE_INDIRECT_MEM
      desc: "Indirect memory access"
    - name: $T_PCI_BAR_TYPE_OTHER
      desc: "Other type of PCI bar"
--- #--------------------------------------------------------------------------
type: struct
desc: "Properties of a pci bar"
class: $tSysman
name: $t_pci_bar_properties_t
members:
    - type: $t_pci_bar_type_t
      name: "type"
      desc: "[out] The type of bar"
    - type: uint64_t
      name: "base"
      desc: "[out] Base address of the bar."
    - type: uint64_t
      name: "size"
      desc: "[out] Size of the bar."
--- #--------------------------------------------------------------------------
type: struct
desc: "PCI throughput"
class: $tSysman
name: $t_pci_throughput_t
details:
    - "Percent throughput is calculated by taking two snapshots (s1, s2) and using the equation: %bw = 10^6 * ((s2.rxCounter - s1.rxCounter) + (s2.txCounter - s1.txCounter)) / (s2.maxBandwidth * (s2.timestamp - s1.timestamp))"
members:
    - type: uint64_t
      name: "timestamp"
      desc: |
            [out] Monotonic timestamp counter in microseconds when the measurement was made.
            No assumption should be made about the absolute value of the timestamp.
            It should only be used to calculate delta time between two snapshots of the same structure.
            Never take the delta of this timestamp with the timestamp from a different structure.
    - type: uint64_t
      name: "rxCounter"
      desc: "[out] Monotonic counter for the number of bytes received"
    - type: uint64_t
      name: "txCounter"
      desc: "[out] Monotonic counter for the number of bytes transmitted (including replays)"
    - type: uint32_t
      name: "maxBandwidth"
      desc: "[out] The maximum bandwidth in bytes/sec under the current configuration"
--- #--------------------------------------------------------------------------
type: struct
desc: "PCI stats counters"
class: $tSysman
name: $t_pci_stats_t
details:
    - "Percent replays is calculated by taking two snapshots (s1, s2) and using the equation: %replay = 10^6 * (s2.replayCounter - s1.replayCounter) / (s2.maxBandwidth * (s2.timestamp - s1.timestamp))"
members:
    - type: uint64_t
      name: "timestamp"
      desc: |
            [out] Monotonic timestamp counter in microseconds when the measurement was made.
            No assumption should be made about the absolute value of the timestamp.
            It should only be used to calculate delta time between two snapshots of the same structure.
            Never take the delta of this timestamp with the timestamp from a different structure.
    - type: uint64_t
      name: "replayCounter"
      desc: "[out] Monotonic counter for the number of replay packets"
    - type: uint64_t
      name: "packetCounter"
      desc: "[out] Monotonic counter for the number of packets"
--- #--------------------------------------------------------------------------
type: function
desc: "Get PCI properties - address, max speed"
class: $tSysman
name: PciGetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: $t_pci_properties_t*
      name: pProperties
      desc: "[in] Will contain the PCI properties."
--- #--------------------------------------------------------------------------
type: function
desc: "Get current PCI state - current speed"
class: $tSysman
name: PciGetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: $t_pci_state_t*
      name: pState
      desc: "[in] Will contain the PCI properties."
--- #--------------------------------------------------------------------------
type: function
desc: "Get properties of a bar"
class: $tSysman
name: PciGetBarProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: uint32_t
      name: barIndex
      desc: "[in] The index of the bar (0 ... [$t_pci_properties_t.numBars - 1])."
    - type: $t_pci_bar_properties_t*
      name: pProperties
      desc: "[in] Will contain properties of the specified bar"
--- #--------------------------------------------------------------------------
type: function
desc: "Get PCI throughput"
class: $tSysman
name: PciGetThroughput
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: $t_pci_throughput_t*
      name: pThroughput
      desc: "[in] Will contain a snapshot of the latest throughput counters."
--- #--------------------------------------------------------------------------
type: function
desc: "Get PCI stats"
class: $tSysman
name: PciGetStats
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: $t_pci_stats_t*
      name: pStats
      desc: "[in] Will contain a snapshot of the latest stats."

--- #--------------------------------------------------------------------------
type: struct
desc: "Properties related to device power settings"
class: $tSysmanPower
name: $t_power_properties_t
members:
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling SMI handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $x_bool_t
      name: "canControl"
      desc: "[out] Software can change the power limits."
    - type: uint32_t
      name: "maxLimit"
      desc: "[out] The maximum power limit in milliwatts that can be requested."
--- #--------------------------------------------------------------------------
type: struct
desc: "Energy counter snapshot"
class: $tSysmanPower
name: $t_power_energy_counter_t
details:
    - "Average power is calculated by taking two snapshots (s1, s2) and using the equation: PowerWatts = (s2.energy - s1.energy) / (s2.timestamp - s1.timestamp)"
members:
    - type: uint64_t
      name: "energy"
      desc: "[out] The monotonic energy counter in microjoules."
    - type: uint64_t
      name: "timestamp"
      desc: |
            [out] Microsecond timestamp when energy was captured.
            No assumption should be made about the absolute value of the timestamp.
            It should only be used to calculate delta time between two snapshots of the same structure.
            Never take the delta of this timestamp with the timestamp from a different structure.
--- #--------------------------------------------------------------------------
type: struct
desc: "Energy threshold"
class: $tSysmanPower
name: $t_power_energy_threshold_t
details:
    - "Energy threshold value, when this value is crossed, pcu will signal an interrupt."
members:
    - type: uint32_t
      name: "energy"
      desc: "[in,out] The energy threshold in joules."
--- #--------------------------------------------------------------------------
type: struct
desc: "Sustained power limits"
class: $tSysmanPower
name: $t_power_sustained_limit_t
details:
    - "The power controller (Punit) will throttle the operating frequency if the power averaged over a window (typically seconds) exceeds this limit."
members:
    - type: $x_bool_t
      name: enabled
      desc: "[in,out] indicates if the limit is enabled (true) or ignored (false)"
    - type: uint32_t
      name: power
      desc: "[in,out] power limit in milliwatts"
    - type: uint32_t
      name: interval
      desc: "[in,out] power averaging window (Tau) in milliseconds"
--- #--------------------------------------------------------------------------
type: struct
desc: "Burst power limit"
class: $tSysmanPower
name: $t_power_burst_limit_t
details:
    - "The power controller (Punit) will throttle the operating frequency of the device if the power averaged over a few milliseconds exceeds a limit known as PL2. Typically PL2 > PL1 so that it permits the frequency to burst higher for short periods than would be otherwise permitted by PL1."
members:
    - type: $x_bool_t
      name: enabled
      desc: "[in,out] indicates if the limit is enabled (true) or ignored (false)"
    - type: uint32_t
      name: power
      desc: "[in,out] power limit in milliwatts"
--- #--------------------------------------------------------------------------
type: struct
desc: "Peak power limit"
class: $tSysmanPower
name: $t_power_peak_limit_t
details:
    - "The power controller (Punit) will preemptively throttle the operating frequency of the device when the instantaneous power exceeds this limit. The limit is known as PL4. It expresses the maximum power that can be drawn from the power supply."
    - "If this power limit is removed or set too high, the power supply will generate an interrupt when it detects an overcurrent condition and the power controller will throttle the device frequencies down to min. It is thus better to tune the PL4 value in order to avoid such excursions."
members:
    - type: uint32_t
      name: power
      desc: "[in,out] power limit in milliwatts"
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of power domains"
class: $tSysman
name: PowerGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_pwr_handle_t*"
      name: phPower
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get properties related to a power domain"
class: $tSysmanPower
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_pwr_handle_t
      name: hPower
      desc: "[in] Handle for the component."
    - type: $t_power_properties_t*
      name: pProperties
      desc: "[in] Structure that will contain property data."
--- #--------------------------------------------------------------------------
type: function
desc: "Get energy counter"
class: $tSysmanPower
name: GetEnergyCounter
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_pwr_handle_t
      name: hPower
      desc: "[in] Handle for the component."
    - type: $t_power_energy_counter_t*
      name: pEnergy
      desc: "[in] Will contain the latest snapshot of the energy counter and timestamp when the last counter value was measured."
--- #--------------------------------------------------------------------------
type: function
desc: "Get energy threshold"
class: $tSysmanPower
name: GetEnergyThreshold
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_pwr_handle_t
      name: hPower
      desc: "[in] Handle for the component."
    - type: $t_power_energy_threshold_t*
      name: pThreshold
      desc: "[out] The current energy threshold value in joules."
--- #--------------------------------------------------------------------------
type: function
desc: "Set energy threshold"
class: $tSysmanPower
name: SetEnergyThreshold
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_pwr_handle_t
      name: hPower
      desc: "[in] Handle for the component."
    - type: $t_power_energy_threshold_t*
      name: pThreshold
      desc: "[in] The energy threshold to be set in joules."
--- #--------------------------------------------------------------------------
type: function
desc: "Get power limits"
class: $tSysmanPower
name: GetLimits
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_pwr_handle_t
      name: hPower
      desc: "[in] Handle for the component."
    - type: $t_power_sustained_limit_t*
      name: pSustained
      desc: "[in][optional] The sustained power limit."
    - type: $t_power_burst_limit_t*
      name: pBurst
      desc: "[in][optional] The burst power limit."
    - type: $t_power_peak_limit_t*
      name: pPeak
      desc: "[in][optional] The peak power limit."
--- #--------------------------------------------------------------------------
type: function
desc: "Set power limits"
class: $tSysmanPower
name: SetLimits
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_pwr_handle_t
      name: hPower
      desc: "[in] Handle for the component."
    - type: const $t_power_sustained_limit_t*
      name: pSustained
      desc: "[in][optional] The sustained power limit."
    - type: const $t_power_burst_limit_t*
      name: pBurst
      desc: "[in][optional] The burst power limit."
    - type: const $t_power_peak_limit_t*
      name: pPeak
      desc: "[in][optional] The peak power limit."
--- #--------------------------------------------------------------------------
type: enum
desc: "Overcloking modes"
class: $tSysmanFrequency
name: $t_oc_mode_t
etors:
    - name: $T_OC_MODE_INTERPOLATIVE
      value: "0"
      desc: "Interpolative Mode."
    - name: $T_OC_MODE_OVERRIDE
      value: "1"
      desc: "Override Mode."
--- #--------------------------------------------------------------------------
type: enum
desc: "Overclocking error type"
class: $tSysmanFrequency
name: $t_oc_error_type_t
etors:
    - name: $T_OVERCLOCKING_LOCKED
      value: "225"
      desc: "The overclocking is locked. Service is read-only."
    - name: $T_OVERCLOCKING_DDOMAIN_SERVICE_NOT_SUPPORTED
      desc: "The specified domain does not support the requested service."
    - name: $T_OVERCLOCKING_RATIO_EXCEEDS_MAX
      desc: "The ratio exceeds maximum overclocking limits."
    - name: $T_OVERCLOCKING_VOLTAGE_EXCEEDS_MAX
      desc: "Requested voltage exceeds input regulators max supported voltage."
    - name: $T_OVERCLOCKING_NOT_SUPPORTED
      desc: "No overclocking capability on the Hardware."
    - name: $OVERCLOCKING_INVALID_VR_ADDRESS
      desc: "The VR Address provided is illegal."
    - name: $OVERCLOCKING_INVALID_ICCMAX
      desc: "ICCMAX value given is invalid (more than 10 bits) or too low."
    - name: $T_OVERCLOCKING_VOLTAGE_OVERRIDE_DISABLED
      desc: "Voltage manipulation attempted when it is disabled."
    - name: $T_OVERCLOCKING_INVALID_COMMAND
      desc: "Data setting invalid for the command."
--- #--------------------------------------------------------------------------
type: struct
desc: "Overclocking VR Topolgy"
class: $tSysmanFrequency
name: $t_oc_vr_topology
details:
    - "Provides all the information related to the VR."
members:
    - type: $x_bool_t
      name: VccInAuxExists
      desc: "[out] VCCIN_AUX Exists (asserted if separate VR)"
    - type: $x_bool_t
      name: VccStgPgExists
      desc: "[out] VCCSTG_PG Exists"
    - type: $x_bool_t
      name: VccStPgExists
      desc: "[out] VCCST_PG Exists"
    - type: $x_bool_t
      name: VccSfrOcPgExists
      desc: "[out] VCCSFR_OC_PG Exists"
    - type: uint16_t
      name: VccInAuxLp
      desc: "[out] VCCIN_Aux_LP Level (0: 1.8v, 1: 1.65v)"
    - type: uint16_t
      name: VccInSvidAddress
      desc: "[out] VCCIN SVID Address"
    - type: uint16_t
      name: VccInVrType
      desc: "[out] VCCIN VR Type (asserted if SVID)"
    - type: uint16_t
      name: SvidNotPresent
      desc: "[out] SVID not present"
    - type: uint16_t
      name: PsysDisabled
      desc: "[out] PSYS Disabled"      
--- #--------------------------------------------------------------------------
type: struct
desc: "Overclocking properties"
class: $tSysmanFrequency
name: $t_oc_capabilities_t
details:
    - "Provides all the overclocking capabilities and properties supported by the device in the current domain."
members:
    - type: uint16_t
      name: MaxOcRatioLimit
      desc: "[out] Max overclocking ratio limit"
    - type: uint16_t
      name: P0Ratio
      desc: "[out] Fused P0 ratio."
    - type: uint16_t
      name: P0Voltage
      desc: "[out] Fused P0 voltage."
    - type: $x_bool_t
      name: RatioOcSupported
      desc: "[out] Ratio overclocking supported"
    - type: $x_bool_t
      name: VoltageOverrideSupported
      desc: "[out] Voltage overrides supported"
    - type: $x_bool_t
      name: VoltageOffsetSupported
      desc: "[out] Voltage offset is supported"
    - type: $x_bool_t
      name: HighVoltModeCapable
      desc: "[out] Capable of high voltage mode"
    - type: $x_bool_t
      name: HighVoltModeEnabled
      desc: "[out] High voltage mode is enabled"
    - type: $t_oc_vr_topology
      name: OcVrTopology
      desc: "[out] Hold all the Vr Topology properties."
--- #--------------------------------------------------------------------------
type: struct
desc: "Overclocking settings override"
class: $tSysmanFrequency
name: $t_oc_settings_override_t
details:
    - "Provide the current settings to be read or changed."
members:
    - type: uint16_t
      name: MaxOcRatio
      desc: "[in,out] Max overclocking ratio"
    - type: uint16_t
      name: TargetVoltage
      desc: "[in,out] Target Voltage. Units: divide by 2^10 for decimal voltage."
    - type: uint16_t
      name: TargetMode
      desc: "[in,out] Overclock Mode: 0 - Interpolative,  1 - Override."
    - type: uint16_t
      name: VoltageOffset
      desc: "[in,out] Voltage offset +/-999mV (minimum end voltage cannot be lower than 250mV)."
    - type: uint32_t
      name: ICCMax
      desc: "[in,out] Maximum desired current."  
    - type: uint32_t
      name: TjMax
      desc: "[in,out] Maximum temperature in °C."  
--- #--------------------------------------------------------------------------
type: struct
desc: "Fan Point."
class: $tSysmanFrequency
name: $t_oc_fan_point_t
details:
    - "Temperature is given in °C and fan speed is given as a percentage value"
members:
    - type: uint8_t
      name: TemperatureDegreesCelsius
      desc: "[in] Temperature for current point."
    - type: uint8_t
      name: FanSpeedPercent
      desc: "[in] Percentage value, where 0% means stop the fan and 100% means run the fan at maximum speed." 
--- #--------------------------------------------------------------------------
type: struct
desc: "Fan control settings."
class: $tSysmanFrequency
name: $t_oc_fan_control_t
details:
    - "Provide the means to control the fan speed."
members:
    - type: uint32_t
      name: FanPointsNumber
      desc: "[in] Number of fan points."
    - type: $t_oc_fan_point_t*
      name: pFanPoints
      desc: "[in] Array with FanPointsNumber of points."
--- #--------------------------------------------------------------------------
type: function
desc: "Set fan speed"
class: $tSysmanFrequency
name: SetFanSpeed
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $t_oc_fan_control_t*
      name: pFanControl
      desc: "[out] Pointer to the allocated structure."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the overclocking capabilities."
class: $tSysmanFrequency
name: GetOcCapabilities
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $t_oc_capabilities_t*
      name: pOcCapabilities
      desc: "[out] Pointer to the allocated structure."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the Vr topology."
class: $tSysmanFrequency
name: GetOcVrTopology
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $t_oc_vr_topology*
      name: pOcVrTopology
      desc: "[out] Pointer to the allocated structure."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the Oc override properties."
class: $tSysmanFrequency
name: GetOcOverrideProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $t_oc_settings_override_t*
      name: pOcSettingsOverride
      desc: "[out] Pointer to the allocated structure."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the Oc Icc Max."
class: $tSysmanFrequency
name: GetOcIccMax
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: uint32_t*
      name: pOcIccMax
      desc: "[out] Pointer to the allocated uint32."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the Oc Tj Max."
class: $tSysmanFrequency
name: GetOcTjMax
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: uint32_t*
      name: pOcTjMax
      desc: "[out] Pointer to the allocated uint32."
--- #--------------------------------------------------------------------------
type: function
desc: "Set the Oc override properties."
class: $tSysmanFrequency
name: SetOcOverrideProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $t_oc_settings_override_t*
      name: pOcSettingsOverride
      desc: "[in] Pointer to the allocated structure."
--- #--------------------------------------------------------------------------
type: function
desc: "Set the Oc Icc Max."
class: $tSysmanFrequency
name: SetOcIccMax
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: uint32_t*
      name: pOcIccMax
      desc: "[in] Pointer to the allocated uint32."
--- #--------------------------------------------------------------------------
type: function
desc: "Set the Oc Tj Max."
class: $tSysmanFrequency
name: SetOcTjMax
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: uint32_t*
      name: pOcTjMax
      desc: "[in] Pointer to the allocated uint32."
--- #--------------------------------------------------------------------------
type: enum
desc: "Frequency domains"
class: $tSysmanFrequency
name: $t_freq_domain_t
etors:
    - name: $T_FREQ_DOMAIN_GPU
      value: "0"
      desc: "Frequency of the GPU."
    - name: $T_FREQ_DOMAIN_MEMORY
      desc: "Frequency of the local memory."
--- #--------------------------------------------------------------------------
type: struct
desc: "Frequency properties"
class: $tSysmanFrequency
name: $t_freq_properties_t
details:
    - "Provides the set of frequencies as a list and as a range/step."
    - "It is generally recommended that applications choose frequencies from the list. However applications can also construct the list themselves using the range/steps provided."
members:
    - type: $t_freq_domain_t
      name: "type"
      desc: "[out] The type of frequency domain (GPU, memory, ...)"
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling SMI handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $x_bool_t
      name: canControl
      desc: "[out] Indicates if software can control the frequency of this domain"
    - type: $x_bool_t
      name: canOverclock
      desc: "[out] Indicates if software can overclock this frequency domain"
    - type: double
      name: min
      desc: "[out] The minimum clock frequency in units of MHz"
    - type: double
      name: max
      desc: "[out] The maximum clock frequency in units of MHz"
    - type: double
      name: step
      desc: "[out] The step clock frequency in units of MHz"
    - type: uint32_t
      name: num
      desc: "[out] The number of clocks in the array pClocks"
    - type: "const double*"
      name: "pClocks"
      desc: "[out] Array of clock frequencies in units of MHz ordered from smallest to largest."
--- #--------------------------------------------------------------------------
type: struct
desc: "Frequency range between which the hardware can operate."
class: $tSysmanFrequency
name: $t_freq_range_t
members:
    - type: double
      name: "min"
      desc: "[in,out] The min frequency in MHz below which hardware frequency management will not request frequencies. Setting to 0 will use the hardware default value."
    - type: double
      name: "max"
      desc: "[in,out] The max frequency in MHz above which hardware frequency management will not request frequencies. Setting to 0 will use the hardware default value."
--- #--------------------------------------------------------------------------
type: enum
desc: "Frequency throttle reasons"
class: $tSysmanFrequency
name: $t_freq_throttle_reasons_t
etors:
    - name: $T_FREQ_THROTTLE_REASONS_NONE
      value: "0"
      desc: "frequency not throttled"
    - name: $T_FREQ_THROTTLE_REASONS_AVE_PWR_CAP
      value: "$X_BIT( 0 )"
      desc: "frequency throttled due to average power excursion (PL1)"
    - name: $T_FREQ_THROTTLE_REASONS_BURST_PWR_CAP
      value: "$X_BIT( 1 )"
      desc: "frequency throttled due to burst power excursion (PL2)"
    - name: $T_FREQ_THROTTLE_REASONS_CURRENT_LIMIT
      value: "$X_BIT( 2 )"
      desc: "frequency throttled due to current excursion (PL4)"
    - name: $T_FREQ_THROTTLE_REASONS_THERMAL_LIMIT
      value: "$X_BIT( 3 )"
      desc: "frequency throttled due to thermal excursion (T > TjMax)"
    - name: $T_FREQ_THROTTLE_REASONS_PSU_ALERT
      value: "$X_BIT( 4 )"
      desc: "frequency throttled due to power supply assertion"
    - name: $T_FREQ_THROTTLE_REASONS_SW_RANGE
      value: "$X_BIT( 5 )"
      desc: "frequency throttled due to software supplied frequency range"
    - name: $T_FREQ_THROTTLE_REASONS_HW_RANGE
      value: "$X_BIT( 6 )"
      desc: "frequency throttled due to a sub block that has a lower frequency range when it receives clocks"
--- #--------------------------------------------------------------------------
type: struct
desc: "Frequency state"
class: $tSysmanFrequency
name: $t_freq_state_t
members:
    - type: double
      name: "request"
      desc: "[out] The current frequency request in MHz."
    - type: double
      name: "tdp"
      desc: "[out] The maximum frequency in MHz supported under the current TDP conditions"
    - type: double
      name: "efficient"
      desc: "[out] The efficient minimum frequency in MHz"
    - type: double
      name: "actual"
      desc: "[out] The resolved frequency in MHz"
    - type: uint32_t
      name: "throttleReasons"
      desc: "[out] The reasons that the frequency is being limited by the hardware (Bitfield of (1<<$t_freq_throttle_reasons_t))."
--- #--------------------------------------------------------------------------
type: struct
desc: "Frequency throttle time snapshot"
class: $tSysmanFrequency
name: $t_freq_throttle_time_t
details:
    - "Percent time throttled is calculated by taking two snapshots (s1, s2) and using the equation: %throttled = (s2.throttleTime - s1.throttleTime) / (s2.timestamp - s1.timestamp)"
members:
    - type: uint64_t
      name: "throttleTime"
      desc: "[out] The monotonic counter of time in microseconds that the frequency has been limited by the hardware."
    - type: uint64_t
      name: "timestamp"
      desc: |
            [out] Microsecond timestamp when throttleTime was captured.
            No assumption should be made about the absolute value of the timestamp.
            It should only be used to calculate delta time between two snapshots of the same structure.
            Never take the delta of this timestamp with the timestamp from a different structure.
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of frequency domains"
class: $tSysman
name: FrequencyGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_freq_handle_t*"
      name: phFrequency
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get frequency properties - available frequencies"
class: $tSysmanFrequency
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $t_freq_properties_t*
      name: pProperties
      desc: "[in] The frequency properties for the specified domain."
--- #--------------------------------------------------------------------------
type: function
desc: "Get current frequency limits"
class: $tSysmanFrequency
name: GetRange
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $t_freq_range_t*
      name: pLimits
      desc: "[in] The range between which the hardware can operate for the specified domain."
--- #--------------------------------------------------------------------------
type: function
desc: "Set frequency range between which the hardware can operate."
class: $tSysmanFrequency
name: SetRange
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: const $t_freq_range_t*
      name: pLimits
      desc: "[in] The limits between which the hardware can operate for the specified domain."
--- #--------------------------------------------------------------------------
type: function
desc: "Get current frequency state - frequency request, actual frequency, TDP limits"
class: $tSysmanFrequency
name: GetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $t_freq_state_t*
      name: pState
      desc: "[in] Frequency state for the specified domain."
--- #--------------------------------------------------------------------------
type: function
desc: "Get frequency throttle time"
class: $tSysmanFrequency
name: GetThrottleTime
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $t_freq_throttle_time_t*
      name: pThrottleTime
      desc: "[in] Will contain a snapshot of the throttle time counters for the specified domain."

--- #--------------------------------------------------------------------------
type: enum
desc: "Accelerator engine groups"
class: $tSysmanEngine
name: $t_engine_group_t
etors:
    - name: $T_ENGINE_GROUP_ALL
      value: "0"
      desc: "Access information about all engines combined."
    - name: $T_ENGINE_GROUP_COMPUTE
      desc: "Access information about compute engines."
    - name: $T_ENGINE_GROUP_MEDIA
      desc: "Access information about media engines."
--- #--------------------------------------------------------------------------
type: struct
desc: "Engine group properties"
class: $tSysmanEngine
name: $t_engine_properties_t
members:
    - type: $t_engine_group_t
      name: "type"
      desc: "[out] The engine group"
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling SMI handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
--- #--------------------------------------------------------------------------
type: struct
desc: "Engine activity counters"
details:
    - "Percent utilization is calculated by taking two snapshots (s1, s2) and using the equation: %util = (s2.activeTime - s1.activeTime) / (s2.timestamp - s1.timestamp)"
class: $tSysmanEngine
name: $t_engine_stats_t
members:
    - type: uint64_t
      name: "activeTime"
      desc: "[out] Monotonic counter for time in microseconds that this resource is actively running workloads."
    - type: uint64_t
      name: "timestamp"
      desc: |
            [out] Monotonic timestamp counter in microseconds when activeTime counter was sampled.
            No assumption should be made about the absolute value of the timestamp.
            It should only be used to calculate delta time between two snapshots of the same structure.
            Never take the delta of this timestamp with the timestamp from a different structure.
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of engine groups"
class: $tSysman
name: EngineGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_engine_handle_t*"
      name: phEngine
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get engine group properties"
class: $tSysmanEngine
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_engine_handle_t
      name: hEngine
      desc: "[in] Handle for the component."
    - type: $t_engine_properties_t*
      name: pProperties
      desc: "[in] The properties for the specified engine group."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the activity stats for an engine group"
class: $tSysmanEngine
name: GetActivity
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_engine_handle_t
      name: hEngine
      desc: "[in] Handle for the component."
    - type: $t_engine_stats_t*
      name: pStats
      desc: "[in] Will contain a snapshot of the engine group activity counters."

--- #--------------------------------------------------------------------------
type: enum
desc: "Standby hardware components"
class: $tSysmanStandby
name: $t_standby_type_t
etors:
    - name: $T_STANDBY_TYPE_GLOBAL
      value: "0"
      desc: "Control the overall standby policy of the device/sub-device"
--- #--------------------------------------------------------------------------
type: struct
desc: "Standby hardware component properties"
class: $tSysmanStandby
name: $t_standby_properties_t
members:
    - type: $t_standby_type_t
      name: "type"
      desc: "[out] Which standby hardware component this controls"
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling SMI handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
--- #--------------------------------------------------------------------------
type: enum
desc: "Standby promotion modes"
class: $tSysmanStandby
name: $t_standby_promo_mode_t
etors:
    - name: $T_STANDBY_PROMO_MODE_DEFAULT
      value: "0"
      desc: "Best compromise between performance and energy savings."
    - name: $T_STANDBY_PROMO_MODE_NEVER
      desc: "The device/component will never shutdown. This can improve performance but uses more energy."
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of standby controls"
class: $tSysman
name: StandbyGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_standby_handle_t*"
      name: phStandby
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get standby hardware component properties"
class: $tSysmanStandby
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_standby_handle_t
      name: hStandby
      desc: "[in] Handle for the component."
    - type: $t_standby_properties_t*
      name: pProperties
      desc: "[in] Will contain the standby hardware properties."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the current standby promotion mode"
class: $tSysmanStandby
name: GetMode
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_standby_handle_t
      name: hStandby
      desc: "[in] Handle for the component."
    - type: $t_standby_promo_mode_t*
      name: pMode
      desc: "[in] Will contain the current standby mode."
--- #--------------------------------------------------------------------------
type: function
desc: "Set standby promotion mode"
class: $tSysmanStandby
name: SetMode
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_standby_handle_t
      name: hStandby
      desc: "[in] Handle for the component."
    - type: $t_standby_promo_mode_t
      name: mode
      desc: "[in] New standby mode."

--- #--------------------------------------------------------------------------
type: struct
desc: "Firmware properties"
class: $tSysmanFirmware
name: $t_firmware_properties_t
members:
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling SMI handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $x_bool_t
      name: "canControl"
      desc: "[out] Indicates if software can flash the firmware"
    - type: int8_t
      name: "name[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] NULL terminated string value"
    - type: int8_t
      name: "version[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] NULL terminated string value"
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of firmwares"
class: $tSysman
name: FirmwareGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_firmware_handle_t*"
      name: phFirmware
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get firmware properties"
class: $tSysmanFirmware
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_firmware_handle_t
      name: hFirmware
      desc: "[in] Handle for the component."
    - type: $t_firmware_properties_t*
      name: pProperties
      desc: "[in] Pointer to an array that will hold the properties of the firmware"
--- #--------------------------------------------------------------------------
type: function
desc: "Get firmware checksum"
class: $tSysmanFirmware
name: GetChecksum
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_firmware_handle_t
      name: hFirmware
      desc: "[in] Handle for the component."
    - type: uint32_t*
      name: pChecksum
      desc: "[in] Calculated checksum of the installed firmware."
--- #--------------------------------------------------------------------------
type: function
desc: "Flash a new firmware image"
class: $tSysmanFirmware
name: Flash
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_firmware_handle_t
      name: hFirmware
      desc: "[in] Handle for the component."
    - type: void*
      name: pImage
      desc: "[in] Image of the new firmware to flash."
    - type: uint32_t
      name: size
      desc: "[in] Size of the flash image."

--- #--------------------------------------------------------------------------
type: enum
desc: "Memory module types"
class: $tSysmanMemory
name: $t_mem_type_t
etors:
    - name: $T_MEM_TYPE_HBM
      value: "0"
      desc: "HBM memory"
    - name: $T_MEM_TYPE_DDR
      desc: "DDR memory"
    - name: $T_MEM_TYPE_SRAM
      desc: "SRAM memory"
    - name: $T_MEM_TYPE_L1
      desc: "L1 cache"
    - name: $T_MEM_TYPE_L3
      desc: "L3 cache"
    - name: $T_MEM_TYPE_GRF
      desc: "Execution unit register file"
    - name: $T_MEM_TYPE_SLM
      desc: "Execution unit shared local memory"
--- #--------------------------------------------------------------------------
type: struct
desc: "Memory properties"
class: $tSysmanMemory
name: $t_mem_properties_t
members:
    - type: $t_mem_type_t
      name: type
      desc: "[out] The memory type"
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling SMI handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: uint64_t
      name: size
      desc: "[out] Physical memory size in bytes"
--- #--------------------------------------------------------------------------
type: struct
desc: "Memory bandwidth"
class: $tSysmanMemory
name: $t_mem_bandwidth_t
details:
    - "Percent bandwidth is calculated by taking two snapshots (s1, s2) and using the equation: %bw = 10^6 * ((s2.readCounter - s1.readCounter) + (s2.writeCounter - s1.writeCounter)) / (s2.maxBandwidth * (s2.timestamp - s1.timestamp))"
members:
    - type: uint64_t
      name: readCounter
      desc: "[out] Total bytes read from memory"
    - type: uint64_t
      name: writeCounter
      desc: "[out] Total bytes written to memory"
    - type: uint64_t
      name: maxBandwidth
      desc: "[out] Current maximum bandwidth in units of bytes/sec"
    - type: uint64_t
      name: timestamp
      desc: |
            [out] The timestamp when these measurements were sampled.
            No assumption should be made about the absolute value of the timestamp.
            It should only be used to calculate delta time between two snapshots of the same structure.
            Never take the delta of this timestamp with the timestamp from a different structure.
--- #--------------------------------------------------------------------------
type: struct
desc: "Memory allocation"
class: $tSysmanMemory
name: $t_mem_alloc_t
details:
    - "Percent allocation is given by 100 * allocated / total."
    - "Percent free is given by 100 * (total - allocated) / total."
members:
    - type: uint64_t
      name: allocated
      desc: "[out] The total allocated bytes"
    - type: uint64_t
      name: total
      desc: "[out] The total physical memory in bytes"
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of memory modules"
class: $tSysman
name: MemoryGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_mem_handle_t*"
      name: phMemory
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get memory properties"
class: $tSysmanMemory
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_mem_handle_t
      name: hMemory
      desc: "[in] Handle for the component."
    - type: $t_mem_properties_t*
      name: pProperties
      desc: "[in] Will contain memory properties."
--- #--------------------------------------------------------------------------
type: function
desc: "Get memory bandwidth"
class: $tSysmanMemory
name: GetBandwidth
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_mem_handle_t
      name: hMemory
      desc: "[in] Handle for the component."
    - type: $t_mem_bandwidth_t*
      name: pBandwidth
      desc: "[in] Will contain a snapshot of the bandwidth counters."
--- #--------------------------------------------------------------------------
type: function
desc: "Get memory allocation"
class: $tSysmanMemory
name: GetAllocated
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_mem_handle_t
      name: hMemory
      desc: "[in] Handle for the component."
    - type: $t_mem_alloc_t*
      name: pAllocated
      desc: "[in] Will contain the current allocated memory."

--- #--------------------------------------------------------------------------
type: struct
desc: "Connectivity switch properties"
class: $tSysmanLinkSwitch
name: $t_link_switch_properties_t
members:
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the switch is located on a sub-device; false means that the switch is on the device of the calling SMI handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
--- #--------------------------------------------------------------------------
type: struct
desc: "Connectivity switch state"
class: $tSysmanLinkSwitch
name: $t_link_switch_state_t
members:
    - type: $x_bool_t
      name: "enabled"
      desc: "[out] Indicates if the switch is enabled/disabled"
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of connectivity switches"
class: $tSysman
name: LinkSwitchGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_link_switch_handle_t*"
      name: phSwitch
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get connectivity switch properties"
class: $tSysmanLinkSwitch
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_link_switch_handle_t
      name: hSwitch
      desc: "[in] Handle for the component."
    - type: $t_link_switch_properties_t*
      name: pProperties
      desc: "[in] Will contain the Switch properties."
--- #--------------------------------------------------------------------------
type: function
desc: "Get connectivity switch state"
class: $tSysmanLinkSwitch
name: GetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_link_switch_handle_t
      name: hSwitch
      desc: "[in] Handle for the component."
    - type: $t_link_switch_state_t*
      name: pState
      desc: "[in] Will contain the current state of the switch (enabled/disabled)."
--- #--------------------------------------------------------------------------
type: function
desc: "Set connectivity switch state"
class: $tSysmanLinkSwitch
name: SetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_link_switch_handle_t
      name: hSwitch
      desc: "[in] Handle for the component."
    - type: $x_bool_t
      name: enable
      desc: "[in] Set to true to enable the Switch, otherwise it will be disabled."

--- #--------------------------------------------------------------------------
type: struct
desc: "Connectivity port speed"
class: $tSysmanLinkPort
name: $t_link_port_speed_t
members:
    - type: uint32_t
      name: "bitRate"
      desc: "[out] Bits/sec that the link is operating at"
    - type: uint32_t
      name: "width"
      desc: "[out] The number of lanes"
    - type: uint32_t
      name: "maxBandwidth"
      desc: "[out] The maximum bandwidth in bytes/sec"
--- #--------------------------------------------------------------------------
type: struct
desc: "Connectivity port properties"
class: $tSysmanLinkPort
name: $t_link_port_properties_t
members:
    - type: uint32_t
      name: "portNum"
      desc: "[out] The port number on the switch"
    - type: $t_link_port_speed_t
      name: "maxSpeed"
      desc: "[out] Maximum bandwidth supported by the port"
--- #--------------------------------------------------------------------------
type: struct
desc: "Connectivity port state"
class: $tSysmanLinkPort
name: $t_link_port_state_t
members:
    - type: $x_bool_t
      name: "isConnected"
      desc: "[out] Indicates if the port is connected to a remote Switch"
    - type: $t_link_port_speed_t
      name: "rxSpeed"
      desc: "[out] Current maximum receive speed"
    - type: $t_link_port_speed_t
      name: "txSpeed"
      desc: "[out] Current maximum transmit speed"
--- #--------------------------------------------------------------------------
type: struct
desc: "Connectivity port throughput"
class: $tSysmanLinkPort
name: $t_link_port_throughput_t
details:
    - "Percent throughput is calculated by taking two snapshots (s1, s2) and using the equation:"
    - "    %rx_bandwidth = 10^6 * (s2.rxCounter - s1.rxCounter) / (s2.rxMaxBandwidth * (s2.timestamp - s1.timestamp))"
    - "    %tx_bandwidth = 10^6 * (s2.txCounter - s1.txCounter) / (s2.txMaxBandwidth * (s2.timestamp - s1.timestamp))"
members:
    - type: uint64_t
      name: "timestamp"
      desc: |
            [out] Monotonic timestamp counter in microseconds when the measurement was made.
            No assumption should be made about the absolute value of the timestamp.
            It should only be used to calculate delta time between two snapshots of the same structure.
            Never take the delta of this timestamp with the timestamp from a different structure.
    - type: uint64_t
      name: "rxCounter"
      desc: "[out] Monotonic counter for the number of bytes received"
    - type: uint64_t
      name: "txCounter"
      desc: "[out] Monotonic counter for the number of bytes transmitted"
    - type: uint32_t
      name: "rxMaxBandwidth"
      desc: "[out] The current maximum bandwidth in bytes/sec for receiving packats"
    - type: uint32_t
      name: "txMaxBandwidth"
      desc: "[out] The current maximum bandwidth in bytes/sec for transmitting packets"
--- #--------------------------------------------------------------------------
type: struct
desc: "Connectivity port stats counters"
class: $tSysmanLinkPort
name: $t_link_port_stats_t
details:
    - "Percent replays is calculated by taking two snapshots (s1, s2) and using the equation: %replay = 10^6 * (s2.replayCounter - s1.replayCounter) / (s2.maxBandwidth * (s2.timestamp - s1.timestamp))"
members:
    - type: uint64_t
      name: "timestamp"
      desc: |
            [out] Monotonic timestamp counter in microseconds when the measurement was made.
            No assumption should be made about the absolute value of the timestamp.
            It should only be used to calculate delta time between two snapshots of the same structure.
            Never take the delta of this timestamp with the timestamp from a different structure.
    - type: uint64_t
      name: "replayCounter"
      desc: "[out] Monotonic counter for the number of replay packets"
    - type: uint64_t
      name: "packetCounter"
      desc: "[out] Monotonic counter for the number of packets"
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of connectivity ports in a switch"
class: $tSysmanLinkSwitch
name: GetPorts
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_link_switch_handle_t
      name: hSysmanLinkSwitch
      desc: "[in] SMI handle of the connectivity switch."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_link_port_handle_t*"
      name: phPort
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get connectivity port properties"
class: $tSysmanLinkPort
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_link_port_handle_t
      name: hPort
      desc: "[in] Handle for the component."
    - type: $t_link_port_properties_t*
      name: pProperties
      desc: "[in] Will contain properties of the Switch Port"
--- #--------------------------------------------------------------------------
type: function
desc: "Get connectivity port state"
class: $tSysmanLinkPort
name: GetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_link_port_handle_t
      name: hPort
      desc: "[in] Handle for the component."
    - type: $t_link_port_state_t*
      name: pState
      desc: "[in] Will contain the current state of the Switch Port"
--- #--------------------------------------------------------------------------
type: function
desc: "Get connectivity port throughput"
class: $tSysmanLinkPort
name: GetThroughput
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_link_port_handle_t
      name: hPort
      desc: "[in] Handle for the component."
    - type: $t_link_port_throughput_t*
      name: pThroughput
      desc: "[in] Will contain the Switch port throughput counters."
--- #--------------------------------------------------------------------------
type: function
desc: "Get connectivity port stats"
class: $tSysmanLinkPort
name: GetStats
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_link_port_handle_t
      name: hPort
      desc: "[in] Handle for the component."
    - type: $t_link_port_stats_t*
      name: pStats
      desc: "[in] Will contain the Switch port stats."
--- #--------------------------------------------------------------------------
type: function
desc: "Check if two connectivity ports are physically connected"
class: $tSysmanLinkPort
name: IsConnected
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_link_port_handle_t
      name: hPort
      desc: "[in] Handle of the local connectivity port."
    - type: $t_sysman_link_port_handle_t
      name: hRemotePort
      desc: "[in] Handle of the remote connectivity port."
    - type: $x_bool_t*
      name: pConnected
      desc: "[in] Will indicate connected to the remote port."

--- #--------------------------------------------------------------------------
type: enum
desc: "Temperature sensors"
class: $tSysmanTemperature
name: $t_temp_sensors_t
etors:
    - name: $T_TEMP_SENSORS_GLOBAL
      value: "0"
      desc: "The maximum temperature across all device sensors"
    - name: $T_TEMP_SENSORS_GPU
      desc: "The maximum temperature across all sensors in the GPU"
    - name: $T_TEMP_SENSORS_MEMORY
      desc: "The maximum temperature across all sensors in the local memory"
--- #--------------------------------------------------------------------------
type: struct
desc: "Temperature sensor properties"
class: $tSysmanTemperature
name: $t_temp_properties_t
members:
    - type: $t_temp_sensors_t
      name: "type"
      desc: "[out] Which part of the device the temperature sensor measures"
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling SMI handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of temperature sensors"
class: $tSysman
name: TemperatureGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_temp_handle_t*"
      name: phTemperature
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get temperature sensor properties"
class: $tSysmanTemperature
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_temp_handle_t
      name: hTemperature
      desc: "[in] Handle for the component."
    - type: $t_temp_properties_t*
      name: pProperties
      desc: "[in] Will contain the temperature sensor properties."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the temperature from a specified sensor"
class: $tSysmanTemperature
name: Read
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_temp_handle_t
      name: hTemperature
      desc: "[in] Handle for the component."
    - type: uint32_t*
      name: pTemperature
      desc: "[in] Will contain the temperature read from the specified sensor."

--- #--------------------------------------------------------------------------
type: enum
desc: "PSU voltage status"
class: $tSysmanPsu
name: $t_psu_voltage_status_t
etors:
    - name: $T_PSU_VOLTAGE_STATUS_NORMAL
      value: "0"
      desc: "No unusual voltages have been detected"
    - name: $T_PSU_VOLTAGE_STATUS_OVER
      desc: "Over-voltage has occurred"
    - name: $T_PSU_VOLTAGE_STATUS_UNDER
      desc: "Under-voltage has occurred"
--- #--------------------------------------------------------------------------
type: struct
desc: "Static properties of the power supply"
class: $tSysmanPsu
name: $t_psu_properties_t
members:
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling SMI handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $x_bool_t
      name: "canControl"
      desc: "[out] Indicates if software can control the PSU"
    - type: $x_bool_t
      name: "haveFan"
      desc: "[out] True if the power supply has a fan"
    - type: uint32_t
      name: "ampLimit"
      desc: "[out] The maximum electrical current in amperes that can be drawn"
--- #--------------------------------------------------------------------------
type: struct
desc: "Dynamic state of the power supply"
class: $tSysmanPsu
name: $t_psu_state_t
members:
    - type: $t_psu_voltage_status_t
      name: "voltStatus"
      desc: "[out] The current PSU voltage status"
    - type: $x_bool_t
      name: "fanFailed"
      desc: "[out] Indicates if the fan has failed"
    - type: uint32_t
      name: "temperature"
      desc: "[out] Read the current heatsink temperature in degrees celcius"
    - type: uint32_t
      name: "current"
      desc: "[out] The amps being drawn in amperes"
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of power supplies"
class: $tSysman
name: PsuGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_psu_handle_t*"
      name: phPsu
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get power supply properties"
class: $tSysmanPsu
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_psu_handle_t
      name: hPsu
      desc: "[in] Handle for the component."
    - type: $t_psu_properties_t*
      name: pProperties
      desc: "[in] Will contain the properties of the power supply."
--- #--------------------------------------------------------------------------
type: function
desc: "Get current power supply state"
class: $tSysmanPsu
name: GetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_psu_handle_t
      name: hPsu
      desc: "[in] Handle for the component."
    - type: $t_psu_state_t*
      name: pState
      desc: "[in] Will contain the current state of the power supply."

--- #--------------------------------------------------------------------------
type: enum
desc: "Fan resource speed mode"
class: $tSysmanFan
name: $t_fan_speed_mode_t
etors:
    - name: $T_FAN_SPEED_MODE_DEFAULT
      value: "0"
      desc: "The fan speed is operating using the hardware default settings"
    - name: $T_FAN_SPEED_MODE_FIXED
      desc: "The fan speed is currently set to a fixed value"
    - name: $T_FAN_SPEED_MODE_TABLE
      desc: "The fan speed is currently controlled dynamically by hardware based on a temp/speed table"
--- #--------------------------------------------------------------------------
type: enum
desc: "Fan speed units"
class: $tSysmanFan
name: $t_fan_speed_units_t
etors:
    - name: $T_FAN_SPEED_UNITS_RPM
      value: "0"
      desc: "The fan speed is in units of revolutions per minute (rpm)"
    - name: $T_FAN_SPEED_UNITS_PERCENT
      desc: "The fan speed is a percentage of the maximum speed of the fan"
--- #--------------------------------------------------------------------------
type: struct
desc: "Fan temperature/speed pair"
class: $tSysmanFan
name: $t_fan_temp_speed_t
members:
    - type: uint32_t
      name: "temperature"
      desc: "[in,out] Temperature in degrees celcius"
    - type: uint32_t
      name: "speed"
      desc: "[in,out] The speed of the fan"
    - type: $t_fan_speed_units_t
      name: "units"
      desc: "[in,out] The units of the member speed"
--- #--------------------------------------------------------------------------
type: macro
desc: "Maximum number of fan temperature/speed pairs in the fan speed table."
name: $T_FAN_TEMP_SPEED_PAIR_COUNT
value: "32"
--- #--------------------------------------------------------------------------
type: struct
desc: "Fan properties"
class: $tSysmanFan
name: $t_fan_properties_t
members:
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling SMI handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $x_bool_t
      name: "canControl"
      desc: "[out] Indicates if software can control the fan speed"
    - type: uint32_t
      name: "maxSpeed"
      desc: "[out] The maximum RPM of the fan"
    - type: uint32_t
      name: "maxPoints"
      desc: "[out] The maximum number of points in the fan temp/speed table"
--- #--------------------------------------------------------------------------
type: struct
desc: "Fan configuration"
class: $tSysmanFan
name: $t_fan_config_t
members:
    - type: $t_fan_speed_mode_t
      name: "mode"
      desc: "[in,out] The fan speed mode (fixed, temp-speed table)"
    - type: uint32_t
      name: "speed"
      desc: "[in,out] The fixed fan speed setting"
    - type: $t_fan_speed_units_t
      name: "speedUnits"
      desc: "[in,out] The units of the fixed fan speed setting"
    - type: uint32_t
      name: "numPoints"
      desc: "[in,out] The number of valid points in the fan speed table"
    - type: $t_fan_temp_speed_t
      name: "table[$T_FAN_TEMP_SPEED_PAIR_COUNT]"
      desc: "[in,out] Array of temperature/fan speed pairs"
--- #--------------------------------------------------------------------------
type: struct
desc: "Fan state"
class: $tSysmanFan
name: $t_fan_state_t
members:
    - type: $t_fan_speed_mode_t
      name: "mode"
      desc: "[out] The fan speed mode (default, fixed, temp-speed table)"
    - type: $t_fan_speed_units_t
      name: "speedUnits"
      desc: "[out] The units of the fan speed"
    - type: uint32_t
      name: "speed"
      desc: "[out] The current fan speed"
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of fans"
class: $tSysman
name: FanGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_fan_handle_t*"
      name: phFan
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get fan properties"
class: $tSysmanFan
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_fan_handle_t
      name: hFan
      desc: "[in] Handle for the component."
    - type: $t_fan_properties_t*
      name: pProperties
      desc: "[in] Will contain the properties of the fan."
--- #--------------------------------------------------------------------------
type: function
desc: "Get current fan configuration"
class: $tSysmanFan
name: GetConfig
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_fan_handle_t
      name: hFan
      desc: "[in] Handle for the component."
    - type: $t_fan_config_t*
      name: pConfig
      desc: "[in] Will contain the current configuration of the fan."
--- #--------------------------------------------------------------------------
type: function
desc: "Set fan configuration"
class: $tSysmanFan
name: SetConfig
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_fan_handle_t
      name: hFan
      desc: "[in] Handle for the component."
    - type: const $t_fan_config_t*
      name: pConfig
      desc: "[in] New fan configuration."
--- #--------------------------------------------------------------------------
type: function
desc: "Get current state of a fan - current mode and speed"
class: $tSysmanFan
name: GetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_fan_handle_t
      name: hFan
      desc: "[in] Handle for the component."
    - type: $t_fan_speed_units_t
      name: units
      desc: "[in] The units in which the fan speed should be returned."
    - type: $t_fan_state_t*
      name: pState
      desc: "[in] Will contain the current state of the fan."

--- #--------------------------------------------------------------------------
type: struct
desc: "LED properties"
class: $tSysmanLed
name: $t_led_properties_t
members:
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling SMI handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $x_bool_t
      name: "canControl"
      desc: "[out] Indicates if software can control the LED"
    - type: $x_bool_t
      name: "haveRGB"
      desc: "[out] Indicates if the LED is RGB capable"
--- #--------------------------------------------------------------------------
type: struct
desc: "LED state"
class: $tSysmanLed
name: $t_led_state_t
members:
    - type: $x_bool_t
      name: isOn
      desc: "[in,out] Indicates if the LED is on or off"
    - type: uint8_t
      name: "red"
      desc: "[in,out][range(0, 255)] The LED red value"
    - type: uint8_t
      name: "green"
      desc: "[in,out][range(0, 255)] The LED green value"
    - type: uint8_t
      name: "blue"
      desc: "[in,out][range(0, 255)] The LED blue value"
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of LEDs"
class: $tSysman
name: LedGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_led_handle_t*"
      name: phLed
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get LED properties"
class: $tSysmanLed
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_led_handle_t
      name: hLed
      desc: "[in] Handle for the component."
    - type: $t_led_properties_t*
      name: pProperties
      desc: "[in] Will contain the properties of the LED."
--- #--------------------------------------------------------------------------
type: function
desc: "Get current state of a LED - on/off, color"
class: $tSysmanLed
name: GetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_led_handle_t
      name: hLed
      desc: "[in] Handle for the component."
    - type: $t_led_state_t*
      name: pState
      desc: "[in] Will contain the current state of the LED."
--- #--------------------------------------------------------------------------
type: function
desc: "Set state of a LED - on/off, color"
class: $tSysmanLed
name: SetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_led_handle_t
      name: hLed
      desc: "[in] Handle for the component."
    - type: const $t_led_state_t*
      name: pState
      desc: "[in] New state of the LED."

--- #--------------------------------------------------------------------------
type: enum
desc: "RAS error type"
class: $tSysmanRas
name: $t_ras_error_type_t
etors:
    - name: $T_RAS_ERROR_TYPE_CORRECTABLE
      value: "0"
      desc: "Errors were corrected by hardware"
    - name: $T_RAS_ERROR_TYPE_UNCORRECTABLE
      desc: "Error were not corrected"
--- #--------------------------------------------------------------------------
type: struct
desc: "RAS properties"
class: $tSysmanRas
name: $t_ras_properties_t
members:
    - type: $t_ras_error_type_t
      name: "type"
      desc: "[out] The type of RAS error"
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling SMI handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $x_bool_t
      name: "supported"
      desc: "[out] True if RAS is supported on this device"
    - type: $x_bool_t
      name: "enabled"
      desc: "[out] True if RAS is enabled on this device"
--- #--------------------------------------------------------------------------
type: struct
desc: "RAS error details"
class: $tSysmanRas
name: $t_ras_details_t
members:
    - type: uint64_t
      name: "numResets"
      desc: "[out] The number of device resets that have taken place"
    - type: uint64_t
      name: "numProgrammingErrors"
      desc: "[out] The number of hardware exceptions generated by the way workloads have programmed the hardware"
    - type: uint64_t
      name: "numDriverErrors"
      desc: "[out] The number of low level driver communication errors have occurred"
    - type: uint64_t
      name: "numComputeErrors"
      desc: "[out] The number of errors that have occurred in the compute accelerator hardware"
    - type: uint64_t
      name: "numNonComputeErrors"
      desc: "[out] The number of errors that have occurred in the fixed-function accelerator hardware"
    - type: uint64_t
      name: "numCacheErrors"
      desc: "[out] The number of errors that have occurred in caches (L1/L3/register file/shared local memory/sampler)"
    - type: uint64_t
      name: "numMemoryErrors"
      desc: "[out] The number of errors that have occurred in the local memory"
    - type: uint64_t
      name: "numPciErrors"
      desc: "[out] The number of errors that have occurred in the PCI link"
    - type: uint64_t
      name: "numSwitchErrors"
      desc: "[out] The number of errors that have occurred in the high-speed connectivity links"
    - type: uint64_t
      name: "numDisplayErrors"
      desc: "[out] The number of errors that have occurred in the display"
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of RAS error sets"
class: $tSysman
name: RasGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_ras_handle_t*"
      name: phRas
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get RAS properties of the device"
class: $tSysmanRas
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_ras_handle_t
      name: hRas
      desc: "[in] Handle for the component."
    - type: $t_ras_properties_t*
      name: pProperties
      desc: "[in] Structure describing RAS properties"
--- #--------------------------------------------------------------------------
type: function
desc: "Get the number of errors of a given RAS error set"
class: $tSysmanRas
name: GetErrors
details:
    - "Clearing errors will affect other threads/applications - the counter values will start from zero."
    - "Clearing errors requires write permissions."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_ras_handle_t
      name: hRas
      desc: "[in] Handle for the component."
    - type: $x_bool_t
      name: clear
      desc: "[in] Set to 1 to clear the counters of this type"
    - type: uint64_t*
      name: pTotalErrors
      desc: "[in] The number total number of errors that have occurred"
    - type: $t_ras_details_t*
      name: pDetails
      desc: "[in][optional] Breakdown of where errors have occurred"
returns:
    - $X_RESULT_ERROR_UNSUPPORTED:
        - "This device does not support RAS."
    - $X_RESULT_ERROR_INSUFFICENT_PERMISSIONS:
        - "Don't have permissions to clear error counters."

--- #--------------------------------------------------------------------------
type: enum
desc: "Event types"
class: $tSysman
name: $t_sysman_event_type_t
etors:
    - name: $T_SYSMAN_EVENT_TYPE_FREQ_THROTTLED
      value: "0"
      desc: "The frequency is being throttled"
    - name: $T_SYSMAN_EVENT_TYPE_ENERGY_THRESHOLD_CROSSED
      desc: "Interrupt from the PCU when the energy threshold is crossed."
    - name: $T_SYSMAN_EVENT_TYPE_RAS_ERRORS
      desc: "ECC/RAS errors"
    - name: $T_SYSMAN_EVENT_TYPE_NUM
      desc: "The number of event types"
--- #--------------------------------------------------------------------------
type: struct
desc: "Event properties"
class: $tSysman
name: $t_event_properties_t
members:
    - type: $x_bool_t
      name: "supportedEvents[$T_SYSMAN_EVENT_TYPE_NUM]"
      desc: "[out] Set to true for the events that are supported"
--- #--------------------------------------------------------------------------
type: struct
desc: "Request structure used to register/unregister events"
class: $tSysman
name: $t_event_request_t
members:
    - type: $t_sysman_event_type_t
      name: "event"
      desc: "[in] The event type to register."
    - type: uint32_t
      name: "threshold"
      desc: "[in] The application only receives a notification when the total count exceeds this value. Set to zero to receive a notification for every new event."
--- #--------------------------------------------------------------------------
type: function
desc: "Get event properties"
class: $tSysman
name: EventsGetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Handle of the SMI object"
    - type: $t_event_properties_t*
      name: pProperties
      desc: "[in] Structure describing event properties"
--- #--------------------------------------------------------------------------
type: function
desc: "Register to receive events"
class: $tSysman
name: EventsRegister
details:
    - "This will only register the specified list of events. If other events have been registered, notifications for them will continue."
    - "Set count to zero to receive notifications for all events."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle for the device"
    - type: uint32_t
      name: count
      desc: "[in] Number of entries in the array pEvents. If zero, all events will be registered."
    - type: $t_event_request_t*
      name: pEvents
      desc: "[in][optional] Events to register."
--- #--------------------------------------------------------------------------
type: function
desc: "Unregister events"
class: $tSysman
name: EventsUnregister
details:
    - "This will only unregister the specified list of events. If other events have been registered, notifications for them will continue."
    - "Set count to zero to no longer receive any notifications."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Handle of the SMI object"
    - type: uint32_t
      name: count
      desc: "[in] Number of entries in the array pEvents. If zero, all events will be unregistered."
    - type: $t_event_request_t*
      name: pEvents
      desc: "[in][optional] Events to unregister."
--- #--------------------------------------------------------------------------
type: macro
desc: "Wait infinitely for events to arrive."
name: $T_EVENT_WAIT_INFINITE
value: "0xFFFFFFFF"
--- #--------------------------------------------------------------------------
type: function
desc: "Get events that have been triggered for a specific device or from all registered devices"
class: $tSysman
decl: static
name: EventsListen
details:
    - "If events have occurred, they are returned and the corresponding event status is cleared if the argument clear = true."
    - "If listening to events from multiple devices, it is recommended to call this function with hSysman = nullptr, clear = false and timeout = $T_EVENT_WAIT_INFINITE. Then call this function for each device with clear = true and timeout = 0."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle for a device. Set to nullptr to get events from any device for which the application has registered to receive notifications."
    - type: $x_bool_t
      name: clear
      desc: "[in] Clear the event status."
    - type: uint32_t
      name: timeout
      desc: "[in] How long to wait in milliseconds for events to arrive. Zero will check status and return immediately. Set to $T_EVENT_WAIT_INFINITE to block until events arrive."
    - type: "uint32_t*"
      name: pEvents
      desc: "[in] Bitfield of events (1<<$t_sysman_event_type_t) that have been triggered."

--- #--------------------------------------------------------------------------
type: enum
desc: "Diagnostic test suite type"
class: $tSysmanDiagnostics
name: $t_diag_type_t
etors:
    - name: $T_DIAG_TYPE_SCAN
      value: "0"
      desc: "Run SCAN diagnostics"
    - name: $T_DIAG_TYPE_ARRAY
      desc: "Run Array diagnostics"
--- #--------------------------------------------------------------------------
type: enum
desc: "Diagnostic results"
class: $tSysmanDiagnostics
name: $t_diag_result_t
etors:
    - name: $T_DIAG_RESULT_NO_ERRORS
      value: "0"
      desc: "Diagnostic completed without finding errors to repair"
    - name: $T_DIAG_RESULT_ABORT
      desc: "Diagnostic had problems running tests"
    - name: $T_DIAG_RESULT_FAIL_CANT_REPAIR
      desc: "Diagnostic had problems setting up repairs"
    - name: $T_DIAG_RESULT_REBOOT_FOR_REPAIR
      desc: "Diagnostics found errors, setup for repair and reboot is required to complete the process"
--- #--------------------------------------------------------------------------
type: macro
desc: "Diagnostic test index to use for the very first test."
name: $T_DIAG_FIRST_TEST_INDEX
value: "0x0"
--- #--------------------------------------------------------------------------
type: macro
desc: "Diagnostic test index to use for the very last test."
name: $T_DIAG_LAST_TEST_INDEX
value: "0xFFFFFFFF"
--- #--------------------------------------------------------------------------
type: struct
desc: "Diagnostic test"
class: $tSysmanDiagnostics
name: $t_diag_test_t
members:
    - type: uint32_t
      name: "index"
      desc: "[out] Index of the test"
    - type: const char*
      name: "name"
      desc: "[out] Name of the test"
--- #--------------------------------------------------------------------------
type: struct
desc: "Diagnostics test suite properties"
class: $tSysmanDiagnostics
name: $t_diag_properties_t
members:
    - type: $t_diag_type_t
      name: "type"
      desc: "[out] The type of diagnostics test suite"
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling SMI handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: const char*
      name: "name"
      desc: "[out] Name of the diagnostics test suite"
    - type: uint32_t
      name: "numTests"
      desc: "[out] The number of tests in the test suite"
    - type: const $t_diag_test_t*
      name: "pTests"
      desc: "[out] Array of tests (size $t_diag_properties_t.numTests), sorted by increasing value of $t_diag_test_t.index"
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of diagnostics test suites"
class: $tSysman
name: DiagnosticsGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_diag_handle_t*"
      name: phDiagnostics
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get properties of a diagnostics test suite"
class: $tSysmanDiagnostics
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_diag_handle_t
      name: hDiagnostics
      desc: "[in] Handle for the component."
    - type: $t_diag_properties_t*
      name: pProperties
      desc: "[in] Structure describing the properties of a diagnostics test suite"
--- #--------------------------------------------------------------------------
type: function
desc: "Run a diagnostics test suite, either all tests or a subset of tests."
class: $tSysmanDiagnostics
name: RunTests
details:
    - "This function will block until the diagnostics have completed."
params:
    - type: $t_sysman_diag_handle_t
      name: hDiagnostics
      desc: "[in] Handle for the component."
    - type: uint32_t
      name: start
      desc: "[in] The index of the first test to run. Set to $T_DIAG_FIRST_TEST_INDEX to start from the beginning."
    - type: uint32_t
      name: end
      desc: "[in] The index of the last test to run. Set to $T_DIAG_LAST_TEST_INDEX to complete all tests after the start test."
    - type: $t_diag_result_t*
      name: pResult
      desc: "[in] The result of the diagnostics"

--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a SMI device"
name: $tSysman
owner: $tDevice
members:
    - type: $t_sysman_handle_t
      name: handle
      desc: "[in] handle of SMI object" 
      init: nullptr
    - type: $tDevice*
      name: pDevice
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a SMI device power domain"
name: $tSysmanPower
owner: $tSysman
members:
    - type: $t_sysman_pwr_handle_t
      name: handle
      desc: "[in] handle of SMI object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a SMI device frequency domain"
name: $tSysmanFrequency
owner: $tSysman
members:
    - type: $t_sysman_freq_handle_t
      name: handle
      desc: "[in] handle of SMI object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a SMI device engine group"
name: $tSysmanEngine
owner: $tSysman
members:
    - type: $t_sysman_engine_handle_t
      name: handle
      desc: "[in] handle of SMI object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a SMI standby control"
name: $tSysmanStandby
owner: $tSysman
members:
    - type: $t_sysman_standby_handle_t
      name: handle
      desc: "[in] handle of SMI object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a SMI device firmware"
name: $tSysmanFirmware
owner: $tSysman
members:
    - type: $t_sysman_firmware_handle_t
      name: handle
      desc: "[in] handle of SMI object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a SMI device memory module"
name: $tSysmanMemory
owner: $tSysman
members:
    - type: $t_sysman_mem_handle_t
      name: handle
      desc: "[in] handle of SMI object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a SMI device connectivity switch"
name: $tSysmanLinkSwitch
owner: $tSysman
members:
    - type: $t_sysman_link_switch_handle_t
      name: handle
      desc: "[in] handle of SMI object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a SMI device connectivity port"
name: $tSysmanLinkPort
owner: $tSysmanLinkSwitch
members:
    - type: $t_sysman_link_port_handle_t
      name: handle
      desc: "[in] handle of SMI object" 
      init: nullptr
    - type: $tSysmanLinkSwitch*
      name: pSysmanLinkSwitch
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a SMI device temperature sensor"
name: $tSysmanTemperature
owner: $tSysman
members:
    - type: $t_sysman_temp_handle_t
      name: handle
      desc: "[in] handle of SMI object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a SMI device power supply"
name: $tSysmanPsu
owner: $tSysman
members:
    - type: $t_sysman_psu_handle_t
      name: handle
      desc: "[in] handle of SMI object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a SMI device fan"
name: $tSysmanFan
owner: $tSysman
members:
    - type: $t_sysman_fan_handle_t
      name: handle
      desc: "[in] handle of SMI object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a SMI device LED"
name: $tSysmanLed
owner: $tSysman
members:
    - type: $t_sysman_led_handle_t
      name: handle
      desc: "[in] handle of SMI object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a SMI device RAS error set"
name: $tSysmanRas
owner: $tSysman
members:
    - type: $t_sysman_ras_handle_t
      name: handle
      desc: "[in] handle of SMI object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a SMI device diagnostic test suite"
name: $tSysmanDiagnostics
owner: $tSysman
members:
    - type: $t_sysman_diag_handle_t
      name: handle
      desc: "[in] handle of SMI object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
