--- #--------------------------------------------------------------------------
type: header
desc: "Intel $OneApi Level-Zero Tool APIs for System Resource Management (SMI)"
--- #--------------------------------------------------------------------------
type: enum
desc: "API version of SMI"
class: $tSysman
name: $t_sysman_version_t
etors:
    - name: $T_SYSMAN_VERSION_CURRENT
      value: "$X_MAKE_VERSION( 1, 0 )"
      desc: "version 1.0"
--- #--------------------------------------------------------------------------
type: enum
desc: "SMI initialization flags (bitfield)"
class: $tSysman
name: $t_sysman_init_flags_t
etors:
    - name: $T_SYSMAN_INIT_FLAGS_NONE
      value: "0"
      desc: "Default initialization"
    - name: $T_SYSMAN_INIT_FLAGS_WRITE
      value: "$X_BIT( 0 )"
      desc: "Request write/control access to resources"
--- #--------------------------------------------------------------------------
type: function
desc: "Creates a handle to access SMI features"
class: $tSysman
name: Create
decl: static
analogue:
    - "**nvmlInit**"
    - "**rsmi_init**"
details:
    - "Initializes internal structures to support SMI features."
    - "If the write flag $T_SYSMAN_INIT_FLAGS_WRITE is specified, no access right checks are made during initialization. The check is done in functions that attempt to control a device."
    - "If the write flag $T_SYSMAN_INIT_FLAGS_WRITE is not specified, any function attempting to control a device will return $X_RESULT_ACCESS_DENIED."
    - "Multiple SMI handles can be created for the same device group and concurrent access through each handle to access underlying hardware resources is supported."
params:
    - type: "$t_device_group_handle_t"
      name: hDeviceGroup
      desc: "[in] Handle of the device group"
    - type: "$t_sysman_version_t"
      name: version
      desc: "[in] SMI version that application was built with"
    - type: "uint32_t"
      name: flags
      desc: "[in] Bitfield of $t_sysman_init_flags_t"
    - type: "$t_sysman_handle_t*"
      name: phSysman
      desc: "[out] Handle for accessing SMI features"
--- #--------------------------------------------------------------------------
type: function
desc: "Destroys a Sysman handle"
class: $tSysman
name: Destroy
decl: static
analogue:
    - "**nvmlShutdown**"
    - "**rsmi_shut_down**"
details:
    - "Only once all SMI handles to a device group have been destroyed will internal data structures be freed from the application memory."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in][release] SMI handle to destroy"
--- #--------------------------------------------------------------------------
type: enum
desc: "Resource types"
class: $tSysman
name: $t_resource_type_t
etors:
    - name: $T_RESOURCE_TYPE_UNIT_CONTAINER
      value: "0"
      desc: "Unit resource container"
    - name: $T_RESOURCE_TYPE_BOARD_CONTAINER
      desc: "Board resource container"
    - name: $T_RESOURCE_TYPE_DEVICE_CONTAINER
      desc: "Device resource container"
    - name: $T_RESOURCE_TYPE_SUBDEVICE_CONTAINER
      desc: "Sub-device resource container"
    - name: $T_RESOURCE_TYPE_PSU
      desc: "PSU resource"
    - name: $T_RESOURCE_TYPE_TEMP
      desc: "Temperature sensor resource"
    - name: $T_RESOURCE_TYPE_FAN
      desc: "Fan resource"
    - name: $T_RESOURCE_TYPE_LED
      desc: "LED resource"
    - name: $T_RESOURCE_TYPE_FIRMWARE
      desc: "Firmware resource"
    - name: $T_RESOURCE_TYPE_PWR
      desc: "Power domain resource"
    - name: $T_RESOURCE_TYPE_FREQ
      desc: "Frequency domain resource"
    - name: $T_RESOURCE_TYPE_PWRWELL
      desc: "Power-well resource"
    - name: $T_RESOURCE_TYPE_ACCEL
      desc: "Accelerator asset resource"
    - name: $T_RESOURCE_TYPE_MEM
      desc: "Memory resource"
    - name: $T_RESOURCE_TYPE_LINK
      desc: "Link resource"
    - name: $T_RESOURCE_TYPE_MAX_TYPES
      desc: "The number of resource types"
--- #--------------------------------------------------------------------------
type: enum
desc: "Accelerator assets"
class: $tSysman
name: $t_accel_asset_t
etors:
    - name: $T_ACCEL_ASSET_PCIE_CONTROLLER
      value: "0"
      desc: "PCIe controller"
    - name: $T_ACCEL_ASSET_IDI_MEM_CONTROLLER
      desc: "IDI memory controller"
    - name: $T_ACCEL_ASSET_HBM_MEM_CONTROLLER
      desc: "HBM memory controller"
    - name: $T_ACCEL_ASSET_L3_CACHE
      desc: "L3 cache"
    - name: $T_ACCEL_ASSET_BLILTTER
      desc: "Blitter"
    - name: $T_ACCEL_ASSET_VIDEO_DECODER
      desc: "Video decoder"
    - name: $T_ACCEL_ASSET_VIDEO_ENCODER
      desc: "Video encoder"
    - name: $T_ACCEL_ASSET_VIDEO_PROCESSING
      desc: "Video processing"
    - name: $T_ACCEL_ASSET_3D_FF
      desc: "3D fixed-function hardware"
    - name: $T_ACCEL_ASSET_3D_RENDER
      desc: "3D programmable shader units"
    - name: $T_ACCEL_ASSET_COMPUTE
      desc: "Compute units"
    - name: $T_ACCEL_ASSET_SYSTOLIC
      desc: "Systolic array"
    - name: $T_ACCEL_ASSET_RAYTRACING
      desc: "Raytracing hardware"
    - name: $T_ACCEL_ASSET_LOCAL_MEM
      desc: "Local memory"
    - name: $T_ACCEL_ASSET_LINK
      desc: "High speed link"
    - name: $T_ACCEL_ASSET_MAX_TYPES
      desc: "The number of accelerator asset types"
--- #--------------------------------------------------------------------------
type: function
desc: "Get human-readable name for an accelerator asset"
class: $tSysman
name: GetAccelAssetName
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] SMI handle"
    - type: $t_accel_asset_t
      name: type
      desc: "[in] The type of accelerator asset"
    - type: "const char**"
      name: ppName
      desc: "[in] Pointer to the asset name"
--- #--------------------------------------------------------------------------
type: macro
desc: "Size of UUID in bytes"
name: $T_RESOURCE_UUID_SIZE
value: "16"
--- #--------------------------------------------------------------------------
type: macro
desc: "Maximum number of characters in string representation of a UUID"
details:
    - "Size does not including end-of-string terminator"
    - "Format of UUID string: ffffffff-ffff-ffff-ffff-ffffffffffff"
name: $T_RESOURCE_UUID_STRING_SIZE
value: "36"
--- #--------------------------------------------------------------------------
type: struct
desc: "Universal unique id (UUID) for Sysman resources"
class: $tSysman
name: $t_resource_uuid_t
members:
    - type: uint8_t
      name: "id[$T_RESOURCE_UUID_SIZE]"
      desc: "[in,out] Universal unique id of Sysman object"
--- #--------------------------------------------------------------------------
type: function
desc: "Convert SMI resource UUID to a string"
class: $tSysman
name: ConvertUuidToString
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Handle of the SMI object"
    - type: const $t_resource_uuid_t*
      name: pUuid
      desc: "[in] Pointer to a Sysman UUID"
    - type: "uint32_t*"
      name: pSize
      desc: |
            [in,out] Pointer to the size of the string buffer pointed to by pStr.
            If size is zero, the storage size including end-of-string terminator will be returned.
            If size is non-zero and less than the required length, the storage size including end-of-string terminator will be returned and an error status given.
            If size is non-zero and larger than the required length, the number of characters stored in the buffer including the end-of-string terminator will be returned.
    - type: "char*"
      name: pStr
      desc: "[in][optional] Pointer to storage for the string representation of the UUID"
--- #--------------------------------------------------------------------------
type: enum
desc: "RAS error type"
class: $tSysman
name: $t_ras_error_type_t
etors:
    - name: $T_RAS_ERROR_TYPE_NONE
      value: "0"
      desc: "No error type"
    - name: $T_RAS_ERROR_TYPE_FATAL
      value: "$X_BIT( 0 )"
      desc: "Error was fatal"
    - name: $T_RAS_ERROR_TYPE_NON_FATAL
      value: "$X_BIT( 1 )"
      desc: "Error was not fatal"
    - name: $T_RAS_ERROR_TYPE_CORRECTABLE
      value: "$X_BIT( 2 )"
      desc: "Error was corrected"
    - name: $T_RAS_ERROR_TYPE_UNCORRECTABLE
      value: "$X_BIT( 3 )"
      desc: "Error was not corrected"
    - name: $T_RAS_ERROR_TYPE_PARITY
      value: "$X_BIT( 4 )"
      desc: "Parity error occurred"
    - name: $T_RAS_ERROR_TYPE_SINGLE_BIT
      value: "$X_BIT( 5 )"
      desc: "Single bit error occurred"
    - name: $T_RAS_ERROR_TYPE_DOUBLE_BIT
      value: "$X_BIT( 6 )"
      desc: "Single bit error occurred"
    - name: $T_RAS_ERROR_TYPE_REPLAY
      value: "$X_BIT( 7 )"
      desc: "Replay occurred"
    - name: $T_RAS_ERROR_TYPE_ALL
      value: "~0"
      desc: "Select all error types"
--- #--------------------------------------------------------------------------
type: enum
desc: "RAS error structural location"
class: $tSysman
name: $t_ras_error_loc_t
etors:
    - name: $T_RAS_ERROR_LOC_NONE
      value: "0"
      desc: "No location"
    - name: $T_RAS_ERROR_LOC_MAIN_MEM
      value: "$X_BIT( 0 )"
      desc: "Error occurred in main onboard memory"
    - name: $T_RAS_ERROR_LOC_L3_CACHE
      value: "$X_BIT( 1 )"
      desc: "Error occurred in L3 cache"
    - name: $T_RAS_ERROR_LOC_SAMPLER_SRAM
      value: "$X_BIT( 2 )"
      desc: "Error occurred in sampler SRAM"
    - name: $T_RAS_ERROR_LOC_GUC_SRAM
      value: "$X_BIT( 3 )"
      desc: "Error occurred in microcontroller SRAM"
    - name: $T_RAS_ERROR_LOC_INST_CACHE
      value: "$X_BIT( 4 )"
      desc: "Error occurred in the compute unit instruction cache"
    - name: $T_RAS_ERROR_LOC_GRF
      value: "$X_BIT( 5 )"
      desc: "Error occurred in the compute unit register file"
    - name: $T_RAS_ERROR_LOC_SLM
      value: "$X_BIT( 6 )"
      desc: "Error occurred in the compute unit shared local memory"
    - name: $T_RAS_ERROR_LOC_PCI
      value: "$X_BIT( 7 )"
      desc: "Error occurred in the PCIe controller"
    - name: $T_RAS_ERROR_LOC_PCI_ROUTING
      value: "$X_BIT( 8 )"
      desc: "Error occurred routing PCIe traffic to/from sub-devices"
    - name: $T_RAS_ERROR_LOC_SGUNIT
      value: "$X_BIT( 9 )"
      desc: "Errors occurred handling transactions between PCI config space, MMIO registers, local memory and sub-devices"
    - name: $T_RAS_ERROR_LOC_GSC
      value: "$X_BIT( 10 )"
      desc: "Security errors occurred"
    - name: $T_RAS_ERROR_LOC_DISPLAY
      value: "$X_BIT( 11 )"
      desc: "Errors occurred in the display"
    - name: $T_RAS_ERROR_LOC_SOC
      value: "$X_BIT( 12 )"
      desc: "Errors occurred in other parts of the device"
    - name: $T_RAS_ERROR_LOC_GPU_HANG
      value: "$X_BIT( 13 )"
      desc: "Driver detected that the GPU hardware was non-responsive"
    - name: $T_RAS_ERROR_LOC_GPU_WARM_RESET
      value: "$X_BIT( 14 )"
      desc: "Driver performed a GPU warm reset"
    - name: $T_RAS_ERROR_LOC_ALL
      value: "~0"
      desc: "Select all error locations"
--- #--------------------------------------------------------------------------
type: enum
desc: "RAS data type"
class: $tSysman
name: $t_ras_data_type_t
etors:
    - name: $T_RAS_DATA_TYPE_NONE
      value: "0"
      desc: "Errors not supported"
    - name: $T_RAS_DATA_TYPE_OCCURRED
      desc: "Indicates if an error occurred"
    - name: $T_RAS_DATA_TYPE_COUNTER
      desc: "Provides a counter for the number of errors that have occurred"
--- #--------------------------------------------------------------------------
type: struct
desc: "RAS error"
class: $tSysman
name: $t_res_error_t
members:
    - type: uint32_t
      name: "type"
      desc: "[out] Bitfield describing type of error, constructed from one or more of $t_ras_error_type_t"
    - type: uint32_t
      name: "loc"
      desc: "[out] Bitfield describing structural location of the error, constructed from one of $t_ras_error_loc_t"
    - type: $t_ras_data_type_t
      name: "dataType"
      desc: "[out] How to interpret the data"
    - type: uint64_t
      name: "data"
      desc: "[out] The value of the error - interpretation depends on dataType"
    - type: $t_resource_uuid_t
      name: "uuid"
      desc: "[out] UUID for the resource where the error was generated"
--- #--------------------------------------------------------------------------
type: struct
desc: "Generic information about a resource"
class: $tSysman
name: $t_resource_info_t
members:
    - type: $t_resource_uuid_t
      name: "uuid"
      desc: "[out] UUID for the resource"
    - type: $t_resource_type_t
      name: "type"
      desc: "[out] Type of resource"
    - type: $x_bool_t
      name: "haveParent"
      desc: "[out] Indicates if this resource has a parent resource"
    - type: uint32_t
      name: "numChildren"
      desc: "[out] The number of child resources"
    - type: uint32_t
      name: "numPeers"
      desc: "[out] The number of resources connected to this resource with peer-to-peer links"
    - type: uint32_t
      name: "numRas"
      desc: "[out] The total number of RAS elements contained in this resource or in any descendants."
    - type: uint32_t
      name: "rasTypes"
      desc: "[out] Bitfield of the type of RAS elements ($t_ras_error_type_t) contained in this resource or in any descendants."
    - type: uint32_t
      name: "rasLocations"
      desc: "[out] Bitfield of the structure location of RAS elements ($t_ras_error_loc_t) contained in this resource or in any descendants."
    - type: uint32_t
      name: "numResourcesByType[$T_RESOURCE_TYPE_MAX_TYPES]"
      desc: "[out] The number of resources of each type attached to this resource (not in the child resources)"
--- #--------------------------------------------------------------------------
type: function
desc: "Retrieves resources of a given type having a specified parent resource"
class: $tSysman
name: GetResources
details:
    - "If a parent resource is not specified, then all resources of the given type are returned. Otherwise only resources directly contained in/under the specified parent are returned."
    - "There is a one-to-many mapping between the underlying hardware for a resource and the corresponding handles returned to the application. Thus, the numerical value of the handles should not be compared with those returned by previous function calls - instead, use the function $tSysmanResourceIsSame() to check if two handles reference the same hardware object."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Handle of the SMI object"
    - type: $t_resource_handle_t
      name: hParentResource
      desc: "[in] Handle of the parent resource object (can be $T_INVALID_SYSMAN_RESOURCE_HANDLE)"
    - type: $t_resource_type_t
      name: type
      desc: "[in] The type of resources to enumerate"
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] Pointer to the number of elements in the array phResources.
            If count is zero, then the driver will update the value with the total number of resources that would be returned.
            If count is non-zero, then driver will only retrieve that number of resources of the given type starting from index 0.
            If count is larger than the number of resource that will be returned, then the driver will update the value with actual number returned.
    - type: "$t_resource_handle_t*"
      name: phResources
      desc: "[out][optional][range(0, *pCount)] Array of resources resources"
--- #--------------------------------------------------------------------------
type: function
desc: "Retrieves a resource handle for a device"
class: $tSysman
name: GetDeviceResource
details:
    - "The specified device must be in the same device group that was used to create the SMI handle."
    - "If the device handle refers to a device, then a resource handle of type $T_RESOURCE_TYPE_DEVICE_CONTAINER will be returned."
    - "If the device handle refers to a sub-device, then a resource handle of type $T_RESOURCE_TYPE_SUBDEVICE_CONTAINER will be returned."
    - "There is a one-to-many mapping between the underlying hardware for a resource and the corresponding handles returned to the application. Thus, the numerical value of the handles should not be compared with those returned by previous function calls - instead, use the function $tSysmanResourceIsSame() to check if two handles reference the same hardware object."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Handle of the SMI object"
    - type: $x_device_handle_t
      name: hDevice
      desc: "[in] Handle to the device."
    - type: "$t_resource_handle_t*"
      name: phResource
      desc: "[out] Resource handle for the specified device"
returns:
    - $X_RESULT_MISMATCH_DEVICE_GROUP:
        - "The device does not belong to the device group that was ued to create the SMI handle"
--- #--------------------------------------------------------------------------
type: function
desc: "Retrieves a resource handle based on resource UUID"
class: $tSysman
name: GetResourceByUuid
details:
    - "There is a one-to-many mapping between the underlying hardware for a resource and the corresponding handles returned to the application. Thus, the numerical value of the handles should not be compared with those returned by previous function calls - instead, use the function $tSysmanResourceIsSame() to check if two handles reference the same hardware object."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Handle of the SMI object"
    - type: const $t_resource_uuid_t*
      name: uuid
      desc: "[in] UUID for the resource"
    - type: "$t_resource_handle_t*"
      name: phResource
      desc: "[out] Resource handle"
returns:
    - $X_RESULT_NOT_FOUND:
        - "No resource could be found with the specified UUID"
--- #--------------------------------------------------------------------------
type: function
desc: "Get RAS errors that have occurred"
class: $tSysman
name: GetRasErrors
details:
    - "Returned errors can be filtered by resource, type, location and threshold."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Handle of the SMI object"
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource. If specified, only errors within that resource of child resources are returned. Otherwise all errors are returned."
    - type: uint32_t
      name: type
      desc: "[in] Bitfield of error types to filter - one or more of $t_ras_error_type_t. Set to $T_RAS_ERROR_TYPE_ALL to have all error types returned."
    - type: uint32_t
      name: location
      desc: "[in] Bitfield of error locations to filter - one or more of $t_ras_error_loc_t. Set to $T_RAS_ERROR_LOC_ALL to have all error locations returned."
    - type: uint32_t
      name: threshold
      desc: |
            [in] Only return error elements that have occurred at least this number of times.
            If set to 0, will get a list of all possible RAS elements, even those that have not had errors.
            For error elements of type $T_RAS_DATA_TYPE_OCCURRED, there is no underlying counter, so they will always be returned independent of the threshold setting.
    - type: $x_bool_t
      name: clear
      desc: "[in] Set to true to clear the underlying counters after they are returned"
    - type: uint32_t*
      name: pCount
      desc: |
            [in] Pointer to the number of elements in the array pErrors.
            If count is 0 or pErrors is nullptr, driver will update with the number of errors matching the specified filters. Counters are not cleared.
            If count is non-zero and less than the number of matching errors, driver will update with the number of errors matching the specified filters. No data is returned and counters are not cleared.
            If count is greater than or equal to the number of matching errors, all data is returned, counters are cleared if requested and count will be set to actual number of errors returned.
    - type: $t_res_error_t*
      name: pErrors
      desc: "[in] Array of error data"
returns:
    - $X_RESULT_TOO_SMALL:
        - "The array doesn't have enough elements to store all the errors"
--- #--------------------------------------------------------------------------
type: function
desc: "Compare if two resource handles reference the same underlying hardware object"
class: $tSysmanResource
name: IsSame
details:
    - "There is a one-to-many mapping between the underlying hardware for a resource and the corresponding handles returned to the application. Thus, the numerical value of the handles should not be compared with those returned by previous function calls - instead, use this function to check if two handles reference the same hardware object."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hLhs
      desc: "[in] Handle of of the resources"
    - type: $t_resource_handle_t
      name: hRhs
      desc: "[in] Handle of the other resource"
    - type: $x_bool_t*
      name: pIsSame
      desc: "[in] Sets to True if the two resources reference the same underlying hardware object"
--- #--------------------------------------------------------------------------
type: function
desc: "Get generic information about a resource"
class: $tSysmanResource
name: GetInfo
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: $t_resource_info_t*
      name: pInfo
      desc: "[out] Generic information about the resource"
--- #--------------------------------------------------------------------------
type: function
desc: "Get a handle to the parent resource"
class: $tSysmanResource
name: GetParent
details:
    - "For resource containers, this will return the handle to parent container. For non-container resources, this will return the handle to the container resource in which the resource is located."
    - "If there is no parent (e.g. resources of type $T_RESOURCE_TYPE_UNIT_CONTAINER), the returned handle will be $T_INVALID_SYSMAN_RESOURCE_HANDLE."
    - "There is a one-to-many mapping between the underlying hardware for a resource and the corresponding handles returned to the application. Thus, the numerical value of the handles should not be compared with those returned by previous function calls - instead, use the function $tSysmanResourceIsSame() to check if two handles reference the same hardware object."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: $t_resource_handle_t*
      name: phResource
      desc: "[out] Handle of the parent resource"
--- #--------------------------------------------------------------------------
type: function
desc: "Get children resources"
class: $tSysmanResource
name: GetChildren
details:
    - "If the parent resource is not a container, no children resources will be returned."
    - "Only resource containers will be returned by this function. The function $tSysmanGetResources should be used to get non-container resources located in a parent resource."
    - "There is a one-to-many mapping between the underlying hardware for a resource and the corresponding handles returned to the application. Thus, the numerical value of the handles should not be compared with those returned by previous function calls - instead, use the function $tSysmanResourceIsSame() to check if two handles reference the same hardware object."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] Pointer to the number of elements in the array phResources.
            If count is zero, then the driver will update the value with the total number of child resources.
            If count is non-zero, then driver will only retrieve that number of child resources starting from index 0.
            If count is larger than the number of child resources that will be returned, then the driver will update the value with the resources actually returned.
    - type: "$t_resource_handle_t*"
      name: phResources
      desc: "[out][optional][range(0, *pCount)] Array of resource handles."
--- #--------------------------------------------------------------------------
type: function
desc: "Get peer resources"
class: $tSysmanResource
name: GetPeers
details:
    - "If the parent resource is not a container, no peer resources will be returned."
    - "Only resource containers will be returned by this function. The function $tSysmanGetResources should be used to get non-container resources located in a parent resource."
    - "There is a one-to-many mapping between the underlying hardware for a resource and the corresponding handles returned to the application. Thus, the numerical value of the handles should not be compared with those returned by previous function calls - instead, use the function $tSysmanResourceIsSame() to check if two handles reference the same hardware object."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] Pointer to the number of elements in the array phResources.
            If count is zero, then the driver will update the value with the total number of peer resources.
            If count is non-zero, then driver will only retrieve that number of peer resources starting from index 0.
            If count is larger than the number of peer resources that will be returned, then the driver will update the value with the resources actually returned.
    - type: "$t_resource_handle_t*"
      name: phResources
      desc: "[out][optional][range(0, *pCount)] Array of resource handles."
--- #--------------------------------------------------------------------------
type: macro
desc: "Maximum number of characters in string properties."
name: $T_STRING_PROPERTY_SIZE
value: "32"
--- #--------------------------------------------------------------------------
type: enum
desc: "Board resource properties"
class: $tSysmanResource
name: $t_board_properties_t
details:
    - "For every property, there is a corresponding structure used to hold the property data. The type of the data structure is derived from the property enumerator, converted to lower-case with '_t' appended."
    - "Properties can be either read-only (ro), write-only (wo) or read-write (rw)."
    - "Properties can be either static or dynamic. Static properties are set during initialization and will not change during the lifetime of the application. Dynamic properties can change at any time and should be reread."
etors:
    - name: $T_BOARD_PROP_SERIAL_NUMBER
      value: "0"
      desc: "(ro static) The serial number of a board (data: $t_board_prop_serial_number_t)"
    - name: $T_BOARD_PROP_BOARD_NUMBER
      desc: "(ro static) The board number of a board (data: $t_board_prop_board_number_t)"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for property $T_BOARD_PROP_SERIAL_NUMBER"
class: $tSysmanResource
name: $t_board_prop_serial_number_t
members:
    - type: int8_t
      name: "str[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] NULL terminated string value"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for property $T_BOARD_PROP_BOARD_NUMBER"
class: $tSysmanResource
name: $t_board_prop_board_number_t
members:
    - type: int8_t
      name: "str[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] NULL terminated string value"
--- #--------------------------------------------------------------------------
type: struct
desc: "Request structure used to query a board resource property"
class: $tSysmanResource
name: $t_board_property_request_t
members:
    - type: $t_board_properties_t
      name: "property"
      desc: "[in] The property being requested (one of $t_board_properties_t)."
    - type: "void*"
      name: "pData"
      desc: |
            [in] Pointer to the data for the property.
            Each property has a corresponding data structure. The type of the data structure is derived from the property enumerator, converted to lower-case with "_t" appended.
    - type: uint32_t
      name: "size"
      desc: "[in] The size of the data structure pointed to by pData."
--- #--------------------------------------------------------------------------
type: function
desc: "Get board property data"
class: $tSysmanResource
name: GetBoardProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: uint32_t
      name: count
      desc: "[in] The number of properties in the array pRequest"
    - type: $t_board_property_request_t*
      name: pRequest
      desc: "[in] Pointer to list of properties and corresponding data storage"
returns:
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The resource is not of type $T_RESOURCE_TYPE_BOARD_CONTAINER"
--- #--------------------------------------------------------------------------
type: enum
desc: "PCI bar types"
class: $tSysmanResource
name: $t_pci_bar_type_t
etors:
    - name: $T_PCI_BAR_TYPE_CONFIG
      value: "0"
      desc: "PCI configuration space"
    - name: $T_PCI_BAR_TYPE_MMIO
      desc: "MMIO registers"
    - name: $T_PCI_BAR_TYPE_VRAM
      desc: "VRAM aperture"
    - name: $T_PCI_BAR_TYPE_ROM
      desc: "ROM aperture"
    - name: $T_PCI_BAR_TYPE_VGA_IO
      desc: "Legacy VGA IO ports"
    - name: $T_PCI_BAR_TYPE_VGA_MEM
      desc: "Legacy VGA memory"
    - name: $T_PCI_BAR_TYPE_INDIRECT_IO
      desc: "Indirect IO port access"
    - name: $T_PCI_BAR_TYPE_INDIRECT_MEM
      desc: "Indirect memory access"
    - name: $T_PCI_BAR_TYPE_OTHER
      desc: "Other type of PCI bar"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for a PCI bar"
class: $tSysmanResource
name: $t_pci_bar_info_t
members:
    - type: $t_pci_bar_type_t
      name: "type"
      desc: "[out] The type of bar"
    - type: uint64_t
      name: "base"
      desc: "[out] Base address of the bar."
    - type: uint64_t
      name: "size"
      desc: "[out] Size of the bar."
--- #--------------------------------------------------------------------------
type: enum
desc: "Device resource properties"
class: $tSysmanResource
name: $t_device_properties_t
details:
    - "For every property, there is a corresponding structure used to hold the property data. The type of the data structure is derived from the property enumerator, converted to lower-case with '_t' appended."
    - "Properties can be either read-only (ro), write-only (wo) or read-write (rw)."
    - "Properties can be either static or dynamic. Static properties are set during initialization and will not change during the lifetime of the application. Dynamic properties can change at any time and should be reread."
etors:
    - name: $T_DEVICE_PROP_BRAND
      value: "0"
      desc: "(ro static) The brand name of the device (data: $t_device_prop_brand_t)"
    - name: $T_DEVICE_PROP_MODEL
      desc: "(ro static) The model name of the device (data: $t_device_prop_model_t)"
    - name: $T_DEVICE_PROP_DEVICEID
      desc: "(ro static) The device ID of the device (data: $t_device_prop_deviceid_t)"
    - name: $T_DEVICE_PROP_VENDOR_NAME
      desc: "(ro static) The vendor name of the device (data: $t_device_prop_vendor_name_t)"
    - name: $T_DEVICE_PROP_ACCEL_ASSETS
      desc: "(ro static) The accelerator assets available in the device (data: $t_device_prop_accel_assets_t)"
    - name: $T_DEVICE_PROP_DRIVER_VERSION
      desc: "(ro static) The driver version associated with the device (data: $t_device_prop_driver_version_t)"
    - name: $T_DEVICE_PROP_BARS
      desc: "(ro static) The bars configured for the device (data: $t_device_prop_bars_t)"
    - name: $T_DEVICE_PROP_COLD_SHUTDOWN
      desc: "(wo dynamic) Cold shudown the device (data: $t_device_prop_cold_shutdown_t)"
    - name: $T_DEVICE_PROP_COLD_RESET
      desc: "(wo dynamic) Cold reset the device (data: $t_device_prop_cold_reset_t)"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for property $T_DEVICE_PROP_BRAND"
class: $tSysmanResource
name: $t_device_prop_brand_t
members:
    - type: int8_t
      name: "str[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] NULL terminated string value"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for property $T_DEVICE_PROP_MODEL"
class: $tSysmanResource
name: $t_device_prop_model_t
members:
    - type: int8_t
      name: "str[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] NULL terminated string value"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for property $T_DEVICE_PROP_DEVICEID"
class: $tSysmanResource
name: $t_device_prop_deviceid_t
members:
    - type: int8_t
      name: "str[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] NULL terminated string value"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for property $T_DEVICE_PROP_VENDOR_NAME"
class: $tSysmanResource
name: $t_device_prop_vendor_name_t
members:
    - type: int8_t
      name: "str[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] NULL terminated string value"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data about one type of accelerator asset"
class: $tSysmanResource
name: $t_device_prop_accel_asset_t
members:
    - type: $t_accel_asset_t
      name: "type"
      desc: "[out] The type of asset"
    - type: uint32_t
      name: "numBlocks"
      desc: "[out] The number of blocks of this asset type"
    - type: uint32_t
      name: "numEngines"
      desc: "[out] The number of submission engines for this type of asset"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_DEVICE_PROP_ACCEL_ASSETS"
class: $tSysmanResource
name: $t_device_prop_accel_assets_t
members:
    - type: uint64_t
      name: "assetBitfield"
      desc: "[out] A bitfield of assets available in the resource"
    - type: $t_device_prop_accel_asset_t
      name: "assetInfo[$T_ACCEL_ASSET_MAX_TYPES]"
      desc: "[out] Information about each asset."
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for property $T_DEVICE_PROP_DRIVER_VERSION"
class: $tSysmanResource
name: $t_device_prop_driver_version_t
members:
    - type: int8_t
      name: "str[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] NULL terminated string value"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_DEVICE_PROP_BARS"
class: $tSysmanResource
name: $t_device_prop_bars_t
members:
    - type: uint32_t
      name: "num"
      desc: "[out] The number of bars"
    - type: "const $t_pci_bar_info_t*"
      name: "pBars"
      desc: "[out][range(0, num-1)] Information about each bar."
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_DEVICE_PROP_COLD_SHUTDOWN"
class: $tSysmanResource
name: $t_device_prop_cold_shutdown_t
members:
    - type: $x_bool_t
      name: "doShutdown"
      desc: "[in] Set to true to perform a cold shutdown of the device"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_DEVICE_PROP_COLD_RESET"
class: $tSysmanResource
name: $t_device_prop_cold_reset_t
members:
    - type: $x_bool_t
      name: "doReset"
      desc: "[in] Set to true to perform a cold shutdown of the device"
--- #--------------------------------------------------------------------------
type: struct
desc: "Request structure used to query a device resource container property"
class: $tSysmanResource
name: $t_device_property_request_t
members:
    - type: $t_device_properties_t
      name: "property"
      desc: "[in] The property being requested (one of $t_device_properties_t)."
    - type: "void*"
      name: "pData"
      desc: |
            [in] Pointer to the data for the property.
            Each property has a corresponding data structure. The type of the data structure is derived from the property enumerator, converted to lower-case with "_t" appended.
    - type: uint32_t
      name: "size"
      desc: "[in] The size of the data structure pointed to by pData."
--- #--------------------------------------------------------------------------
type: function
desc: "Get device container property data"
class: $tSysmanResource
name: GetDeviceProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: uint32_t
      name: count
      desc: "[in] The number of properties in the array pRequest"
    - type: $t_device_property_request_t*
      name: pRequest
      desc: "[in] Pointer to list of properties and corresponding data storage"
returns:
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The resource is not of type $T_RESOURCE_TYPE_DEVICE_CONTAINER"
--- #--------------------------------------------------------------------------
type: function
desc: "Set device container property data"
class: $tSysmanResource
name: SetDeviceProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: uint32_t
      name: count
      desc: "[in] The number of properties in the array pRequest"
    - type: $t_device_property_request_t*
      name: pRequest
      desc: "[in] Pointer to list of properties and corresponding data storage"
returns:
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The resource is not of type $T_RESOURCE_TYPE_DEVICE_CONTAINER"
--- #--------------------------------------------------------------------------
type: enum
desc: "PSU voltage status"
class: $tSysmanResource
name: $t_psu_voltage_status_t
etors:
    - name: $T_PSU_VOLTAGE_STATUS_NORMAL
      value: "0"
      desc: "No unusual voltages have been detected"
    - name: $T_PSU_VOLTAGE_STATUS_OVER
      desc: "Over-voltage has occurred"
    - name: $T_PSU_VOLTAGE_STATUS_UNDER
      desc: "Under-voltage has occurred"
--- #--------------------------------------------------------------------------
type: enum
desc: "PSU resource properties"
class: $tSysmanResource
name: $t_psu_properties_t
details:
    - "For every property, there is a corresponding structure used to hold the property data. The type of the data structure is derived from the property enumerator, converted to lower-case with '_t' appended."
    - "Properties can be either read-only (ro), write-only (wo) or read-write (rw)."
    - "Properties can be either static or dynamic. Static properties are set during initialization and will not change during the lifetime of the application. Dynamic properties can change at any time and should be reread."
etors:
    - name: $T_PSU_PROP_AMP_LIMIT
      value: "0"
      desc: "(ro static) The maximum electrical current in amperes that can be drawn (data: $t_psu_prop_amp_limit_t)"
    - name: $T_PSU_PROP_VOLTAGE_STATUS
      desc: "(ro dynamic) Indicates if under or over voltage has occurred (data: $t_psu_prop_voltage_status_t)"
    - name: $T_PSU_PROP_FAN_FAILURE
      desc: "(ro dynamic) Indicates if the fan has failed (data: $t_psu_prop_fan_failure_t)"
    - name: $T_PSU_PROP_TEMPERATURE
      desc: "(ro dynamic) The current heatsink temperature in degrees celcius (data: $t_psu_prop_temperature_t)"
    - name: $T_PSU_PROP_AMPS
      desc: "(ro dynamic) The current amps being drawn in amperes (data: $t_psu_prop_amps_t)"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_PSU_PROP_AMP_LIMIT"
class: $tSysmanResource
name: $t_psu_prop_amp_limit_t
members:
    - type: uint32_t
      name: "limit"
      desc: "[out] The maximum electrical current in amperes that can be drawn"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_PSU_PROP_VOLTAGE_STATUS"
class: $tSysmanResource
name: $t_psu_prop_voltage_status_t
members:
    - type: $t_psu_voltage_status_t
      name: "status"
      desc: "[out] The current PSU voltage status)"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_PSU_PROP_FAN_FAILURE"
class: $tSysmanResource
name: $t_psu_prop_fan_failure_t
members:
    - type: $x_bool_t
      name: "status"
      desc: "[out] Indicates if the fan has failed"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_PSU_PROP_TEMPERATURE"
class: $tSysmanResource
name: $t_psu_prop_temperature_t
members:
    - type: uint32_t
      name: "temperature"
      desc: "[out] Read the current heatsink temperature in degrees celcius"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_PSU_PROP_AMPS"
class: $tSysmanResource
name: $t_psu_prop_amps_t
members:
    - type: uint32_t
      name: "current"
      desc: "[out] The amps being drawn in amperes"
--- #--------------------------------------------------------------------------
type: struct
desc: "Request structure used to query a PSU resource property"
class: $tSysmanResource
name: $t_psu_property_request_t
members:
    - type: $t_psu_properties_t
      name: "property"
      desc: "[in] The property being requested (one of $t_psu_properties_t)."
    - type: "void*"
      name: "pData"
      desc: |
            [in] Pointer to the data for the property.
            Each property has a corresponding data structure. The type of the data structure is derived from the property enumerator, converted to lower-case with "_t" appended.
    - type: uint32_t
      name: "size"
      desc: "[in] The size of the data structure pointed to by pData."
--- #--------------------------------------------------------------------------
type: function
desc: "Get PSU resource property data"
class: $tSysmanResource
name: GetPsuProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: uint32_t
      name: count
      desc: "[in] The number of properties in the array pRequest"
    - type: $t_psu_property_request_t*
      name: pRequest
      desc: "[in] Pointer to list of properties and corresponding data storage"
returns:
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The resource is not of type $T_RESOURCE_TYPE_PSU"
--- #--------------------------------------------------------------------------
type: function
desc: "Set PSU resource property data"
class: $tSysmanResource
name: SetPsuProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: uint32_t
      name: count
      desc: "[in] The number of properties in the array pRequest"
    - type: $t_psu_property_request_t*
      name: pRequest
      desc: "[in] Pointer to list of properties and corresponding data storage"
returns:
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The resource is not of type $T_RESOURCE_TYPE_PSU"
--- #--------------------------------------------------------------------------
type: enum
desc: "Temperature sensor resource properties"
class: $tSysmanResource
name: $t_temp_properties_t
details:
    - "For every property, there is a corresponding structure used to hold the property data. The type of the data structure is derived from the property enumerator, converted to lower-case with '_t' appended."
    - "Properties can be either read-only (ro), write-only (wo) or read-write (rw)."
    - "Properties can be either static or dynamic. Static properties are set during initialization and will not change during the lifetime of the application. Dynamic properties can change at any time and should be reread."
etors:
    - name: $T_TEMP_PROP_TEMPERATURE
      value: "0"
      desc: "(ro dynamic) The current temperature of the sensor in degrees celcius (data: $t_temp_prop_temperature_t)"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_TEMP_PROP_TEMPERATURE"
class: $tSysmanResource
name: $t_temp_prop_temperature_t
members:
    - type: uint32_t
      name: "temperature"
      desc: "[out] The current temperature of the sensor in degrees celcius"
--- #--------------------------------------------------------------------------
type: struct
desc: "Request structure used to query a temperature sensor resource property"
class: $tSysmanResource
name: $t_temp_property_request_t
members:
    - type: $t_temp_properties_t
      name: "property"
      desc: "[in] The property being requested (one of $t_temp_properties_t)."
    - type: "void*"
      name: "pData"
      desc: |
            [in] Pointer to the data for the property.
            Each property has a corresponding data structure. The type of the data structure is derived from the property enumerator, converted to lower-case with "_t" appended.
    - type: uint32_t
      name: "size"
      desc: "[in] The size of the data structure pointed to by pData."
--- #--------------------------------------------------------------------------
type: function
desc: "Get temperature sensor resource property data"
class: $tSysmanResource
name: GetTempProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: uint32_t
      name: count
      desc: "[in] The number of properties in the array pRequest"
    - type: $t_temp_property_request_t*
      name: pRequest
      desc: "[in] Pointer to list of properties and corresponding data storage"
returns:
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The resource is not of type $T_RESOURCE_TYPE_TEMP"
--- #--------------------------------------------------------------------------
type: enum
desc: "Fan resource speed mode"
class: $tSysmanResource
name: $t_fan_speed_mode_t
etors:
    - name: $T_FAN_SPEED_MODE_FIXED
      value: "0"
      desc: "The fan speed is currently set to a fixed value"
    - name: $T_FAN_SPEED_MODE_TABLE
      desc: "The fan speed is currently controlled dynamically by hardware based on a temp/speed table"
--- #--------------------------------------------------------------------------
type: enum
desc: "Fan speed units"
class: $tSysmanResource
name: $t_fan_speed_units_t
etors:
    - name: $T_FAN_SPEED_UNITS_RPM
      value: "0"
      desc: "The fan speed is in units of revolutions per minute (rpm)"
    - name: $T_FAN_SPEED_UNITS_PERCENT
      desc: "The fan speed is a percentage of the maximum speed of the fan"
--- #--------------------------------------------------------------------------
type: struct
desc: "Fan temperature/speed pair"
class: $tSysmanResource
name: $t_fan_temp_speed_t
members:
    - type: uint32_t
      name: "temperature"
      desc: "[in,out] Temperature in degrees celcius"
    - type: uint32_t
      name: "speed"
      desc: "[in,out] The speed of the fan"
    - type: $t_fan_speed_units_t
      name: "units"
      desc: "[in,out] The units of the member speed"
--- #--------------------------------------------------------------------------
type: macro
desc: "Maximum number of fan temperature/speed pairs in the fan speed table."
name: $T_FAN_TEMP_SPEED_PAIR_COUNT
value: "32"
--- #--------------------------------------------------------------------------
type: enum
desc: "Fan resource properties"
class: $tSysmanResource
name: $t_fan_properties_t
details:
    - "For every property, there is a corresponding structure used to hold the property data. The type of the data structure is derived from the property enumerator, converted to lower-case with '_t' appended."
    - "Properties can be either read-only (ro), write-only (wo) or read-write (rw)."
    - "Properties can be either static or dynamic. Static properties are set during initialization and will not change during the lifetime of the application. Dynamic properties can change at any time and should be reread."
etors:
    - name: $T_FAN_PROP_MAX_RPM
      value: "0"
      desc: "(ro static) The maximum RPM of the fan (data: $t_fan_prop_max_rpm_t)"
    - name: $T_FAN_PROP_MAX_TABLE_SIZE
      desc: "(ro static) The maximum number of points in the fan temp/speed table (data: $t_fan_prop_max_table_size_t)"
    - name: $T_FAN_PROP_SPEED_RPM
      desc: "(ro dynamic) The current fan speed in units of revolutions per minute (rpm) (data: $t_fan_prop_speed_rpm_t)"
    - name: $T_FAN_PROP_SPEED_PERCENT
      desc: "(ro dynamic) The current fan speed as a percentage of the maximum speed of that fan (data: $t_fan_prop_speed_percent_t)"
    - name: $T_FAN_PROP_MODE
      desc: "(ro dynamic) The current fan speed mode (one of $t_fan_speed_mode_t) (data: $t_fan_prop_mode_t)"
    - name: $T_FAN_PROP_FIXED_SPEED
      desc: "(rw dynamic) Read/write the fixed speed setting for the fan (data: $t_fan_prop_fixed_speed_t)"
    - name: $T_FAN_PROP_SPEED_TABLE
      desc: "(rw dynamic) Read/write the fan speed table (data: $t_fan_prop_speed_table_t)"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_FAN_PROP_MAX_RPM"
class: $tSysmanResource
name: $t_fan_prop_max_rpm_t
members:
    - type: uint32_t
      name: "maxSpeed"
      desc: "[out] The maximum RPM of the fan"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_FAN_PROP_MAX_TABLE_SIZE"
class: $tSysmanResource
name: $t_fan_prop_max_table_size_t
members:
    - type: uint32_t
      name: "maxPoints"
      desc: "[out] The maximum number of points in the fan temp/speed table"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_FAN_PROP_SPEED_RPM"
class: $tSysmanResource
name: $t_fan_prop_speed_rpm_t
members:
    - type: uint32_t
      name: "speed"
      desc: "[out] The current fan speed in units of revolutions per minute (rpm)"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_FAN_PROP_SPEED_PERCENT"
class: $tSysmanResource
name: $t_fan_prop_speed_percent_t
members:
    - type: uint32_t
      name: "speed"
      desc: "[out] The current fan speed as a percentage of the maximum speed of that fan"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_FAN_PROP_MODE"
class: $tSysmanResource
name: $t_fan_prop_mode_t
members:
    - type: $t_fan_speed_mode_t
      name: "mode"
      desc: "[in,out] The current fan speed mode (one of $t_fan_speed_mode_t)"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_FAN_PROP_FIXED_SPEED"
class: $tSysmanResource
name: $t_fan_prop_fixed_speed_t
members:
    - type: uint32_t
      name: "speed"
      desc: "[in,out] The speed of the fan"
    - type: $t_fan_speed_units_t
      name: "units"
      desc: "[in,out] The units of the member speed"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_FAN_PROP_SPEED_TABLE"
class: $tSysmanResource
name: $t_fan_prop_speed_table_t
members:
    - type: uint32_t*
      name: "pCount"
      desc: |
            [in,out] The number of temp/speed pairs.
            When reading the current fan speed table, this will be set to the number of points returned.
            When setting the fan speed table, this specifies the number of valid points in the table.
    - type: $t_fan_temp_speed_t
      name: "points[$T_FAN_TEMP_SPEED_PAIR_COUNT]"
      desc: "[in,out][range(0, *pCount)] Array of temperature/fan speed pairs"
--- #--------------------------------------------------------------------------
type: struct
desc: "Request structure used to query a fan resource property"
class: $tSysmanResource
name: $t_fan_property_request_t
members:
    - type: $t_fan_properties_t
      name: "property"
      desc: "[in] The property being requested (one of $t_fan_properties_t)."
    - type: "void*"
      name: "pData"
      desc: |
            [in] Pointer to the data for the property.
            Each property has a corresponding data structure. The type of the data structure is derived from the property enumerator, converted to lower-case with "_t" appended.
    - type: uint32_t
      name: "size"
      desc: "[in] The size of the data structure pointed to by pData."
--- #--------------------------------------------------------------------------
type: function
desc: "Get fan resource property data"
class: $tSysmanResource
name: GetFanProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: uint32_t
      name: count
      desc: "[in] The number of properties in the array pRequest"
    - type: $t_fan_property_request_t*
      name: pRequest
      desc: "[in] Pointer to list of properties and corresponding data storage"
returns:
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The resource is not of type $T_RESOURCE_TYPE_FAN"
--- #--------------------------------------------------------------------------
type: function
desc: "Set fan resource property data"
class: $tSysmanResource
name: SetFanProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: uint32_t
      name: count
      desc: "[in] The number of properties in the array pRequest"
    - type: $t_fan_property_request_t*
      name: pRequest
      desc: "[in] Pointer to list of properties and corresponding data storage"
returns:
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The resource is not of type $T_RESOURCE_TYPE_FAN"
--- #--------------------------------------------------------------------------
type: enum
desc: "LED resource properties"
class: $tSysmanResource
name: $t_led_properties_t
details:
    - "For every property, there is a corresponding structure used to hold the property data. The type of the data structure is derived from the property enumerator, converted to lower-case with '_t' appended."
    - "Properties can be either read-only (ro), write-only (wo) or read-write (rw)."
    - "Properties can be either static or dynamic. Static properties are set during initialization and will not change during the lifetime of the application. Dynamic properties can change at any time and should be reread."
etors:
    - name: $T_LED_PROP_RGB_CAP
      value: "0"
      desc: "(ro static) Indicates if the LED is RGB capable (data: $t_led_prop_rgb_cap_t)"
    - name: $T_LED_PROP_STATE
      desc: "(rw dynaic) The LED state - on/off and color (data: $t_led_prop_state_t)"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_LED_PROP_RGB_CAP"
class: $tSysmanResource
name: $t_led_prop_rgb_cap_t
members:
    - type: $x_bool_t
      name: "haveRGB"
      desc: "[out] Indicates if the LED is RGB capable"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_LED_PROP_STATE"
class: $tSysmanResource
name: $t_led_prop_state_t
members:
    - type: $x_bool_t
      name: isOn
      desc: "[in,out] Indicates if the LED is on or off"
    - type: uint8_t
      name: "red"
      desc: "[in,out][range(0, 255)] The LED red value"
    - type: uint8_t
      name: "green"
      desc: "[in,out][range(0, 255)] The LED green value"
    - type: uint8_t
      name: "blue"
      desc: "[in,out][range(0, 255)] The LED blue value"
--- #--------------------------------------------------------------------------
type: struct
desc: "Request structure used to query a LED resource property"
class: $tSysmanResource
name: $t_led_property_request_t
members:
    - type: $t_led_properties_t
      name: "property"
      desc: "[in] The property being requested (one of $t_led_properties_t)."
    - type: "void*"
      name: "pData"
      desc: |
            [in] Pointer to the data for the property.
            Each property has a corresponding data structure. The type of the data structure is derived from the property enumerator, converted to lower-case with "_t" appended.
    - type: uint32_t
      name: "size"
      desc: "[in] The size of the data structure pointed to by pData."
--- #--------------------------------------------------------------------------
type: function
desc: "Get LED resource property data"
class: $tSysmanResource
name: GetLedProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: uint32_t
      name: count
      desc: "[in] The number of properties in the array pRequest"
    - type: $t_led_property_request_t*
      name: pRequest
      desc: "[in] Pointer to list of properties and corresponding data storage"
returns:
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The resource is not of type $T_RESOURCE_TYPE_LED"
--- #--------------------------------------------------------------------------
type: function
desc: "Set LED resource property data"
class: $tSysmanResource
name: SetLedProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: uint32_t
      name: count
      desc: "[in] The number of properties in the array pRequest"
    - type: $t_led_property_request_t*
      name: pRequest
      desc: "[in] Pointer to list of properties and corresponding data storage"
returns:
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The resource is not of type $T_RESOURCE_TYPE_LED"
--- #--------------------------------------------------------------------------
type: enum
desc: "Firmware resource properties"
class: $tSysmanResource
name: $t_firmware_properties_t
details:
    - "For every property, there is a corresponding structure used to hold the property data. The type of the data structure is derived from the property enumerator, converted to lower-case with '_t' appended."
    - "Properties can be either read-only (ro), write-only (wo) or read-write (rw)."
    - "Properties can be either static or dynamic. Static properties are set during initialization and will not change during the lifetime of the application. Dynamic properties can change at any time and should be reread."
etors:
    - name: $T_FIRMWARE_PROP_NAME
      value: "0"
      desc: "(ro static) Name encoded in the loaded firmware image (data: $t_firmware_prop_name_t)"
    - name: $T_FIRMWARE_PROP_VERSION
      desc: "(ro static) The version of the loaded firmware image (data: $t_firmware_prop_version_t)"
    - name: $T_FIRMWARE_PROP_CHECK
      desc: "(ro dynamic) Verify the checksum of the loaded firmware image (data: $t_firmware_prop_check_t)"
    - name: $T_FIRMWARE_PROP_FLASH
      desc: "(wo dynamically) Flash a new firmware image (data: $t_firmware_prop_flash_t)"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for property $T_FIRMWARE_PROP_NAME"
class: $tSysmanResource
name: $t_firmware_prop_name_t
members:
    - type: int8_t
      name: "str[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] NULL terminated string value"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for property $T_FIRMWARE_PROP_VERSION"
class: $tSysmanResource
name: $t_firmware_prop_version_t
members:
    - type: int8_t
      name: "str[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] NULL terminated string value"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_FIRMWARE_PROP_CHECK"
class: $tSysmanResource
name: $t_firmware_prop_check_t
members:
    - type: uint32_t
      name: "checksum"
      desc: "[out] The calculated checksum of the loaded firmware image"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_FIRMWARE_PROP_FLASH"
class: $tSysmanResource
name: $t_firmware_prop_flash_t
members:
    - type: void*
      name: "pImage"
      desc: "[in] Pointer to the image to be flashed"
    - type: uint32_t
      name: "size"
      desc: "[in] Size in bytes of the image pointed to by pImage"
--- #--------------------------------------------------------------------------
type: struct
desc: "Request structure used to query a firmware resource property"
class: $tSysmanResource
name: $t_firmware_property_request_t
members:
    - type: $t_firmware_properties_t
      name: "property"
      desc: "[in] The property being requested (one of $t_firmware_properties_t)."
    - type: "void*"
      name: "pData"
      desc: |
            [in] Pointer to the data for the property.
            Each property has a corresponding data structure. The type of the data structure is derived from the property enumerator, converted to lower-case with "_t" appended.
    - type: uint32_t
      name: "size"
      desc: "[in] The size of the data structure pointed to by pData."
--- #--------------------------------------------------------------------------
type: function
desc: "Get firmware resource property data"
class: $tSysmanResource
name: GetFirmwareProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: uint32_t
      name: count
      desc: "[in] The number of properties in the array pRequest"
    - type: $t_firmware_property_request_t*
      name: pRequest
      desc: "[in] Pointer to list of properties and corresponding data storage"
returns:
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The resource is not of type $T_RESOURCE_TYPE_FIRMWARE"
--- #--------------------------------------------------------------------------
type: function
desc: "Set firmware resource property data"
class: $tSysmanResource
name: SetFirmwareProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: uint32_t
      name: count
      desc: "[in] The number of properties in the array pRequest"
    - type: $t_firmware_property_request_t*
      name: pRequest
      desc: "[in] Pointer to list of properties and corresponding data storage"
returns:
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The resource is not of type $T_RESOURCE_TYPE_FIRMWARE"
--- #--------------------------------------------------------------------------
type: enum
desc: "Power domain resource properties"
class: $tSysmanResource
name: $t_pwr_properties_t
details:
    - "For every property, there is a corresponding structure used to hold the property data. The type of the data structure is derived from the property enumerator, converted to lower-case with '_t' appended."
    - "Properties can be either read-only (ro), write-only (wo) or read-write (rw)."
    - "Properties can be either static or dynamic. Static properties are set during initialization and will not change during the lifetime of the application. Dynamic properties can change at any time and should be reread."
etors:
    - name: $T_PWR_PROP_ACCEL_ASSETS
      value: "0"
      desc: "(ro static) List of accelerator assets that contribute to this power domain (data: $t_pwr_prop_accel_assets_t)"
    - name: $T_PWR_PROP_MAX_LIMIT
      desc: "(ro static) The maximum power limit that can be requested (data: $t_pwr_prop_max_limit_t)"
    - name: $T_PWR_PROP_ENERGY_COUNTER
      desc: "(ro dynamic) The value of the monotonic energy counter (data: $t_pwr_prop_energy_counter_t)"
    - name: $T_PWR_PROP_SUSTAINED_LIMIT
      desc: "(rw dynamic) The sustained power limit (data: $t_pwr_prop_sustained_limit_t)"
    - name: $T_PWR_PROP_BURST_LIMIT
      desc: "(rw dynamic) The burst power limit (data: $t_pwr_prop_burst_limit_t)"
    - name: $T_PWR_PROP_PEAK_LIMIT
      desc: "(rw dynamic) The peak power limit (data: $t_pwr_prop_peak_limit_t)"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_PWR_PROP_ACCEL_ASSETS"
class: $tSysmanResource
name: $t_pwr_prop_accel_assets_t
members:
    - type: uint64_t
      name: "assets"
      desc: "[out] List of accelerator assets that contribute to this power domain (Bitfield of (1<<$t_accel_asset_t))."
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_PWR_PROP_MAX_LIMIT"
class: $tSysmanResource
name: $t_pwr_prop_max_limit_t
members:
    - type: uint32_t
      name: "assets"
      desc: "[out] The maximum power limit in milliwatts that can be requested."
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_PWR_PROP_ENERGY_COUNTER"
class: $tSysmanResource
name: $t_pwr_prop_energy_counter_t
members:
    - type: uint64_t
      name: "energy"
      desc: "[out] The value of the monotonic energy counter in millijoules."
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_PWR_PROP_SUSTAINED_LIMIT"
class: $tSysmanResource
name: $t_pwr_prop_sustained_limit_t
details:
    - "The power controller (Punit) will throttle the operating frequency if the power averaged over a window (typically seconds) exceeds this limit."
members:
    - type: $x_bool_t
      name: enabled
      desc: "[in,out] indicates if the limit is enabled (true) or ignored (false)"
    - type: uint32_t
      name: power
      desc: "[in,out] power limit in milliwatts"
    - type: uint32_t
      name: interval
      desc: "[in,out] power averaging window (Tau) in milliseconds"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_PWR_PROP_BURST_LIMIT"
class: $tSysmanResource
name: $t_pwr_prop_burst_limit_t
details:
    - "The power controller (Punit) will throttle the operating frequency of the device if the power averaged over a few milliseconds exceeds a limit known as PL2. Typically PL2 > PL1 so that it permits the frequency to burst higher for short periods than would be otherwise permitted by PL1."
members:
    - type: $x_bool_t
      name: enabled
      desc: "[in,out] indicates if the limit is enabled (true) or ignored (false)"
    - type: uint32_t
      name: power
      desc: "[in,out] power limit in milliwatts"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_PWR_PROP_PEAK_LIMIT"
class: $tSysmanResource
name: $t_pwr_prop_peak_limit_t
details:
    - "The power controller (Punit) will preemptively throttle the operating frequency of the device when the instantaneous power exceeds this limit. The limit is known as PL4. It expresses the maximum power that can be drawn from the power supply."
    - "If this power limit is removed or set too high, the power supply will generate an interrupt when it detects an overcurrent condition and the power controller will throttle the device frequencies down to min. It is thus better to tune the PL4 value in order to avoid such excursions."
members:
    - type: uint32_t
      name: power
      desc: "[in,out] power limit in milliwatts"
--- #--------------------------------------------------------------------------
type: struct
desc: "Request structure used to query a power domain resource property"
class: $tSysmanResource
name: $t_pwr_property_request_t
members:
    - type: $t_pwr_properties_t
      name: "property"
      desc: "[in] The property being requested (one of $t_pwr_properties_t)."
    - type: "void*"
      name: "pData"
      desc: |
            [in] Pointer to the data for the property.
            Each property has a corresponding data structure. The type of the data structure is derived from the property enumerator, converted to lower-case with "_t" appended.
    - type: uint32_t
      name: "size"
      desc: "[in] The size of the data structure pointed to by pData."
--- #--------------------------------------------------------------------------
type: function
desc: "Get power domain resource property data"
class: $tSysmanResource
name: GetPwrProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: uint32_t
      name: count
      desc: "[in] The number of properties in the array pRequest"
    - type: $t_pwr_property_request_t*
      name: pRequest
      desc: "[in] Pointer to list of properties and corresponding data storage"
returns:
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The resource is not of type $T_RESOURCE_TYPE_PWR"
--- #--------------------------------------------------------------------------
type: function
desc: "Set power power resource property data"
class: $tSysmanResource
name: SetPwrProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: uint32_t
      name: count
      desc: "[in] The number of properties in the array pRequest"
    - type: $t_pwr_property_request_t*
      name: pRequest
      desc: "[in] Pointer to list of properties and corresponding data storage"
returns:
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The resource is not of type $T_RESOURCE_TYPE_PWR"
--- #--------------------------------------------------------------------------
type: enum
desc: "Frequency domain types"
class: $tSysmanResource
name: $t_freq_domain_type_t
etors:
    - name: $T_FREQ_DOMAIN_TYPE_INDEPENDENT
      value: "0"
      desc: "The frequency of this domain can be managed independently of other domains"
    - name: $T_FREQ_DOMAIN_TYPE_DEPENDENT
      desc: "The frequency of this domain is dependent on another domain through a clock divider"
--- #--------------------------------------------------------------------------
type: enum
desc: "DVFS mode"
class: $tSysmanResource
name: $t_dvfs_mode_t
etors:
    - name: $T_DVFS_MODE_MIN
      value: "0"
      desc: "Fixed minimum frequency will be requested unless specific applications request otherwise."
    - name: $T_DVFS_MODE_EFFICIENT
      desc: "Dynamic frequency management that prefers power saving over performance."
    - name: $T_DVFS_MODE_STABLE
      desc: "Fixed frequency that should not be throttled under normal operating conditions."
    - name: $T_DVFS_MODE_DEFAULT
      desc: "Dynamic frequency management that balances power and performance."
    - name: $T_DVFS_MODE_AGGRESSIVE
      desc: "Dynamic frequency management that trades more power for better performance."
    - name: $T_DVFS_MODE_MAX
      desc: "Fixed maximum frequency."
--- #--------------------------------------------------------------------------
type: enum
desc: "Frequency throttle reasons"
class: $tSysmanResource
name: $t_freq_throttle_reasons_t
etors:
    - name: $T_FREQ_THROTTLE_REASONS_NONE
      value: "0"
      desc: "frequency not throttled"
    - name: $T_FREQ_THROTTLE_REASONS_AVE_PWR_CAP
      value: "$X_BIT( 0 )"
      desc: "frequency throttled due to average power excursion (PL1)"
    - name: $T_FREQ_THROTTLE_REASONS_BURST_PWR_CAP
      value: "$X_BIT( 1 )"
      desc: "frequency throttled due to burst power excursion (PL2)"
    - name: $T_FREQ_THROTTLE_REASONS_CURRENT_LIMIT
      value: "$X_BIT( 2 )"
      desc: "frequency throttled due to current excursion (PL4)"
    - name: $T_FREQ_THROTTLE_REASONS_THERMAL_LIMIT
      value: "$X_BIT( 3 )"
      desc: "frequency throttled due to thermal excursion (T > TjMax)"
    - name: $T_FREQ_THROTTLE_REASONS_PSU_ALERT
      value: "$X_BIT( 4 )"
      desc: "frequency throttled due to power supply assertion"
    - name: $T_FREQ_THROTTLE_REASONS_SW_RANGE
      value: "$X_BIT( 5 )"
      desc: "frequency throttled due to software supplied frequency range"
    - name: $T_FREQ_THROTTLE_REASONS_HW_RANGE
      value: "$X_BIT( 6 )"
      desc: "frequency throttled due to a sub block that has a lower frequency range when it receives clocks"
--- #--------------------------------------------------------------------------
type: struct
desc: "Frequency divider element"
class: $tSysmanResource
name: $t_freq_divider_t
details:
    - "The frequency of a domain of type $T_FREQ_DOMAIN_TYPE_DEPENDENT is obtained by the formula:"
    - "freq = source domain freq * numerator / denominator"
members:
    - type: uint16_t
      name: numerator
      desc: "[in,out] numerator of the ratio"
    - type: uint16_t
      name: denominator
      desc: "[in,out] denominator of the ratio"
--- #--------------------------------------------------------------------------
type: enum
desc: "Frequency domain resource properties"
class: $tSysmanResource
name: $t_freq_properties_t
details:
    - "For every property, there is a corresponding structure used to hold the property data. The type of the data structure is derived from the property enumerator, converted to lower-case with '_t' appended."
    - "Properties can be either read-only (ro), write-only (wo) or read-write (rw)."
    - "Properties can be either static or dynamic. Static properties are set during initialization and will not change during the lifetime of the application. Dynamic properties can change at any time and should be reread."
etors:
    - name: $T_FREQ_PROP_ACCEL_ASSETS
      value: "0"
      desc: "(ro static) List of accelerator assets that are connected to this power domain (data: $t_freq_prop_accel_assets_t)"
    - name: $T_FREQ_PROP_DOMAIN_TYPE
      desc: "(ro static) The type of frequency domain (data: $t_freq_prop_domain_type_t)"
    - name: $T_FREQ_PROP_AVAIL_CLOCKS
      desc: "(ro static) Available frequency clocks that this domain can run at (data: $t_freq_prop_avail_clocks_t)"
    - name: $T_FREQ_PROP_AVAIL_DIVIDERS
      desc: "(ro static) Available dividers that this domain can run with (data: $t_freq_prop_avail_dividers_t)"
    - name: $T_FREQ_PROP_SRC_FREQ
      desc: "(ro static) Get the UUID of the source frequency domain resource if the type is dependent (data: $t_freq_prop_src_freq_t)"
    - name: $T_FREQ_PROP_DVFS_MODE
      desc: "(rw dynamic) The operating mode of dynamic frequency management for this domain (data: $t_freq_prop_dvfs_mode_t)"
    - name: $T_FREQ_PROP_FREQ_RANGE
      desc: "(rw dynamic) The frequencies between which dynamic frequency management operates (data: $t_freq_prop_freq_range_t)"
    - name: $T_FREQ_PROP_FREQ_TDP
      desc: "(ro dynamic) The maximum frequency supported under the current TDP conditions (data: $t_freq_prop_freq_tdp_t)"
    - name: $T_FREQ_PROP_FREQ_EFFICIENT
      desc: "(ro dynamic) The efficient minimum frequency (data: $t_freq_prop_freq_efficient_t)"
    - name: $T_FREQ_PROP_FREQ_REQUEST
      desc: "(ro dynamic) The current frequency request (data: $t_freq_prop_freq_request_t)"
    - name: $T_FREQ_PROP_FREQ_RESOLVED
      desc: "(ro dynamic) The resolved frequency (data: $t_freq_prop_freq_resolved_t)"
    - name: $T_FREQ_PROP_FREQ_DIVIDER
      desc: "(rw dynamic) The current frequency divider for dependent frequency domains (data: $t_freq_prop_freq_divider_t)"
    - name: $T_FREQ_PROP_THROTTLE_REASONS
      desc: "(ro dynamic) The reasons that the frequency is being limited by the PCU (data: $t_freq_prop_throttle_reasons_t)"
    - name: $T_FREQ_PROP_THROTTLE_TIME
      desc: "(ro dynamic) The total time that the frequency has been limited by the PCU (data: $t_freq_prop_throttle_time_t)"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_FREQ_PROP_ACCEL_ASSETS"
class: $tSysmanResource
name: $t_freq_prop_accel_assets_t
members:
    - type: uint64_t
      name: "assets"
      desc: "[out] List of accelerator assets that are connected to this power domain (Bitfield of (1<<$t_accel_asset_t))."
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_FREQ_PROP_DOMAIN_TYPE"
class: $tSysmanResource
name: $t_freq_prop_domain_type_t
members:
    - type: $t_freq_domain_type_t
      name: type
      desc: "[out] The type of frequency domain"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_FREQ_PROP_AVAIL_CLOCKS"
class: $tSysmanResource
name: $t_freq_prop_avail_clocks_t
details:
    - "The list is ordered from the smallest frequency to the largest frequency."
members:
    - type: uint32_t
      name: num
      desc: "[out] The number of clocks"
    - type: "const uint32_t*"
      name: "pClocks"
      desc: "[out] Array of clock frequencies in MHz ordered from smallest to largest."
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_FREQ_PROP_AVAIL_DIVIDERS"
class: $tSysmanResource
name: $t_freq_prop_avail_dividers_t
details:
    - "The list is ordered from the smallest ratio to the largest ratio."
members:
    - type: uint32_t
      name: num
      desc: "[out] The number of dividers"
    - type: "const $t_freq_divider_t*"
      name: "pDividers"
      desc: "[out] Array of numerator/denominator for each divider"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_FREQ_PROP_SRC_FREQ"
class: $tSysmanResource
name: $t_freq_prop_src_freq_t
members:
    - type: $t_resource_uuid_t
      name: uuid
      desc: "[out] The resource UUID of the source frequency domain"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_FREQ_PROP_DVFS_MODE"
class: $tSysmanResource
name: $t_freq_prop_dvfs_mode_t
members:
    - type: $t_dvfs_mode_t
      name: mode
      desc: "[in,out] The DVFS operating mode"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_FREQ_PROP_FREQ_RANGE"
class: $tSysmanResource
name: $t_freq_prop_freq_range_t
members:
    - type: uint32_t
      name: min
      desc: "[in,out] Minimum frequency in MHz"
    - type: uint16_t
      name: max
      desc: "[in,out] Maximum frequency in MHz"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_FREQ_PROP_FREQ_TDP"
class: $tSysmanResource
name: $t_freq_prop_freq_tdp_t
members:
    - type: uint32_t
      name: "freqTdp"
      desc: "[out] The maximum frequency in MHz supported under the current TDP conditions"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_FREQ_PROP_FREQ_EFFICIENT"
class: $tSysmanResource
name: $t_freq_prop_freq_efficient_t
members:
    - type: uint32_t
      name: "freqEfficient"
      desc: "[out] The efficient minimum frequency in MHz"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_FREQ_PROP_FREQ_REQUEST"
class: $tSysmanResource
name: $t_freq_prop_freq_request_t
members:
    - type: uint32_t
      name: "freqRequest"
      desc: "[out] The current frequency request in MHz"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_FREQ_PROP_FREQ_RESOLVED"
class: $tSysmanResource
name: $t_freq_prop_freq_resolved_t
members:
    - type: uint32_t
      name: "freqResolved"
      desc: "[out] The resolved frequency in MHz"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_FREQ_PROP_FREQ_DIVIDER"
class: $tSysmanResource
name: $t_freq_prop_freq_divider_t
members:
    - type: $t_freq_divider_t
      name: divider
      desc: "[in,out] The frequency divider"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_FREQ_PROP_THROTTLE_REASONS"
class: $tSysmanResource
name: $t_freq_prop_throttle_reasons_t
members:
    - type: uint32_t
      name: "throttleReasons"
      desc: "[out] The reasons that the frequency is being limited by the PCU (Bitfield of (1<<$t_freq_throttle_reasons_t))."
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_FREQ_PROP_THROTTLE_TIME"
class: $tSysmanResource
name: $t_freq_prop_throttle_time_t
members:
    - type: uint32_t
      name: "throttleTime"
      desc: "[out] The total time in microseconds that the frequency has been limited by the PCU."
--- #--------------------------------------------------------------------------
type: struct
desc: "Request structure used to query a frequency domain resource property"
class: $tSysmanResource
name: $t_freq_property_request_t
members:
    - type: $t_freq_properties_t
      name: "property"
      desc: "[in] The property being requested (one of $t_freq_properties_t)."
    - type: "void*"
      name: "pData"
      desc: |
            [in] Pointer to the data for the property.
            Each property has a corresponding data structure. The type of the data structure is derived from the property enumerator, converted to lower-case with "_t" appended.
    - type: uint32_t
      name: "size"
      desc: "[in] The size of the data structure pointed to by pData."
--- #--------------------------------------------------------------------------
type: function
desc: "Get frequency domain resource property data"
class: $tSysmanResource
name: GetFreqProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: uint32_t
      name: count
      desc: "[in] The number of properties in the array pRequest"
    - type: $t_freq_property_request_t*
      name: pRequest
      desc: "[in] Pointer to list of properties and corresponding data storage"
returns:
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The resource is not of type $T_RESOURCE_TYPE_FREQ"
--- #--------------------------------------------------------------------------
type: function
desc: "Set frequency domain resource property data"
class: $tSysmanResource
name: SetFreqProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: uint32_t
      name: count
      desc: "[in] The number of properties in the array pRequest"
    - type: $t_freq_property_request_t*
      name: pRequest
      desc: "[in] Pointer to list of properties and corresponding data storage"
returns:
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The resource is not of type $T_RESOURCE_TYPE_FREQ"
--- #--------------------------------------------------------------------------
type: enum
desc: "Power-well domain promotion modes"
class: $tSysmanResource
name: $t_pwrwell_promo_mode_t
etors:
    - name: $T_PWRWELL_PROMO_MODE_IMMEDIATE
      value: "0"
      desc: "The power-well will shutdown immediately when all contained units are idle."
    - name: $T_PWRWELL_PROMO_MODE_EFFICIENT
      desc: "Favor energy savings over performance. The power-well is more likely to shutdown when all contained units are idle, even if this will cause some performance degredation."
    - name: $T_PWRWELL_PROMO_MODE_DEFAULT
      desc: "Best compromise between performance and energy savings."
    - name: $T_PWRWELL_PROMO_MODE_PERFORMANCE
      desc: "Favor performance over energy savings. The power-well is more likely to stay on when all contained units are idle since it has dedicated that more work will be executing shortly."
    - name: $T_PWRWELL_PROMO_MODE_NEVER
      desc: "The power-well will never shutdown. This can improve performance but uses more energy."
--- #--------------------------------------------------------------------------
type: enum
desc: "Power-well domain resource properties"
class: $tSysmanResource
name: $t_pwrwell_properties_t
details:
    - "For every property, there is a corresponding structure used to hold the property data. The type of the data structure is derived from the property enumerator, converted to lower-case with '_t' appended."
    - "Properties can be either read-only (ro), write-only (wo) or read-write (rw)."
    - "Properties can be either static or dynamic. Static properties are set during initialization and will not change during the lifetime of the application. Dynamic properties can change at any time and should be reread."
etors:
    - name: $T_PWRWELL_PROP_ACCEL_ASSETS
      value: "0"
      desc: "(ro static) List of accelerator assets that are connected to this power-well domain (data: $t_pwrwell_prop_accel_assets_t)"
    - name: $T_PWRWELL_PROP_PROMO_CAP
      desc: "(ro static) Find out if the power-well domain has a programmable promotion setting (data: $t_pwrwell_prop_promo_cap_t)"
    - name: $T_PWRWELL_PROP_PROMO_MODE
      desc: "(rw dynamic) The current promotion mode (data: $t_pwrwell_prop_promo_mode_t)"
    - name: $T_PWRWELL_PROP_UTILIZATION
      desc: "(ro dynamic) Monotonic counters for the amount of time the power-well is off/idle/active (data: $t_pwrwell_prop_utilization_t)"
    - name: $T_PWRWELL_PROP_TRANSITIONS
      desc: "(ro dynamic) The monotonic counter for the number of times that the power-well has transitioned between off/idle/active states (data: $t_pwrwell_prop_transitions_t)"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_PWRWELL_PROP_ACCEL_ASSETS"
class: $tSysmanResource
name: $t_pwrwell_prop_accel_assets_t
members:
    - type: uint64_t
      name: "assets"
      desc: "[out] List of accelerator assets that are connected to this power-well domain (bitfield of (1<<$t_accel_asset_t))."
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_PWRWELL_PROP_PROMO_CAP"
class: $tSysmanResource
name: $t_pwrwell_prop_promo_cap_t
members:
    - type: $x_bool_t
      name: "canChangePromoMode"
      desc: "[out] Indicates if the power-well domain has a programmable promotion setting."
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_PWRWELL_PROP_PROMO_MODE"
class: $tSysmanResource
name: $t_pwrwell_prop_promo_mode_t
members:
    - type: $t_pwrwell_promo_mode_t
      name: mode
      desc: "[in,out] Current promotion mode"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_PWRWELL_PROP_UTILIZATION"
class: $tSysmanResource
name: $t_pwrwell_prop_utilization_t
members:
    - type: uint32_t
      name: "sleepCounter"
      desc: "[out] The monotonic counter for the amount of time in microseconds that the power-well is off."
    - type: uint32_t
      name: "idleCounter"
      desc: "[out] The monotonic counter for the amount of time in microseconds that the power-well is on but not executing any accelerator workloads."
    - type: uint32_t
      name: "activeCounter"
      desc: "[out] The monotonic counter for the amount of time the power-well is on and executing accelerator workloads."
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_PWRWELL_PROP_TRANSITIONS"
class: $tSysmanResource
name: $t_pwrwell_prop_transitions_t
members:
    - type: uint32_t
      name: "wakeCounter"
      desc: "[out] The monotonic counter for the number of times that the power-well has transitioned from a sleep state to a powered on state."
    - type: uint32_t
      name: "execCounter"
      desc: "[out] The monotonic counter for the number of times that the power-well has transitioned from a sleep or idle state to an active state."
--- #--------------------------------------------------------------------------
type: struct
desc: "Request structure used to query a power-well domain resource property"
class: $tSysmanResource
name: $t_pwrwell_property_request_t
members:
    - type: $t_pwrwell_properties_t
      name: "property"
      desc: "[in] The property being requested (one of $t_pwrwell_properties_t)."
    - type: "void*"
      name: "pData"
      desc: |
            [in] Pointer to the data for the property.
            Each property has a corresponding data structure. The type of the data structure is derived from the property enumerator, converted to lower-case with "_t" appended.
    - type: uint32_t
      name: "size"
      desc: "[in] The size of the data structure pointed to by pData."
--- #--------------------------------------------------------------------------
type: function
desc: "Get power-well domain resource property data"
class: $tSysmanResource
name: GetPwrwellProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: uint32_t
      name: count
      desc: "[in] The number of properties in the array pRequest"
    - type: $t_pwrwell_property_request_t*
      name: pRequest
      desc: "[in] Pointer to list of properties and corresponding data storage"
returns:
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The resource is not of type $T_RESOURCE_TYPE_PWRWELL"
--- #--------------------------------------------------------------------------
type: function
desc: "Set power-well domain resource property data"
class: $tSysmanResource
name: SetPwrwellProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: uint32_t
      name: count
      desc: "[in] The number of properties in the array pRequest"
    - type: $t_pwrwell_property_request_t*
      name: pRequest
      desc: "[in] Pointer to list of properties and corresponding data storage"
returns:
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The resource is not of type $T_RESOURCE_TYPE_PWRWELL"
--- #--------------------------------------------------------------------------
type: enum
desc: "Accelerator asset resource properties"
class: $tSysmanResource
name: $t_accel_properties_t
details:
    - "For every property, there is a corresponding structure used to hold the property data. The type of the data structure is derived from the property enumerator, converted to lower-case with '_t' appended."
    - "Properties can be either read-only (ro), write-only (wo) or read-write (rw)."
    - "Properties can be either static or dynamic. Static properties are set during initialization and will not change during the lifetime of the application. Dynamic properties can change at any time and should be reread."
etors:
    - name: $T_ACCEL_PROP_ACCEL_ASSETS
      value: "0"
      desc: "(ro static) List of accelerator assets that contribute to counters in this resource (data: $t_accel_prop_accel_assets_t)"
    - name: $T_ACCEL_PROP_UTILIZATION
      desc: "(ro dynamic) The total wall time accelerator assets in this resource are active (data: $t_accel_prop_utilization_t)"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_ACCEL_PROP_ACCEL_ASSETS"
class: $tSysmanResource
name: $t_accel_prop_accel_assets_t
members:
    - type: uint64_t
      name: "assets"
      desc: "[out] List of accelerator assets that contribute to counters in this resource (bitfield of (1<<$t_accel_asset_t))."
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_ACCEL_PROP_UTILIZATION"
class: $tSysmanResource
name: $t_accel_prop_utilization_t
members:
    - type: uint32_t
      name: "activeCounter"
      desc: "[out] Monotonic counter for total wall time in microseconds that accelerator assets in this resource are active."
    - type: uint32_t
      name: "idleCounter"
      desc: "[out] Monotonic counter for total wall time in microseconds that no accelerator assets in this resource are active."
--- #--------------------------------------------------------------------------
type: struct
desc: "Request structure used to query an accelerator resource property"
class: $tSysmanResource
name: $t_accel_property_request_t
members:
    - type: $t_accel_properties_t
      name: "property"
      desc: "[in] The property being requested (one of $t_accel_properties_t)."
    - type: "void*"
      name: "pData"
      desc: |
            [in] Pointer to the data for the property.
            Each property has a corresponding data structure. The type of the data structure is derived from the property enumerator, converted to lower-case with "_t" appended.
    - type: uint32_t
      name: "size"
      desc: "[in] The size of the data structure pointed to by pData."
--- #--------------------------------------------------------------------------
type: function
desc: "Get accelerator resource property data"
class: $tSysmanResource
name: GetAccelProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: uint32_t
      name: count
      desc: "[in] The number of properties in the array pRequest"
    - type: $t_accel_property_request_t*
      name: pRequest
      desc: "[in] Pointer to list of properties and corresponding data storage"
returns:
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The resource is not of type $T_RESOURCE_TYPE_ACCEL"
--- #--------------------------------------------------------------------------
type: enum
desc: "Memory resource types"
class: $tSysmanResource
name: $t_mem_type_t
etors:
    - name: $T_MEM_TYPE_HBM
      value: "0"
      desc: "HBM memory"
    - name: $T_MEM_TYPE_DDR
      desc: "DDR memory"
    - name: $T_MEM_TYPE_SRAM
      desc: "SRAM memory"
    - name: $T_MEM_TYPE_L1
      desc: "L1 cache"
    - name: $T_MEM_TYPE_L3
      desc: "L3 cache"
    - name: $T_MEM_TYPE_GRF
      desc: "Execution unit register file"
    - name: $T_MEM_TYPE_SLM
      desc: "Execution unit shared local memory"
--- #--------------------------------------------------------------------------
type: enum
desc: "Memory retire reasons"
class: $tSysmanResource
name: $t_mem_retire_reason_t
etors:
    - name: $T_MEM_RETIRE_REASON_MULTIPLE_SINGLE_BIT_ERRORS
      value: "0"
      desc: "Memory page has been retired due to multiple single bit ECC errors"
    - name: $T_MEM_RETIRE_REASON_DOUBLE_BIT_ERRORS
      desc: "Memory page has been retired due to one or more double bit ECC errors"
--- #--------------------------------------------------------------------------
type: struct
desc: "Retired page info"
class: $tSysmanResource
name: $t_mem_retire_info_t
members:
    - type: uint64_t
      name: address
      desc: "[out] The address of the page"
    - type: $t_mem_retire_reason_t
      name: reason
      desc: "[out] The reason the page was retired"
--- #--------------------------------------------------------------------------
type: enum
desc: "Memory resource properties"
class: $tSysmanResource
name: $t_mem_properties_t
details:
    - "For every property, there is a corresponding structure used to hold the property data. The type of the data structure is derived from the property enumerator, converted to lower-case with '_t' appended."
    - "Properties can be either read-only (ro), write-only (wo) or read-write (rw)."
    - "Properties can be either static or dynamic. Static properties are set during initialization and will not change during the lifetime of the application. Dynamic properties can change at any time and should be reread."
etors:
    - name: $T_MEM_PROP_TYPE
      value: "0"
      desc: "(ro static) The type of memory covered by this resource (data: $t_mem_prop_type_t)"
    - name: $T_MEM_PROP_ECC_CAP
      desc: "(ro static) Indicates if this memory resource supports ECC/RAS features (data: $t_mem_prop_ecc_cap_t)"
    - name: $T_MEM_PROP_BAD_LIST
      desc: "(ro static) Get the list of pages that have been permanently marked bad (data: $t_mem_prop_bad_list_t)"
    - name: $T_MEM_PROP_UTILIZATION
      desc: "(ro dynamic) Get current allocated/unallocated size (data: $t_mem_prop_utilization_t)"
    - name: $T_MEM_PROP_BANDWIDTH
      desc: "(ro dynamic) Get current read/write bandwidth counters and maximum bandwidth (data: $t_mem_prop_bandwidth_t)"
    - name: $T_MEM_PROP_ECC_ENABLE
      desc: "(rw dynamic) Determine if ECC is enabled/disabled or change this setting (data: $t_mem_prop_ecc_enable_t)"
    - name: $T_MEM_PROP_ECC_POISON
      desc: "(wo dynamic) Poison the memory resource (data: $t_mem_prop_ecc_poison_t)"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_MEM_PROP_TYPE"
class: $tSysmanResource
name: $t_mem_prop_type_t
members:
    - type: $t_mem_type_t
      name: type
      desc: "[out] The memory type"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_MEM_PROP_ECC_CAP"
class: $tSysmanResource
name: $t_mem_prop_ecc_cap_t
members:
    - type: $x_bool_t
      name: "isEccCapable"
      desc: "[out] Indicates if this memory resource supports ECC/RAS features."
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_MEM_PROP_BAD_LIST"
class: $tSysmanResource
name: $t_mem_prop_bad_list_t
members:
    - type: uint32_t*
      name: pCount
      desc: |
            [in,out] The number of elements in pList
            If pCount is zero, then the driver will update the value with the number of elements needed to store the bad list.
            If pCount is less than that required to store the bad list, the driver will update the value with the required number of elements and return an error.
            If pCount is larger than that required to store the bad list, the driver will update the value with the number of elements actually returned.
    - type: $t_mem_retire_info_t*
      name: "pList"
      desc: "[in] Pointer to storage for information about each bad page."
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_MEM_PROP_UTILIZATION"
class: $tSysmanResource
name: $t_mem_prop_utilization_t
members:
    - type: uint64_t
      name: allocated
      desc: "[out] The total allocated bytes"
    - type: uint64_t
      name: unallocated
      desc: "[out] The total unallocated bytes"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_MEM_PROP_BANDWIDTH"
class: $tSysmanResource
name: $t_mem_prop_bandwidth_t
members:
    - type: uint32_t
      name: readCounter
      desc: "[out] Total bytes read from memory"
    - type: uint32_t
      name: writeCounter
      desc: "[out] Total bytes written to memory"
    - type: uint32_t
      name: maxBandwidth
      desc: "[out] Current maximum bandwidth in units of bytes/sec"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_MEM_PROP_ECC_ENABLE"
class: $tSysmanResource
name: $t_mem_prop_ecc_enable_t
members:
    - type: $x_bool_t
      name: "enable"
      desc: "[in] Whether or not ECC is enabled"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_MEM_PROP_ECC_POISON"
class: $tSysmanResource
name: $t_mem_prop_ecc_poison_t
members:
    - type: $x_bool_t
      name: "doPoison"
      desc: "[out] Poison the memory resource."
--- #--------------------------------------------------------------------------
type: struct
desc: "Request structure used to query a memory resource property"
class: $tSysmanResource
name: $t_mem_property_request_t
members:
    - type: $t_mem_properties_t
      name: "property"
      desc: "[in] The property being requested (one of $t_mem_properties_t)."
    - type: "void*"
      name: "pData"
      desc: |
            [in] Pointer to the data for the property.
            Each property has a corresponding data structure. The type of the data structure is derived from the property enumerator, converted to lower-case with "_t" appended.
    - type: uint32_t
      name: "size"
      desc: "[in] The size of the data structure pointed to by pData."
--- #--------------------------------------------------------------------------
type: function
desc: "Get memory resource property data"
class: $tSysmanResource
name: GetMemProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: uint32_t
      name: count
      desc: "[in] The number of properties in the array pRequest"
    - type: $t_mem_property_request_t*
      name: pRequest
      desc: "[in] Pointer to list of properties and corresponding data storage"
returns:
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The resource is not of type $T_RESOURCE_TYPE_MEM"
--- #--------------------------------------------------------------------------
type: function
desc: "Set memory resource property data"
class: $tSysmanResource
name: SetMemProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: uint32_t
      name: count
      desc: "[in] The number of properties in the array pRequest"
    - type: $t_mem_property_request_t*
      name: pRequest
      desc: "[in] Pointer to list of properties and corresponding data storage"
returns:
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The resource is not of type $T_RESOURCE_TYPE_MEM"
--- #--------------------------------------------------------------------------
type: enum
desc: "Link resource types"
class: $tSysmanResource
name: $t_link_type_t
etors:
    - name: $T_LINK_TYPE_PCI
      value: "0"
      desc: "PCI connection"
    - name: $T_LINK_TYPE_PEER_TO_PEER
      desc: "Peer-to-peer connection"
--- #--------------------------------------------------------------------------
type: struct
desc: "Link speed element"
class: $tSysmanResource
name: $t_link_speed_t
members:
    - type: uint32_t
      name: numLanes
      desc: "[out] The number of lanes used by the link"
    - type: uint32_t
      name: speed
      desc: "[out] The frequency of the link in units of MHz"
    - type: uint32_t
      name: bandwidth
      desc: "[out] The maximum bandwidth in units of bytes/sec"
--- #--------------------------------------------------------------------------
type: enum
desc: "Link resource properties"
class: $tSysmanResource
name: $t_link_properties_t
details:
    - "For every property, there is a corresponding structure used to hold the property data. The type of the data structure is derived from the property enumerator, converted to lower-case with '_t' appended."
    - "Properties can be either read-only (ro), write-only (wo) or read-write (rw)."
    - "Properties can be either static or dynamic. Static properties are set during initialization and will not change during the lifetime of the application. Dynamic properties can change at any time and should be reread."
etors:
    - name: $T_LINK_PROP_TYPE
      value: "0"
      desc: "(ro static) The type of link (data: $t_link_prop_type_t)"
    - name: $T_LINK_PROP_BUS_ADDRESS
      desc: "(ro static) The bus address of the link (data: $t_link_prop_bus_address_t)"
    - name: $T_LINK_PROP_PWR_CAP
      desc: "(ro static) Indicates if the link frequency can adjust to control power (data: $t_link_prop_pwr_cap_t)"
    - name: $T_LINK_PROP_AVAIL_SPEEDS
      desc: "(ro static) Available link speeds (data: $t_link_prop_avail_speeds_t)"
    - name: $T_LINK_PROP_MAX_PACKET_SIZE
      desc: "(ro static) Maximum packet size (data: $t_link_prop_max_packet_size_t)"
    - name: $T_LINK_PROP_BANDWIDTH
      desc: "(ro dynamic) Monotonic bandwidth counters (data: $t_link_prop_bandwidth_t)"
    - name: $T_LINK_PROP_SPEED
      desc: "(ro dynamic) Current link speed (data: $t_link_prop_speed_t)"
    - name: $T_LINK_PROP_SPEED_RANGE
      desc: "(wo dynamic) Set the min/max speeds between which the link can operate (data: $t_link_prop_speed_range_t)"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for property $T_LINK_PROP_TYPE"
class: $tSysmanResource
name: $t_link_prop_type_t
members:
    - type: $t_link_type_t
      name: "type"
      desc: "[out] The type of link"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for property $T_LINK_PROP_BUS_ADDRESS"
class: $tSysmanResource
name: $t_link_prop_bus_address_t
members:
    - type: int8_t
      name: "str[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] NULL terminated string value"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_LINK_PROP_PWR_CAP"
class: $tSysmanResource
name: $t_link_prop_pwr_cap_t
members:
    - type: $x_bool_t
      name: "havePwrMgmt"
      desc: "[out] Indicates if the link frequency can adjust to control power."
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_LINK_PROP_AVAIL_SPEEDS"
class: $tSysmanResource
name: $t_link_prop_avail_speeds_t
details:
    - "The list is ordered from the smallest ratio to the largest ratio."
members:
    - type: uint32_t
      name: num
      desc: "[out] The number of elements in pList"
    - type: "const $t_link_speed_t*"
      name: "pList"
      desc: "[out][range(0, num-1)] Pointer to an array of link speeds"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_LINK_PROP_MAX_PACKET_SIZE"
class: $tSysmanResource
name: $t_link_prop_max_packet_size_t
members:
    - type: uint32_t
      name: "maxPacketSize"
      desc: "[out] Maximum packet size in bytes."
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_LINK_PROP_BANDWIDTH"
class: $tSysmanResource
name: $t_link_prop_bandwidth_t
members:
    - type: uint32_t
      name: recvCounter
      desc: "[out] Total bytes received across the link"
    - type: uint32_t
      name: "sendCounter"
      desc: "[out] Total bytes sent across the link"
    - type: uint32_t
      name: "maxBandwidth"
      desc: "[out] Maximum bytes/sec that can be transfered acros the link"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_LINK_PROP_SPEED"
class: $tSysmanResource
name: $t_link_prop_speed_t
members:
    - type: "const $t_link_speed_t*"
      name: "pSpeed"
      desc: "[out] Pointer to the current speed configuration"
--- #--------------------------------------------------------------------------
type: struct
desc: "Data for the property $T_LINK_PROP_SPEED_RANGE"
class: $tSysmanResource
name: $t_link_prop_speed_range_t
members:
    - type: "const $t_link_speed_t*"
      name: "pMinSpeed"
      desc: "[out] Pointer to the min speed configuration (one of those in the array returned by property $T_LINK_PROP_AVAIL_SPEEDS)"
    - type: "const $t_link_speed_t*"
      name: "pMaxSpeed"
      desc: "[out] Pointer to the max speed configuration (one of those in the array returned by property $T_LINK_PROP_AVAIL_SPEEDS)"
--- #--------------------------------------------------------------------------
type: struct
desc: "Request structure used to query a link resource property"
class: $tSysmanResource
name: $t_link_property_request_t
members:
    - type: $t_link_properties_t
      name: "property"
      desc: "[in] The property being requested (one of $t_link_properties_t)."
    - type: "void*"
      name: "pData"
      desc: |
            [in] Pointer to the data for the property.
            Each property has a corresponding data structure. The type of the data structure is derived from the property enumerator, converted to lower-case with "_t" appended.
    - type: uint32_t
      name: "size"
      desc: "[in] The size of the data structure pointed to by pData."
--- #--------------------------------------------------------------------------
type: function
desc: "Get link resource property data"
class: $tSysmanResource
name: GetLinkProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: uint32_t
      name: count
      desc: "[in] The number of properties in the array pRequest"
    - type: $t_link_property_request_t*
      name: pRequest
      desc: "[in] Pointer to list of properties and corresponding data storage"
returns:
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The resource is not of type $T_RESOURCE_TYPE_LINK"
--- #--------------------------------------------------------------------------
type: function
desc: "Set link resource property data"
class: $tSysmanResource
name: SetLinkProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_resource_handle_t
      name: hResource
      desc: "[in] Handle of the resource"
    - type: uint32_t
      name: count
      desc: "[in] The number of properties in the array pRequest"
    - type: $t_link_property_request_t*
      name: pRequest
      desc: "[in] Pointer to list of properties and corresponding data storage"
returns:
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The resource is not of type $T_RESOURCE_TYPE_LINK"
--- #--------------------------------------------------------------------------
type: enum
desc: "Event types"
class: $tSysman
name: $t_sysman_event_type_t
etors:
    - name: $T_SYSMAN_EVENT_TYPE_FREQ_THROTTLED
      value: "0"
      desc: "The frequency is being throttled"
    - name: $T_SYSMAN_EVENT_TYPE_FREQ_POLICY_CHANGED
      desc: "Another API client has modified frequency domain properties"
    - name: $T_SYSMAN_EVENT_TYPE_GPU_ERRORS
      desc: "GPU hardware errors have occurred"
    - name: $T_SYSMAN_EVENT_TYPE_RESET
      desc: "Device reset has occurred"
    - name: $T_SYSMAN_EVENT_TYPE_HANG
      desc: "Device hang has occurred"
    - name: $T_SYSMAN_EVENT_TYPE_MEM_ERRORS
      desc: "ECC correctable errors have occurred in a memory resource"
    - name: $T_SYSMAN_EVENT_TYPE_LINK_ERRORS
      desc: "Link replays have occured in a link resource"
    - name: $T_SYSMAN_EVENT_TYPE_COUNT
      desc: "The number of event types"
--- #--------------------------------------------------------------------------
type: function
desc: "Register to receive events"
class: $tSysman
name: RegisterEvents
details:
    - "This will only register the specified list of events. If other events have been registered, notifications for them will continue."
    - "Applies only to devices in the specified SMI handle."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Handle of the SMI object"
    - type: $t_resource_handle_t
      name: hResource
      desc: |
            [in] Handle of the parent resource. Events from any contained devices will be registered.
            If the handle is $T_INVALID_SYSMAN_RESOURCE_HANDLE, events from all devices will be registered.
    - type: uint32_t
      name: events
      desc: |
            [in] Bitfield of events to register.
            Construct by ORing (1<<$t_sysman_event_type_t).
            Set to (~0) to register to receive all events.
--- #--------------------------------------------------------------------------
type: function
desc: "Unregister events"
class: $tSysman
name: UnregisterEvents
details:
    - "This will only unregister the specified list of events. If other events have been registered, notifications for them will continue."
    - "Applies only to devices in the specified SMI handle."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Handle of the SMI object"
    - type: $t_resource_handle_t
      name: hResource
      desc: |
            [in] Handle of the parent resource. Events from any contained devices will be unregistered.
            If the handle is $T_INVALID_SYSMAN_RESOURCE_HANDLE, events from all devices will be unregistered.
    - type: uint32_t
      name: events
      desc: |
            [in] Bitfield of events to unregister.
            Construct by ORing (1<<$t_sysman_event_type_t).
            Set to (~0) to unregister all events.
--- #--------------------------------------------------------------------------
type: struct
desc: "Event data"
class: $tSysman
name: $t_sysman_event_data_t
members:
    - type: $t_resource_uuid_t
      name: "uuid"
      desc: "[out] The UUID of the resource that generated the event"
    - type: uint32_t
      name: "events"
      desc: "[out] Bitfield of events (1<<$t_sysman_event_type_t) that have been triggered."
--- #--------------------------------------------------------------------------
type: function
desc: "Listen for events"
class: $tSysman
name: ListenEvents
details:
    - "This will only unregister the specified list of events. If other events have been registered, notifications for them will continue."
    - "Applies only to devices in the specified SMI handle."
    - "At most, one event data per device will be returned."
    - "If event data is returned, the corresponding event status is cleared."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Handle of the SMI object"
    - type: $x_bool_t
      name: block
      desc: "[in] If set to true, the call will block the calling thread"
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] Pointer to the number of elements in the array pointed to by pEventData.
            If size is zero, then the driver will update the value with the number of elements needed to retrieve the list of events.
            If size is less than that required to store the list of events, the driver will update the value with the required number of elements and return an error.
            If size is larger than that required to store the list of events, the driver will update the value with the number of elements actually returned.
    - type: "$t_sysman_event_data_t*"
      name: pEventData
      desc: "[in] Pointer to an array of event data"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for SMI of a device group"
name: $tSysman
owner: $tDeviceGroup
members:
    - type: $t_sysman_handle_t
      name: handle
      desc: "[in] handle of SMI object" 
      init: nullptr
    - type: $tDeviceGroup*
      name: pDeviceGroup
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for SMI resource"
name: $tSysmanResource
owner: $tSysman
members:
    - type: $t_resource_handle_t
      name: handle
      desc: "[in] handle of resource" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"