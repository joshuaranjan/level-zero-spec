#
# Copyright (C) 2019 Intel Corporation
#
# SPDX-License-Identifier: MIT
#
# See YaML.md for syntax definition
#
--- #--------------------------------------------------------------------------
type: header
desc: "Intel $OneApi Level-Zero Tool APIs for System Resource Management (Sysman)"
--- #--------------------------------------------------------------------------
type: enum
desc: "API version of Sysman"
class: $tSysman
name: $t_sysman_version_t
etors:
    - name: $T_SYSMAN_VERSION_CURRENT
      value: "$X_MAKE_VERSION( 1, 0 )"
      desc: "version 1.0"
--- #--------------------------------------------------------------------------
type: function
desc: "Get the handle to access Sysman features for a device"
class: $tSysman
name: Get
decl: static
details:
    - "The returned handle is unique."
    - "$t_device_handle_t returned by $xDeviceGetSubDevices() are not support. Only use handles returned by $xDeviceGet(). All resources on sub-devices can be enumerated through the primary device."
params:
    - type: "$t_device_handle_t"
      name: hDevice
      desc: "[in] Handle of the device"
    - type: "$t_sysman_version_t"
      name: version
      desc: "[in] Sysman version that application was built with"
    - type: "$t_sysman_handle_t*"
      name: phSysman
      desc: "[out] Handle for accessing Sysman features"
--- #--------------------------------------------------------------------------
type: macro
desc: "Maximum number of characters in string properties."
name: $T_STRING_PROPERTY_SIZE
value: "64"
--- #--------------------------------------------------------------------------
type: enum
desc: "Types of accelerator engines"
class: $tSysman
name: $t_engine_type_t
etors:
    - name: $T_ENGINE_TYPE_OTHER
      value: "0"
      desc: "Undefined types of accelerators."
    - name: $T_ENGINE_TYPE_COMPUTE
      desc: "Engines that process compute kernels."
    - name: $T_ENGINE_TYPE_3D
      desc: "Engines that process 3D content"
    - name: $T_ENGINE_TYPE_MEDIA
      desc: "Engines that process media workloads"
    - name: $T_ENGINE_TYPE_DMA
      desc: "Engines that copy blocks of data"
--- #--------------------------------------------------------------------------
type: struct
desc: "Device properties"
class: $tSysman
name: $t_sysman_properties_t
members:
    - type: $x_device_properties_t
      name: core
      desc: "[out] Core device properties"
    - type: uint32_t
      name: "numSubdevices"
      desc: "[out] Number of sub-devices"
    - type: int8_t
      name: "serialNumber[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] Manufacturing serial number (NULL terminated string value)"
    - type: int8_t
      name: "boardNumber[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] Manufacturing board number (NULL terminated string value)"
    - type: int8_t
      name: "brandName[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] Brand name of the device (NULL terminated string value)"
    - type: int8_t
      name: "modelName[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] Model name of the device (NULL terminated string value)"
    - type: int8_t
      name: "vendorName[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] Vendor name of the device (NULL terminated string value)"
    - type: int8_t
      name: "driverVersion[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] Installed driver version (NULL terminated string value)"
--- #--------------------------------------------------------------------------
type: function
desc: "Get properties about the device"
class: $tSysman
name: DeviceGetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: $t_sysman_properties_t*
      name: pProperties
      desc: "[in] Structure that will contain information about the device."

--- #--------------------------------------------------------------------------
type: enum
desc: "Scheduler mode"
class: $tSysman
name: $t_sched_mode_t
etors:
    - name: $T_SCHED_MODE_TIMEOUT
      value: "0"
      desc: "Multiple applications or contexts are submitting work to the hardware. When higher priority work arrives, the scheduler attempts to pause the current executing work within some timeout interval, then submits the other work."
    - name: $T_SCHED_MODE_TIMESLICE
      desc: "The scheduler attempts to fairly timeslice hardware execution time between multiple contexts submitting work to the hardware concurrently."
    - name: $T_SCHED_MODE_EXCLUSIVE
      desc: "Any application or context can run indefinitely on the hardware without being preempted or terminated. All pending work for other contexts must wait until the running context completes with no further submitted work."
    - name: $T_SCHED_MODE_COMPUTE_UNIT_DEBUG
      desc: "Scheduler ensures that submission of workloads to the hardware is optimized for compute unit debugging."
--- #--------------------------------------------------------------------------
type: macro
desc: "Disable forward progress guard timeout."
name: $T_SCHED_WATCHDOG_DISABLE
value: "(~(0ULL))"
--- #--------------------------------------------------------------------------
type: struct
desc: "Configuration for timeout scheduler mode ($T_SCHED_MODE_TIMEOUT)"
class: $tSysman
name: $t_sched_timeout_properties_t
members:
    - type: uint64_t
      name: "watchdogTimeout"
      desc: "[in,out] The maximum time in microseconds that the scheduler will wait for a batch of work submitted to a hardware engine to complete or to be preempted so as to run another context. "
      desc: |
            [in,out] The maximum time in microseconds that the scheduler will wait for a batch of work submitted to a hardware engine to complete or to be preempted so as to run another context.
            If this time is exceeded, the hardware engine is reset and the context terminated.
            If set to $T_SCHED_WATCHDOG_DISABLE, a running workload can run as long as it wants without being terminated, but preemption attempts to run other contexts are permitted but not enforced.
--- #--------------------------------------------------------------------------
type: struct
desc: "Configuration for timeslice scheduler mode ($T_SCHED_MODE_TIMESLICE)"
class: $tSysman
name: $t_sched_timeslice_properties_t
members:
    - type: uint64_t
      name: "interval"
      desc: "[in,out] The average interval in microseconds that a submission for a context will run on a hardware engine before being preempted out to run a pending submission for another context."
    - type: uint64_t
      name: "yieldTimeout"
      desc: "[in,out] The maximum time in microseconds that the scheduler will wait to preempt a workload running on an engine before deciding to reset the hardware engine and terminating the associated context."
--- #--------------------------------------------------------------------------
type: function
desc: "Get a list of supported scheduler modes"
class: $tSysman
name: SchedulerGetSupportedModes
details:
    - "If zero modes are returned, control of scheduler modes are not supported."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of scheduler modes.
            if count is zero, then the driver will update the value with the total number of supported modes.
            if count is non-zero, then driver will only retrieve that number of supported scheduler modes.
            if count is larger than the number of supported scheduler modes, then the driver will update the value with the correct number of supported scheduler modes that are returned.
    - type: "$t_sched_mode_t*"
      name: pModes
      desc: "[in,out][optional][range(0, *pCount)] Array of supported scheduler modes"
--- #--------------------------------------------------------------------------
type: function
desc: "Get current scheduler mode"
class: $tSysman
name: SchedulerGetCurrentMode
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: $t_sched_mode_t*
      name: pMode
      desc: "[in] Will contain the current scheduler mode."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Device does not support scheduler modes (check using $tSysmanSchedulerGetSupportedModes())."
--- #--------------------------------------------------------------------------
type: function
desc: "Get scheduler config for mode $T_SCHED_MODE_TIMEOUT"
class: $tSysman
name: SchedulerGetTimeoutModeProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: $x_bool_t
      name: getDefaults
      desc: "[in] If TRUE, the driver will return the system default properties for this mode, otherwise it will return the current properties."
    - type: $t_sched_timeout_properties_t*
      name: pConfig
      desc: "[in] Will contain the current parameters for this mode."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "This scheduler mode is not supported (check using $tSysmanSchedulerGetSupportedModes())."
--- #--------------------------------------------------------------------------
type: function
desc: "Get scheduler config for mode $T_SCHED_MODE_TIMESLICE"
class: $tSysman
name: SchedulerGetTimesliceModeProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: $x_bool_t
      name: getDefaults
      desc: "[in] If TRUE, the driver will return the system default properties for this mode, otherwise it will return the current properties."
    - type: $t_sched_timeslice_properties_t*
      name: pConfig
      desc: "[in] Will contain the current parameters for this mode."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "This scheduler mode is not supported (check using $tSysmanSchedulerGetSupportedModes())."
--- #--------------------------------------------------------------------------
type: function
desc: "Change scheduler mode to $T_SCHED_MODE_TIMEOUT or update scheduler mode parameters if already running in this mode."
class: $tSysman
name: SchedulerSetTimeoutMode
details:
    - "This mode is optimized for multiple applications or contexts submitting work to the hardware. When higher priority work arrives, the scheduler attempts to pause the current executing work within some timeout interval, then submits the other work."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: $t_sched_timeout_properties_t*
      name: pProperties
      desc: "[in] The properties to use when configurating this mode."
    - type: $x_bool_t*
      name: pNeedReboot
      desc: "[in] Will be set to TRUE if a system reboot is needed to apply the new scheduler mode."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "This scheduler mode is not supported (check using $tSysmanSchedulerGetSupportedModes())."
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make this modification."
--- #--------------------------------------------------------------------------
type: function
desc: "Change scheduler mode to $T_SCHED_MODE_TIMESLICE or update scheduler mode parameters if already running in this mode."
class: $tSysman
name: SchedulerSetTimesliceMode
details:
    - "This mode is optimized to provide fair sharing of hardware execution time between multiple contexts submitting work to the hardware concurrently."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: $t_sched_timeslice_properties_t*
      name: pProperties
      desc: "[in] The properties to use when configurating this mode."
    - type: $x_bool_t*
      name: pNeedReboot
      desc: "[in] Will be set to TRUE if a system reboot is needed to apply the new scheduler mode."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "This scheduler mode is not supported (check using $tSysmanSchedulerGetSupportedModes())."
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make this modification."
--- #--------------------------------------------------------------------------
type: function
desc: "Change scheduler mode to $T_SCHED_MODE_EXCLUSIVE"
class: $tSysman
name: SchedulerSetExclusiveMode
details:
    - "This mode is optimized for single application/context use-cases. It permits a context to run indefinitely on the hardware without being preempted or terminated. All pending work for other contexts must wait until the running context completes with no further submitted work."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: $x_bool_t*
      name: pNeedReboot
      desc: "[in] Will be set to TRUE if a system reboot is needed to apply the new scheduler mode."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "This scheduler mode is not supported (check using $tSysmanSchedulerGetSupportedModes())."
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make this modification."
--- #--------------------------------------------------------------------------
type: function
desc: "Change scheduler mode to $T_SCHED_MODE_COMPUTE_UNIT_DEBUG"
class: $tSysman
name: SchedulerSetComputeUnitDebugMode
details:
    - "This mode is optimized for application debug. It ensures that only one command queue can execute work on the hardware at a given time. Work is permitted to run as long as needed without enforcing any scheduler fairness policies."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: $x_bool_t*
      name: pNeedReboot
      desc: "[in] Will be set to TRUE if a system reboot is needed to apply the new scheduler mode."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "This scheduler mode is not supported (check using $tSysmanSchedulerGetSupportedModes())."
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make this modification."

--- #--------------------------------------------------------------------------
type: enum
desc: "Workload performance profiles"
class: $tSysman
name: $t_perf_profile_t
etors:
    - name: $T_PERF_PROFILE_BALANCED
      value: "0"
      desc: "The hardware is configured to strike a balance between compute and memory resources. This is the default profile when the device boots/resets."
    - name: $T_PERF_PROFILE_COMPUTE_BOUNDED
      desc: "The hardware is configured to prioritize performance of the compute units."
    - name: $T_PERF_PROFILE_MEMORY_BOUNDED
      desc: "The hardware is configured to prioritize memory throughput."
--- #--------------------------------------------------------------------------
type: function
desc: "Get a list of supported performance profiles that can be loaded for this device"
class: $tSysman
name: PerformanceProfileGetSupported
details:
    - "The balanced profile $T_PERF_PROFILE_BALANCED is always returned in the array."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t"
      name: supported
      desc: "[in,out] A bit field of (1<<$t_perf_profile_t) profiles that are supported."
--- #--------------------------------------------------------------------------
type: function
desc: "Get current pre-configured performance profile being used by the hardware"
class: $tSysman
name: PerformanceProfileGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: $t_perf_profile_t*
      name: pProfile
      desc: "[in] The performance profile currently loaded."
--- #--------------------------------------------------------------------------
type: function
desc: "Load a pre-configured performance profile"
class: $tSysman
name: PerformanceProfileSet
details:
    - "Performance profiles are not persistent settings. If the device is reset, the device will default back to the balanced profile $T_PERF_PROFILE_BALANCED."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: $t_perf_profile_t
      name: profile
      desc: "[in] The performance profile to load."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "The specified profile is not valid or not supported on this device (use $tSysmanPerformanceProfileGetSupported() to get a list of supported profiles)."
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to change the performance profile of the hardware."
--- #--------------------------------------------------------------------------
type: struct
desc: "Contains information about a process that has an open connection with this device"
class: $tSysman
name: $t_process_state_t
details:
    - "The application can use the process ID to query the OS for the owner and the path to the executable."
members:
    - type: uint32_t
      name: "processId"
      desc: "[out] Host OS process ID."
    - type: int64_t
      name: "memSize"
      desc: "[out] Device memory size in bytes allocated by this process (may not necessarily be resident on the device at the time of reading)."
    - type: int64_t
      name: "engines"
      desc: "[out] Bitfield of accelerator engines being used by this process (or 1<<$t_engine_type_t together)."
--- #--------------------------------------------------------------------------
type: function
desc: "Get information about host processes using the device"
class: $tSysman
name: ProcessesGetState
details:
    - "The number of processes connected to the device is dynamic. This means that between a call to determine the correct value of pCount and the subsequent call, the number of processes may have increased. It is recommended that a large array be passed in so as to avoid receiving the error $X_RESULT_ERROR_INVALID_SIZE."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle for the device"
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of processes.
            if count is zero, then the driver will update the value with the total number of processes currently using the device.
            if count is non-zero but less than the number of processes, the driver will set to the number of processes currently using the device and return the error $X_RESULT_ERROR_INVALID_SIZE.
            if count is larger than the number of processes, then the driver will update the value with the correct number of processes that are returned.
    - type: "$t_process_state_t*"
      name: pProcesses
      desc: "[in,out][optional][range(0, *pCount)] array of process information, one for each process currently using the device"
returns:
    - $X_RESULT_ERROR_INVALID_SIZE:
        - "The provided value of pCount is not big enough to store information about all the processes currently attached to the device."
--- #--------------------------------------------------------------------------
type: function
desc: "Reset device"
class: $tSysman
name: DeviceReset
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle for the device"
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to perform this operation."
--- #--------------------------------------------------------------------------
type: enum
desc: "Device repair status"
class: $tSysman
name: $t_repair_status_t
etors:
    - name: $T_REPAIR_STATUS_UNSUPPORTED
      value: "0"
      desc: "The device does not support in-field repairs."
    - name: $T_REPAIR_STATUS_NOT_PERFORMED
      desc: "The device has never been repaired."
    - name: $T_REPAIR_STATUS_PERFORMED
      desc: "The device has been repaired."
--- #--------------------------------------------------------------------------
type: function
desc: "Find out if the device has been repaired (either by the manufacturer or by running diagnostics)"
class: $tSysman
name: DeviceGetRepairStatus
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle for the device"
    - type: $t_repair_status_t*
      name: pRepairStatus
      desc: "[in] Will indicate if the device was repaired"
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to query this property."
--- #--------------------------------------------------------------------------
type: struct
desc: "PCI address"
class: $tSysman
name: $t_pci_address_t
members:
    - type: uint32_t
      name: "domain"
      desc: "[out] BDF domain"
    - type: uint32_t
      name: "bus"
      desc: "[out] BDF bus"
    - type: uint32_t
      name: "device"
      desc: "[out] BDF device"
    - type: uint32_t
      name: "function"
      desc: "[out] BDF function"
--- #--------------------------------------------------------------------------
type: struct
desc: "PCI speed"
class: $tSysman
name: $t_pci_speed_t
members:
    - type: uint32_t
      name: "gen"
      desc: "[out] The link generation"
    - type: uint32_t
      name: "width"
      desc: "[out] The number of lanes"
    - type: uint64_t
      name: "maxBandwidth"
      desc: "[out] The maximum bandwidth in bytes/sec"
--- #--------------------------------------------------------------------------
type: struct
desc: "Static PCI properties"
class: $tSysman
name: $t_pci_properties_t
members:
    - type: $t_pci_address_t
      name: "address"
      desc: "[out] The BDF address"
    - type: $t_pci_speed_t
      name: "maxSpeed"
      desc: "[out] Fastest port configuration supported by the device."
--- #--------------------------------------------------------------------------
type: enum
desc: "PCI link status"
class: $tSysman
name: $t_pci_link_status_t
etors:
    - name: $T_PCI_LINK_STATUS_GREEN
      value: "0"
      desc: "The link is up and operating as expected"
    - name: $T_PCI_LINK_STATUS_YELLOW
      desc: "The link is up but has quality and/or bandwidth degradation"
    - name: $T_PCI_LINK_STATUS_RED
      desc: "The link has stability issues and preventing workloads making forward progress"
--- #--------------------------------------------------------------------------
type: enum
desc: "PCI link quality degradation reasons"
class: $tSysman
name: $t_pci_link_qual_issues_t
etors:
    - name: $T_PCI_LINK_QUAL_ISSUES_NONE
      value: "0"
      desc: "There are no quality issues with the link at this time"
    - name: $T_PCI_LINK_QUAL_ISSUES_REPLAYS
      value: "$X_BIT( 0 )"
      desc: "An significant number of replays are occurring"
    - name: $T_PCI_LINK_QUAL_ISSUES_SPEED
      value: "$X_BIT( 1 )"
      desc: "There is a degradation in the maximum bandwidth of the link"
--- #--------------------------------------------------------------------------
type: enum
desc: "PCI link stability issues"
class: $tSysman
name: $t_pci_link_stab_issues_t
etors:
    - name: $T_PCI_LINK_STAB_ISSUES_NONE
      value: "0"
      desc: "There are no connection stability issues at this time"
    - name: $T_PCI_LINK_STAB_ISSUES_RETRAINING
      value: "$X_BIT( 0 )"
      desc: "Link retraining has occurred to deal with quality issues"
--- #--------------------------------------------------------------------------
type: struct
desc: "Dynamic PCI state"
class: $tSysman
name: $t_pci_state_t
members:
    - type: $t_pci_link_status_t
      name: "status"
      desc: "[out] The current status of the port"
    - type: $t_pci_link_qual_issues_t
      name: "qualityIssues"
      desc: "[out] If status is $T_PCI_LINK_STATUS_YELLOW, this gives a bitfield of quality issues that have been detected"
    - type: $t_pci_link_stab_issues_t
      name: "stabilityIssues"
      desc: "[out] If status is $T_PCI_LINK_STATUS_RED, this gives a bitfield of reasons for the connection instability"
    - type: $t_pci_speed_t
      name: "speed"
      desc: "[out] The current port configure speed"
--- #--------------------------------------------------------------------------
type: enum
desc: "PCI bar types"
class: $tSysman
name: $t_pci_bar_type_t
etors:
    - name: $T_PCI_BAR_TYPE_CONFIG
      value: "0"
      desc: "PCI configuration space"
    - name: $T_PCI_BAR_TYPE_MMIO
      desc: "MMIO registers"
    - name: $T_PCI_BAR_TYPE_VRAM
      desc: "VRAM aperture"
    - name: $T_PCI_BAR_TYPE_ROM
      desc: "ROM aperture"
    - name: $T_PCI_BAR_TYPE_VGA_IO
      desc: "Legacy VGA IO ports"
    - name: $T_PCI_BAR_TYPE_VGA_MEM
      desc: "Legacy VGA memory"
    - name: $T_PCI_BAR_TYPE_INDIRECT_IO
      desc: "Indirect IO port access"
    - name: $T_PCI_BAR_TYPE_INDIRECT_MEM
      desc: "Indirect memory access"
    - name: $T_PCI_BAR_TYPE_OTHER
      desc: "Other type of PCI bar"
--- #--------------------------------------------------------------------------
type: struct
desc: "Properties of a pci bar"
class: $tSysman
name: $t_pci_bar_properties_t
members:
    - type: $t_pci_bar_type_t
      name: "type"
      desc: "[out] The type of bar"
    - type: uint32_t
      name: "index"
      desc: "[out] The index of the bar"
    - type: uint64_t
      name: "base"
      desc: "[out] Base address of the bar."
    - type: uint64_t
      name: "size"
      desc: "[out] Size of the bar."
--- #--------------------------------------------------------------------------
type: struct
desc: "PCI stats counters"
class: $tSysman
name: $t_pci_stats_t
details:
    - "Percent throughput is calculated by taking two snapshots (s1, s2) and using the equation: %bw = 10^6 * ((s2.rxCounter - s1.rxCounter) + (s2.txCounter - s1.txCounter)) / (s2.maxBandwidth * (s2.timestamp - s1.timestamp))"
    - "Percent replays is calculated by taking two snapshots (s1, s2) and using the equation: %replay = 10^6 * (s2.replayCounter - s1.replayCounter) / (s2.maxBandwidth * (s2.timestamp - s1.timestamp))"
members:
    - type: uint64_t
      name: "timestamp"
      desc: |
            [out] Monotonic timestamp counter in microseconds when the measurement was made.
            No assumption should be made about the absolute value of the timestamp.
            It should only be used to calculate delta time between two snapshots of the same structure.
            Never take the delta of this timestamp with the timestamp from a different structure.
    - type: uint64_t
      name: "replayCounter"
      desc: "[out] Monotonic counter for the number of replay packets"
    - type: uint64_t
      name: "packetCounter"
      desc: "[out] Monotonic counter for the number of packets"
    - type: uint64_t
      name: "rxCounter"
      desc: "[out] Monotonic counter for the number of bytes received"
    - type: uint64_t
      name: "txCounter"
      desc: "[out] Monotonic counter for the number of bytes transmitted (including replays)"
    - type: uint64_t
      name: "maxBandwidth"
      desc: "[out] The maximum bandwidth in bytes/sec under the current configuration"
--- #--------------------------------------------------------------------------
type: function
desc: "Get PCI properties - address, max speed"
class: $tSysman
name: PciGetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: $t_pci_properties_t*
      name: pProperties
      desc: "[in] Will contain the PCI properties."
--- #--------------------------------------------------------------------------
type: function
desc: "Get current PCI state - current speed"
class: $tSysman
name: PciGetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: $t_pci_state_t*
      name: pState
      desc: "[in] Will contain the PCI properties."
--- #--------------------------------------------------------------------------
type: function
desc: "Get information about each configured bar"
class: $tSysman
name: PciGetBars
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of PCI bars.
            if count is zero, then the driver will update the value with the total number of bars.
            if count is non-zero, then driver will only retrieve that number of bars.
            if count is larger than the number of bar, then the driver will update the value with the correct number of bars that are returned.
    - type: "$t_pci_bar_properties_t*"
      name: pProperties
      desc: "[in,out][optional][range(0, *pCount)] array of bar properties"
--- #--------------------------------------------------------------------------
type: function
desc: "Get PCI stats - bandwidth, number of packets, number of replays"
class: $tSysman
name: PciGetStats
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: $t_pci_stats_t*
      name: pStats
      desc: "[in] Will contain a snapshot of the latest stats."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to query this telemetry."
--- #--------------------------------------------------------------------------
type: struct
desc: "Properties related to device power settings"
class: $tSysmanPower
name: $t_power_properties_t
members:
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $x_bool_t
      name: "canControl"
      desc: "[out] Software can change the power limits of this domain assuming the user has permissions."
    - type: $x_bool_t
      name: "isEnergyThresholdSupported"
      desc: "[out] Indicates if this power domain supports the energy threshold event ($T_SYSMAN_EVENT_TYPE_ENERGY_THRESHOLD_CROSSED)."
    - type: uint32_t
      name: "defaultLimit"
      desc: "[out] The factory default TDP power limit of the part in milliwatts."  
    - type: uint32_t
      name: "minLimit"
      desc: "[out] The minimum power limit in milliwatts that can be requested."  
    - type: uint32_t
      name: "maxLimit"
      desc: "[out] The maximum power limit in milliwatts that can be requested."  
--- #--------------------------------------------------------------------------
type: struct
desc: "Energy counter snapshot"
class: $tSysmanPower
name: $t_power_energy_counter_t
details:
    - "Average power is calculated by taking two snapshots (s1, s2) and using the equation: PowerWatts = (s2.energy - s1.energy) / (s2.timestamp - s1.timestamp)"
members:
    - type: uint64_t
      name: "energy"
      desc: "[out] The monotonic energy counter in microjoules."
    - type: uint64_t
      name: "timestamp"
      desc: |
            [out] Microsecond timestamp when energy was captured.
            No assumption should be made about the absolute value of the timestamp.
            It should only be used to calculate delta time between two snapshots of the same structure.
            Never take the delta of this timestamp with the timestamp from a different structure.
--- #--------------------------------------------------------------------------
type: struct
desc: "Sustained power limits"
class: $tSysmanPower
name: $t_power_sustained_limit_t
details:
    - "The power controller (Punit) will throttle the operating frequency if the power averaged over a window (typically seconds) exceeds this limit."
members:
    - type: $x_bool_t
      name: enabled
      desc: "[in,out] indicates if the limit is enabled (true) or ignored (false)"
    - type: uint32_t
      name: power
      desc: "[in,out] power limit in milliwatts"
    - type: uint32_t
      name: interval
      desc: "[in,out] power averaging window (Tau) in milliseconds"
--- #--------------------------------------------------------------------------
type: struct
desc: "Burst power limit"
class: $tSysmanPower
name: $t_power_burst_limit_t
details:
    - "The power controller (Punit) will throttle the operating frequency of the device if the power averaged over a few milliseconds exceeds a limit known as PL2. Typically PL2 > PL1 so that it permits the frequency to burst higher for short periods than would be otherwise permitted by PL1."
members:
    - type: $x_bool_t
      name: enabled
      desc: "[in,out] indicates if the limit is enabled (true) or ignored (false)"
    - type: uint32_t
      name: power
      desc: "[in,out] power limit in milliwatts"
--- #--------------------------------------------------------------------------
type: struct
desc: "Peak power limit"
class: $tSysmanPower
name: $t_power_peak_limit_t
details:
    - "The power controller (Punit) will preemptively throttle the operating frequency of the device when the instantaneous power exceeds this limit. The limit is known as PL4. It expresses the maximum power that can be drawn from the power supply."
    - "If this power limit is removed or set too high, the power supply will generate an interrupt when it detects an overcurrent condition and the power controller will throttle the device frequencies down to min. It is thus better to tune the PL4 value in order to avoid such excursions."
members:
    - type: uint32_t
      name: powerAC
      desc: "[in,out] power limit in milliwatts for the AC power source."
    - type: uint32_t
      name: powerDC
      desc: "[in,out] power limit in milliwatts for the DC power source. This is ignored if the product does not have a battery."
--- #--------------------------------------------------------------------------
type: struct
desc: "Energy threshold"
class: $tSysmanPower
name: $t_energy_threshold_t
details:
    - "."
members:
    - type: $x_bool_t
      name: enable
      desc: "[in,out] Indicates if the energy threshold is enabled."
    - type: double
      name: threshold
      desc: "[in,out] The energy threshold in Joules. Will be 0.0 if no threshold has been set."
    - type: uint32_t
      name: processId
      desc: "[in,out] The host process ID that set the energy threshold. Will be 0xFFFFFFFF if no threshold has been set."
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of power domains"
class: $tSysman
name: PowerGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_pwr_handle_t*"
      name: phPower
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get properties related to a power domain"
class: $tSysmanPower
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_pwr_handle_t
      name: hPower
      desc: "[in] Handle for the component."
    - type: $t_power_properties_t*
      name: pProperties
      desc: "[in] Structure that will contain property data."
--- #--------------------------------------------------------------------------
type: function
desc: "Get energy counter"
class: $tSysmanPower
name: GetEnergyCounter
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_pwr_handle_t
      name: hPower
      desc: "[in] Handle for the component."
    - type: $t_power_energy_counter_t*
      name: pEnergy
      desc: "[in] Will contain the latest snapshot of the energy counter and timestamp when the last counter value was measured."
--- #--------------------------------------------------------------------------
type: function
desc: "Get power limits"
class: $tSysmanPower
name: GetLimits
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_pwr_handle_t
      name: hPower
      desc: "[in] Handle for the component."
    - type: $t_power_sustained_limit_t*
      name: pSustained
      desc: "[in][optional] The sustained power limit."
    - type: $t_power_burst_limit_t*
      name: pBurst
      desc: "[in][optional] The burst power limit."
    - type: $t_power_peak_limit_t*
      name: pPeak
      desc: "[in][optional] The peak power limit."
--- #--------------------------------------------------------------------------
type: function
desc: "Set power limits"
class: $tSysmanPower
name: SetLimits
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_pwr_handle_t
      name: hPower
      desc: "[in] Handle for the component."
    - type: const $t_power_sustained_limit_t*
      name: pSustained
      desc: "[in][optional] The sustained power limit."
    - type: const $t_power_burst_limit_t*
      name: pBurst
      desc: "[in][optional] The burst power limit."
    - type: const $t_power_peak_limit_t*
      name: pPeak
      desc: "[in][optional] The peak power limit."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make these modifications."
    - $X_RESULT_ERROR_NOT_AVAILABLE:
        - "The device is in use, meaning that the GPU is under Over clocking, applying power limits under overclocking is not supported."
--- #--------------------------------------------------------------------------
type: function
desc: "Get energy threshold"
class: $tSysmanPower
name: GetEnergyThreshold
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_pwr_handle_t
      name: hPower
      desc: "[in] Handle for the component."
    - type: $t_energy_threshold_t*
      name: pThreshold
      desc: "[in] Returns information about the energy threshold setting - enabled/energy threshold/process ID."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Energy threshold not supported on this power domain (check $t_power_properties_t.isEnergyThresholdSupported)."
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to request this feature."
--- #--------------------------------------------------------------------------
type: function
desc: "Set energy threshold"
class: $tSysmanPower
name: SetEnergyThreshold
details:
    - "An event $T_SYSMAN_EVENT_TYPE_ENERGY_THRESHOLD_CROSSED will be generated when the delta energy consumed starting from this call exceeds the specified threshold. Use the function $tSysmanEventSetConfig() to start receiving the event."
    - "Only one running process can control the energy threshold at a given time. If another process attempts to change the energy threshold, the error $X_RESULT_ERROR_NOT_AVAILABLE will be returned. The function $tSysmanPowerGetEnergyThreshold() to determine the process ID currently controlling this setting."
    - "Calling this function will remove any pending energy thresholds and start counting from the time of this call."
    - "Once the energy threshold has been reached and the event generated, the threshold is automatically removed. It is up to the application to request a new threshold."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_pwr_handle_t
      name: hPower
      desc: "[in] Handle for the component."
    - type: double
      name: threshold
      desc: "[in] The energy threshold to be set in joules."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Energy threshold not supported on this power domain (check $t_power_properties_t.isEnergyThresholdSupported)."
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to request this feature."
    - $X_RESULT_ERROR_NOT_AVAILABLE:
        - "Another running process has set the energy threshold."
--- #--------------------------------------------------------------------------
type: enum
desc: "Frequency domains."
class: $tSysman
name: $t_freq_domain_t
etors:
    - name: $T_FREQ_DOMAIN_GPU
      value: "0"
      desc: "GPU Core Domain."
    - name: $T_FREQ_DOMAIN_MEMORY
      desc: "Local Memory Domain."
--- #--------------------------------------------------------------------------
type: struct
desc: "Frequency properties"
class: $tSysmanFrequency
name: $t_freq_properties_t
details:
    - "Indicates if this frequency domain can be overclocked (if true, functions such as $tSysmanFrequencyOcSetConfig() are supported)."
    - "The min/max hardware frequencies are specified for non-overclock configurations. For overclock configurations, use $tSysmanFrequencyOcGetConfig() to determine the maximum frequency that can be requested."
    - "If step is non-zero, the available frequencies are (min, min + step, min + 2xstep, ..., max). Otherwise, call $tSysmanFrequencyGetAvailableClocks() to get the list of frequencies that can be requested."
members:
    - type: $t_freq_domain_t
      name: "type"
      desc: "[out] The hardware block that this frequency domain controls (GPU, memory, ...)"
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $x_bool_t
      name: canControl
      desc: "[out] Indicates if software can control the frequency of this domain assuming the user has permissions"
    - type: $x_bool_t
      name: isThrottleEventSupported
      desc: "[out] Indicates if software can register to receive event $T_SYSMAN_EVENT_TYPE_FREQ_THROTTLED"
    - type: double
      name: min
      desc: "[out] The minimum hardware clock frequency in units of MHz"
    - type: double
      name: max
      desc: "[out] The maximum non-overclock hardware clock frequency in units of MHz."
    - type: double
      name: step
      desc: "[out] The minimum step-size for clock frequencies in units of MHz. The hardware will clamp intermediate frequencies to lowest multiplier of this number."
--- #--------------------------------------------------------------------------
type: struct
desc: "Frequency range between which the hardware can operate."
class: $tSysmanFrequency
name: $t_freq_range_t
members:
    - type: double
      name: "min"
      desc: "[in,out] The min frequency in MHz below which hardware frequency management will not request frequencies. Setting to 0 will use the hardware default value."
    - type: double
      name: "max"
      desc: "[in,out] The max frequency in MHz above which hardware frequency management will not request frequencies. Setting to 0 will use the hardware default value."
--- #--------------------------------------------------------------------------
type: enum
desc: "Frequency throttle reasons"
class: $tSysmanFrequency
name: $t_freq_throttle_reasons_t
etors:
    - name: $T_FREQ_THROTTLE_REASONS_NONE
      value: "0"
      desc: "frequency not throttled"
    - name: $T_FREQ_THROTTLE_REASONS_AVE_PWR_CAP
      value: "$X_BIT( 0 )"
      desc: "frequency throttled due to average power excursion (PL1)"
    - name: $T_FREQ_THROTTLE_REASONS_BURST_PWR_CAP
      value: "$X_BIT( 1 )"
      desc: "frequency throttled due to burst power excursion (PL2)"
    - name: $T_FREQ_THROTTLE_REASONS_CURRENT_LIMIT
      value: "$X_BIT( 2 )"
      desc: "frequency throttled due to current excursion (PL4)"
    - name: $T_FREQ_THROTTLE_REASONS_THERMAL_LIMIT
      value: "$X_BIT( 3 )"
      desc: "frequency throttled due to thermal excursion (T > TjMax)"
    - name: $T_FREQ_THROTTLE_REASONS_PSU_ALERT
      value: "$X_BIT( 4 )"
      desc: "frequency throttled due to power supply assertion"
    - name: $T_FREQ_THROTTLE_REASONS_SW_RANGE
      value: "$X_BIT( 5 )"
      desc: "frequency throttled due to software supplied frequency range"
    - name: $T_FREQ_THROTTLE_REASONS_HW_RANGE
      value: "$X_BIT( 6 )"
      desc: "frequency throttled due to a sub block that has a lower frequency range when it receives clocks"
--- #--------------------------------------------------------------------------
type: struct
desc: "Frequency state"
class: $tSysmanFrequency
name: $t_freq_state_t
members:
    - type: double
      name: "request"
      desc: "[out] The current frequency request in MHz."
    - type: double
      name: "tdp"
      desc: "[out] The maximum frequency in MHz supported under the current TDP conditions"
    - type: double
      name: "efficient"
      desc: "[out] The efficient minimum frequency in MHz"
    - type: double
      name: "actual"
      desc: "[out] The resolved frequency in MHz"
    - type: uint32_t
      name: "throttleReasons"
      desc: "[out] The reasons that the frequency is being limited by the hardware (Bitfield of $t_freq_throttle_reasons_t)."
--- #--------------------------------------------------------------------------
type: struct
desc: "Frequency throttle time snapshot"
class: $tSysmanFrequency
name: $t_freq_throttle_time_t
details:
    - "Percent time throttled is calculated by taking two snapshots (s1, s2) and using the equation: %throttled = (s2.throttleTime - s1.throttleTime) / (s2.timestamp - s1.timestamp)"
members:
    - type: uint64_t
      name: "throttleTime"
      desc: "[out] The monotonic counter of time in microseconds that the frequency has been limited by the hardware."
    - type: uint64_t
      name: "timestamp"
      desc: |
            [out] Microsecond timestamp when throttleTime was captured.
            No assumption should be made about the absolute value of the timestamp.
            It should only be used to calculate delta time between two snapshots of the same structure.
            Never take the delta of this timestamp with the timestamp from a different structure.
--- #--------------------------------------------------------------------------
type: enum
desc: "Overclocking modes"
class: $tSysmanFrequency
name: $t_oc_mode_t
etors:
    - name: $T_OC_MODE_OFF
      value: "0"
      desc: "Overclocking if off - hardware is running using factory default voltages/frequencies."
    - name: $T_OC_MODE_OVERRIDE
      desc: "Overclock override mode - In this mode, a fixed user-supplied voltage is applied independent of the frequency request. The maximum permitted frequency can also be increased."
    - name: $T_OC_MODE_INTERPOLATIVE
      desc: "Overclock interpolative mode - In this mode, the voltage/frequency curve can be extended with a new voltage/frequency point that will be interpolated. The existing voltage/frequency points can also be offset (up or down) by a fixed voltage."
--- #--------------------------------------------------------------------------
type: struct
desc: "Overclocking properties"
class: $tSysmanFrequency
name: $t_oc_capabilities_t
details:
    - "Provides all the overclocking capabilities and properties supported by the device for the frequency domain."
members:
    - type: $x_bool_t
      name: isOcSupported
      desc: "[out] Indicates if any overclocking features are supported on this frequency domain."
    - type: double
      name: maxFactoryDefaultFrequency
      desc: "[out] Factory default non-overclock maximum frequency in Mhz."
    - type: double
      name: maxFactoryDefaultVoltage
      desc: "[out] Factory default voltage used for the non-overclock maximum frequency in MHz."
    - type: double
      name: maxOcFrequency
      desc: "[out] Maximum hardware overclocking frequency limit in Mhz."
    - type: double
      name: minOcVoltageOffset
      desc: "[out] The minimum voltage offset that can be applied to the voltage/frequency curve. Note that this number can be negative."
    - type: double
      name: maxOcVoltageOffset
      desc: "[out] The maximum voltage offset that can be applied to the voltage/frequency curve."
    - type: double
      name: maxOcVoltage
      desc: "[out] The maximum overclock voltage that hardware supports."
    - type: $x_bool_t
      name: isTjMaxSupported
      desc: "[out] Indicates if the maximum temperature limit (TjMax) can be changed for this frequency domain."
    - type: $x_bool_t
      name: isIccMaxSupported
      desc: "[out] Indicates if the maximum current (IccMax) can be changed for this frequency domain."
    - type: $x_bool_t
      name: isHighVoltModeCapable
      desc: "[out] Indicates if this frequency domains supports a feature to set very high voltages."
    - type: $x_bool_t
      name: isHighVoltModeEnabled
      desc: "[out] Indicates if very high voltages are permitted on this frequency domain."
--- #--------------------------------------------------------------------------
type: struct
desc: "Overclocking configuration"
class: $tSysmanFrequency
name: $t_oc_config_t
details:
    - "Overclock settings"
members:
    - type: $t_oc_mode_t
      name: mode
      desc: "[in,out] Overclock Mode $t_oc_mode_t."
    - type: double
      name: frequency
      desc: "[in,out] Overclocking Frequency in MHz. This cannot be greater than $t_oc_capabilities_t.maxOcFrequency."
    - type: double
      name: voltageTarget
      desc: "[in,out] Overclock voltage in Volts. This cannot be greater than $t_oc_capabilities_t.maxOcVoltage."
    - type: double
      name: voltageOffset
      desc: "[in,out] This voltage offset is applied to all points on the voltage/frequency curve, include the new overclock voltageTarget. It can be in the range ($t_oc_capabilities_t.minOcVoltageOffset, $t_oc_capabilities_t.maxOcVoltageOffset)."
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of frequency domains"
class: $tSysman
name: FrequencyGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_freq_handle_t*"
      name: phFrequency
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get frequency properties - available frequencies"
class: $tSysmanFrequency
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $t_freq_properties_t*
      name: pProperties
      desc: "[in] The frequency properties for the specified domain."
--- #--------------------------------------------------------------------------
type: function
desc: "Get available non-overclocked hardware clock frequencies for the frequency domain"
class: $tSysmanFrequency
name: GetAvailableClocks
details:
    - "The list of available frequencies is returned in order of slowest to fastest."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of frequencies.
            If count is zero, then the driver will update the value with the total number of frequencies available.
            If count is non-zero, then driver will only retrieve that number of frequencies.
            If count is larger than the number of frequencies available, then the driver will update the value with the correct number of frequencies available.
    - type: "double*"
      name: phFrequency
      desc: "[in,out][optional][range(0, *pCount)] array of frequencies in units of MHz and sorted from slowest to fastest"
--- #--------------------------------------------------------------------------
type: function
desc: "Get current frequency limits"
class: $tSysmanFrequency
name: GetRange
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $t_freq_range_t*
      name: pLimits
      desc: "[in] The range between which the hardware can operate for the specified domain."
--- #--------------------------------------------------------------------------
type: function
desc: "Set frequency range between which the hardware can operate."
class: $tSysmanFrequency
name: SetRange
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: const $t_freq_range_t*
      name: pLimits
      desc: "[in] The limits between which the hardware can operate for the specified domain."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make these modifications."
--- #--------------------------------------------------------------------------
type: function
desc: "Get current frequency state - frequency request, actual frequency, TDP limits"
class: $tSysmanFrequency
name: GetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $t_freq_state_t*
      name: pState
      desc: "[in] Frequency state for the specified domain."
--- #--------------------------------------------------------------------------
type: function
desc: "Get frequency throttle time"
class: $tSysmanFrequency
name: GetThrottleTime
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $t_freq_throttle_time_t*
      name: pThrottleTime
      desc: "[in] Will contain a snapshot of the throttle time counters for the specified domain."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the overclocking capabilities."
class: $tSysmanFrequency
name: OcGetCapabilities
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $t_oc_capabilities_t*
      name: pOcCapabilities
      desc: "[in] Pointer to the capabilities structure $t_oc_capabilities_t."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the current overclocking configuration."
class: $tSysmanFrequency
name: OcGetConfig
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $t_oc_config_t*
      name: pOcConfiguration
      desc: "[in] Pointer to the configuration structure $t_oc_config_t."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Overclocking is not supported on this frequency domain ($t_oc_capabilities_t.isOcSupported)"
--- #--------------------------------------------------------------------------
type: function
desc: "Change the overclocking configuration."
class: $tSysmanFrequency
name: OcSetConfig
details:
    - "If $t_oc_config_t.mode is set to $T_OC_MODE_OFF, overclocking will be turned off and the hardware returned to run with factory voltages/frequencies. Call $tSysmanFrequencyOcSetIccMax() and $tSysmanFrequencyOcSetTjMax() separately with 0.0 to return those settings to factory defaults."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: $t_oc_config_t*
      name: pOcConfiguration
      desc: "[in] Pointer to the configuration structure $t_oc_config_t."
    - type: $x_bool_t*
      name: pDeviceRestart
      desc: "[in,out] This will be set to true if the device needs to be restarted in order to enable the new overclock settings."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Overclocking is not supported on this frequency domain ($t_oc_capabilities_t.isOcSupported)"
        - "The specified voltage and/or frequency overclock settings exceed the hardware values (see $t_oc_capabilities_t.maxOcFrequency, $t_oc_capabilities_t.maxOcVoltage, $t_oc_capabilities_t.minOcVoltageOffset, $t_oc_capabilities_t.maxOcVoltageOffset)."
        - "Requested voltage overclock is very high but $t_oc_capabilities_t.isHighVoltModeEnabled is not enabled for the device."
    - $X_RESULT_ERROR_NOT_AVAILABLE:
        - "Overclocking feature is locked on this frequency domain"
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make these modifications."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the maximum current limit setting."
class: $tSysmanFrequency
name: OcGetIccMax
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: double*
      name: pOcIccMax
      desc: "[in] Will contain the maximum current limit in Amperes on successful return."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Overclocking is not supported on this frequency domain ($t_oc_capabilities_t.isOcSupported)"
        - "Capability $t_oc_capabilities_t.isIccMaxSupported is false for this frequency domain"
--- #--------------------------------------------------------------------------
type: function
desc: "Change the maximum current limit setting."
class: $tSysmanFrequency
name: OcSetIccMax
details:
    - "Setting ocIccMax to 0.0 will return the value to the factory default."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: double
      name: ocIccMax
      desc: "[in] The new maximum current limit in Amperes."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Overclocking is not supported on this frequency domain ($t_oc_capabilities_t.isOcSupported)"
        - "Capability $t_oc_capabilities_t.isIccMaxSupported is false for this frequency domain"
    - $X_RESULT_ERROR_NOT_AVAILABLE:
        - "Overclocking feature is locked on this frequency domain"
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The specified current limit is too low or too high"
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make these modifications."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the maximum temperature limit setting."
class: $tSysmanFrequency
name: OcGetTjMax
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: double*
      name: pOcTjMax
      desc: "[in] Will contain the maximum temperature limit in degrees Celsius on successful return."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Overclocking is not supported on this frequency domain ($t_oc_capabilities_t.isOcSupported)"
--- #--------------------------------------------------------------------------
type: function
desc: "Change the maximum temperature limit setting."
class: $tSysmanFrequency
name: OcSetTjMax
details:
    - "Setting ocTjMax to 0.0 will return the value to the factory default."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_freq_handle_t
      name: hFrequency
      desc: "[in] Handle for the component."
    - type: double
      name: ocTjMax
      desc: "[in] The new maximum temperature limit in degrees Celsius."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Overclocking is not supported on this frequency domain ($t_oc_capabilities_t.isOcSupported)"
        - "Capability $t_oc_capabilities_t.isTjMaxSupported is false for this frequency domain"
    - $X_RESULT_ERROR_NOT_AVAILABLE:
        - "Overclocking feature is locked on this frequency domain"
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "The specified temperature limit is too high"
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make these modifications."

--- #--------------------------------------------------------------------------
type: enum
desc: "Accelerator engine groups"
class: $tSysmanEngine
name: $t_engine_group_t
etors:
    - name: $T_ENGINE_GROUP_ALL
      value: "0"
      desc: "Access information about all engines combined."
    - name: $T_ENGINE_GROUP_COMPUTE_ALL
      desc: "Access information about all compute engines combined."
    - name: $T_ENGINE_GROUP_MEDIA_ALL
      desc: "Access information about all media engines combined."
    - name: $T_ENGINE_GROUP_COPY_ALL
      desc: "Access information about all copy (blitter) engines combined."
--- #--------------------------------------------------------------------------
type: struct
desc: "Engine group properties"
class: $tSysmanEngine
name: $t_engine_properties_t
members:
    - type: $t_engine_group_t
      name: "type"
      desc: "[out] The engine group"
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
--- #--------------------------------------------------------------------------
type: struct
desc: "Engine activity counters"
details:
    - "Percent utilization is calculated by taking two snapshots (s1, s2) and using the equation: %util = (s2.activeTime - s1.activeTime) / (s2.timestamp - s1.timestamp)"
class: $tSysmanEngine
name: $t_engine_stats_t
members:
    - type: uint64_t
      name: "activeTime"
      desc: "[out] Monotonic counter for time in microseconds that this resource is actively running workloads."
    - type: uint64_t
      name: "timestamp"
      desc: |
            [out] Monotonic timestamp counter in microseconds when activeTime counter was sampled.
            No assumption should be made about the absolute value of the timestamp.
            It should only be used to calculate delta time between two snapshots of the same structure.
            Never take the delta of this timestamp with the timestamp from a different structure.
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of engine groups"
class: $tSysman
name: EngineGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_engine_handle_t*"
      name: phEngine
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get engine group properties"
class: $tSysmanEngine
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_engine_handle_t
      name: hEngine
      desc: "[in] Handle for the component."
    - type: $t_engine_properties_t*
      name: pProperties
      desc: "[in] The properties for the specified engine group."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the activity stats for an engine group"
class: $tSysmanEngine
name: GetActivity
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_engine_handle_t
      name: hEngine
      desc: "[in] Handle for the component."
    - type: $t_engine_stats_t*
      name: pStats
      desc: "[in] Will contain a snapshot of the engine group activity counters."

--- #--------------------------------------------------------------------------
type: enum
desc: "Standby hardware components"
class: $tSysmanStandby
name: $t_standby_type_t
etors:
    - name: $T_STANDBY_TYPE_GLOBAL
      value: "0"
      desc: "Control the overall standby policy of the device/sub-device"
--- #--------------------------------------------------------------------------
type: struct
desc: "Standby hardware component properties"
class: $tSysmanStandby
name: $t_standby_properties_t
members:
    - type: $t_standby_type_t
      name: "type"
      desc: "[out] Which standby hardware component this controls"
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
--- #--------------------------------------------------------------------------
type: enum
desc: "Standby promotion modes"
class: $tSysmanStandby
name: $t_standby_promo_mode_t
etors:
    - name: $T_STANDBY_PROMO_MODE_DEFAULT
      value: "0"
      desc: "Best compromise between performance and energy savings."
    - name: $T_STANDBY_PROMO_MODE_NEVER
      desc: "The device/component will never shutdown. This can improve performance but uses more energy."
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of standby controls"
class: $tSysman
name: StandbyGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_standby_handle_t*"
      name: phStandby
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get standby hardware component properties"
class: $tSysmanStandby
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_standby_handle_t
      name: hStandby
      desc: "[in] Handle for the component."
    - type: $t_standby_properties_t*
      name: pProperties
      desc: "[in] Will contain the standby hardware properties."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the current standby promotion mode"
class: $tSysmanStandby
name: GetMode
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_standby_handle_t
      name: hStandby
      desc: "[in] Handle for the component."
    - type: $t_standby_promo_mode_t*
      name: pMode
      desc: "[in] Will contain the current standby mode."
--- #--------------------------------------------------------------------------
type: function
desc: "Set standby promotion mode"
class: $tSysmanStandby
name: SetMode
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_standby_handle_t
      name: hStandby
      desc: "[in] Handle for the component."
    - type: $t_standby_promo_mode_t
      name: mode
      desc: "[in] New standby mode."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make these modifications."
--- #--------------------------------------------------------------------------
type: struct
desc: "Firmware properties"
class: $tSysmanFirmware
name: $t_firmware_properties_t
members:
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $x_bool_t
      name: "canControl"
      desc: "[out] Indicates if software can flash the firmware assuming the user has permissions"
    - type: int8_t
      name: "name[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] NULL terminated string value"
    - type: int8_t
      name: "version[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] NULL terminated string value"
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of firmwares"
class: $tSysman
name: FirmwareGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_firmware_handle_t*"
      name: phFirmware
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get firmware properties"
class: $tSysmanFirmware
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_firmware_handle_t
      name: hFirmware
      desc: "[in] Handle for the component."
    - type: $t_firmware_properties_t*
      name: pProperties
      desc: "[in] Pointer to an array that will hold the properties of the firmware"
--- #--------------------------------------------------------------------------
type: function
desc: "Get firmware checksum"
class: $tSysmanFirmware
name: GetChecksum
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_firmware_handle_t
      name: hFirmware
      desc: "[in] Handle for the component."
    - type: uint32_t*
      name: pChecksum
      desc: "[in] Calculated checksum of the installed firmware."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to perform this operation."
--- #--------------------------------------------------------------------------
type: function
desc: "Flash a new firmware image"
class: $tSysmanFirmware
name: Flash
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_firmware_handle_t
      name: hFirmware
      desc: "[in] Handle for the component."
    - type: void*
      name: pImage
      desc: "[in] Image of the new firmware to flash."
    - type: uint32_t
      name: size
      desc: "[in] Size of the flash image."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to perform this operation."
--- #--------------------------------------------------------------------------
type: enum
desc: "Memory module types"
class: $tSysmanMemory
name: $t_mem_type_t
etors:
    - name: $T_MEM_TYPE_HBM
      value: "0"
      desc: "HBM memory"
    - name: $T_MEM_TYPE_DDR
      desc: "DDR memory"
    - name: $T_MEM_TYPE_SRAM
      desc: "SRAM memory"
    - name: $T_MEM_TYPE_L1
      desc: "L1 cache"
    - name: $T_MEM_TYPE_L3
      desc: "L3 cache"
    - name: $T_MEM_TYPE_GRF
      desc: "Execution unit register file"
    - name: $T_MEM_TYPE_SLM
      desc: "Execution unit shared local memory"
--- #--------------------------------------------------------------------------
type: enum
desc: "Memory health"
class: $tSysmanMemory
name: $t_mem_health_t
etors:
    - name: $T_MEM_HEALTH_OK
      value: "0"
      desc: "All memory channels are healthy"
    - name: $T_MEM_HEALTH_DEGRADED
      desc: "Excessive correctable errors have been detected on one or more channels. Device should be reset."
    - name: $T_MEM_HEALTH_CRITICAL
      desc: "Operating with reduced memory to cover banks with too many uncorrectable errors."
    - name: $T_MEM_HEALTH_REPLACE
      desc: "Device should be replaced due to excessive uncorrectable errors."
--- #--------------------------------------------------------------------------
type: struct
desc: "Memory properties"
class: $tSysmanMemory
name: $t_mem_properties_t
members:
    - type: $t_mem_type_t
      name: type
      desc: "[out] The memory type"
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: uint64_t
      name: physicalSize
      desc: "[out] Physical memory size in bytes"
--- #--------------------------------------------------------------------------
type: struct
desc: "Memory state - health, allocated"
class: $tSysmanMemory
name: $t_mem_state_t
details:
    - "Percent allocation is given by 100 * allocatedSize / maxSize."
    - "Percent free is given by 100 * (maxSize - allocatedSize) / maxSize."
members:
    - type: $t_mem_health_t
      name: health
      desc: "[out] Indicates the health of the memory"
    - type: uint64_t
      name: allocatedSize
      desc: "[out] The total allocated bytes"
    - type: uint64_t
      name: maxSize
      desc: "[out] The total allocatable memory in bytes (can be less than $t_mem_properties_t.physicalSize)"
--- #--------------------------------------------------------------------------
type: struct
desc: "Memory bandwidth"
class: $tSysmanMemory
name: $t_mem_bandwidth_t
details:
    - "Percent bandwidth is calculated by taking two snapshots (s1, s2) and using the equation: %bw = 10^6 * ((s2.readCounter - s1.readCounter) + (s2.writeCounter - s1.writeCounter)) / (s2.maxBandwidth * (s2.timestamp - s1.timestamp))"
members:
    - type: uint64_t
      name: readCounter
      desc: "[out] Total bytes read from memory"
    - type: uint64_t
      name: writeCounter
      desc: "[out] Total bytes written to memory"
    - type: uint64_t
      name: maxBandwidth
      desc: "[out] Current maximum bandwidth in units of bytes/sec"
    - type: uint64_t
      name: timestamp
      desc: |
            [out] The timestamp when these measurements were sampled.
            No assumption should be made about the absolute value of the timestamp.
            It should only be used to calculate delta time between two snapshots of the same structure.
            Never take the delta of this timestamp with the timestamp from a different structure.
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of memory modules"
class: $tSysman
name: MemoryGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_mem_handle_t*"
      name: phMemory
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get memory properties"
class: $tSysmanMemory
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_mem_handle_t
      name: hMemory
      desc: "[in] Handle for the component."
    - type: $t_mem_properties_t*
      name: pProperties
      desc: "[in] Will contain memory properties."
--- #--------------------------------------------------------------------------
type: function
desc: "Get memory state - health, allocated"
class: $tSysmanMemory
name: GetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_mem_handle_t
      name: hMemory
      desc: "[in] Handle for the component."
    - type: $t_mem_state_t*
      name: pState
      desc: "[in] Will contain the current health and allocated memory."
--- #--------------------------------------------------------------------------
type: function
desc: "Get memory bandwidth"
class: $tSysmanMemory
name: GetBandwidth
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_mem_handle_t
      name: hMemory
      desc: "[in] Handle for the component."
    - type: $t_mem_bandwidth_t*
      name: pBandwidth
      desc: "[in] Will contain a snapshot of the bandwidth counters."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to query this telemetry."
--- #--------------------------------------------------------------------------
type: macro
desc: "Maximum Fabric port model string size"
name: $T_MAX_FABRIC_PORT_MODEL_SIZE
value: "256"
--- #--------------------------------------------------------------------------
type: macro
desc: "Maximum fabric port uuid size in bytes"
name: $T_MAX_FABRIC_PORT_UUID_SIZE
value: "72"
--- #--------------------------------------------------------------------------
type: macro
desc: "Maximum size of the buffer that will return information about link types"
name: $T_MAX_FABRIC_LINK_TYPE_SIZE
value: "256"
--- #--------------------------------------------------------------------------
type: enum
desc: "Fabric port status"
class: $tSysmanFabricPort
name: $t_fabric_port_status_t
etors:
    - name: $T_FABRIC_PORT_STATUS_GREEN
      value: "0"
      desc: "The port is up and operating as expected"
    - name: $T_FABRIC_PORT_STATUS_YELLOW
      desc: "The port is up but has quality and/or bandwidth degradation"
    - name: $T_FABRIC_PORT_STATUS_RED
      desc: "Port connection instabilities are preventing workloads making forward progress"
    - name: $T_FABRIC_PORT_STATUS_BLACK
      desc: "The port is configured down"
--- #--------------------------------------------------------------------------
type: enum
desc: "Fabric port quality degradation reasons"
class: $tSysmanFabricPort
name: $t_fabric_port_qual_issues_t
etors:
    - name: $T_FABRIC_PORT_QUAL_ISSUES_NONE
      value: "0"
      desc: "There are no quality issues with the link at this time"
    - name: $T_FABRIC_PORT_QUAL_ISSUES_FEC
      value: "$X_BIT( 0 )"
      desc: "Excessive FEC (forward error correction) are occurring"
    - name: $T_FABRIC_PORT_QUAL_ISSUES_LTP_CRC
      value: "$X_BIT( 1 )"
      desc: "Excessive LTP CRC failure induced replays are occurring"
    - name: $T_FABRIC_PORT_QUAL_ISSUES_SPEED
      value: "$X_BIT( 2 )"
      desc: "There is a degradation in the maximum bandwidth of the port"
--- #--------------------------------------------------------------------------
type: enum
desc: "Fabric port stability issues"
class: $tSysmanFabricPort
name: $t_fabric_port_stab_issues_t
etors:
    - name: $T_FABRIC_PORT_STAB_ISSUES_NONE
      value: "0"
      desc: "There are no connection stability issues at this time"
    - name: $T_FABRIC_PORT_STAB_ISSUES_TOO_MANY_REPLAYS
      value: "$X_BIT( 0 )"
      desc: "Sequential replay failure is inducing link retraining"
    - name: $T_FABRIC_PORT_STAB_ISSUES_NO_CONNECT
      value: "$X_BIT( 1 )"
      desc: "A connection was never able to be established through the link"
    - name: $T_FABRIC_PORT_STAB_ISSUES_FLAPPING
      value: "$X_BIT( 2 )"
      desc: "The port is flapping"
--- #--------------------------------------------------------------------------
type: struct
desc: "Fabric port universal unique id (UUID)"
class: $tSysmanFabricPort
name: $t_fabric_port_uuid_t
members:
    - type: uint8_t
      name: "id[$T_MAX_FABRIC_PORT_UUID_SIZE]"
      desc: "[out] Frabric port universal unique id"
--- #--------------------------------------------------------------------------
type: struct
desc: "Fabric port speed in one direction"
class: $tSysmanFabricPort
name: $t_fabric_port_speed_t
members:
    - type: uint64_t
      name: "bitRate"
      desc: "[out] Bits/sec that the link is operating at"
    - type: uint32_t
      name: "width"
      desc: "[out] The number of lanes"
    - type: uint64_t
      name: "maxBandwidth"
      desc: "[out] The maximum bandwidth in bytes/sec"
--- #--------------------------------------------------------------------------
type: struct
desc: "Fabric port properties"
class: $tSysmanFabricPort
name: $t_fabric_port_properties_t
members:
    - type: int8_t
      name: "model[$T_MAX_FABRIC_PORT_MODEL_SIZE]"
      desc: "[out] Description of port technology"
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the port is located on a sub-device; false means that the port is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $t_fabric_port_uuid_t
      name: "portUuid"
      desc: "[out] The port universal unique id"
    - type: $t_fabric_port_speed_t
      name: "maxRxSpeed"
      desc: "[out] Maximum bandwidth supported by the receive side of the port"
    - type: $t_fabric_port_speed_t
      name: "maxTxSpeed"
      desc: "[out] Maximum bandwidth supported by the transmit side of the port"
--- #--------------------------------------------------------------------------
type: struct
desc: "Provides information about the fabric link attached to a port"
class: $tSysmanFabricPort
name: $t_fabric_link_type_t
members:
    - type: int8_t
      name: "desc[$T_MAX_FABRIC_LINK_TYPE_SIZE]"
      desc: |
            [out] This provides a textural description of a link attached to a port. It contains the following information:
            - Link material
            - Link technology
            - Cable manufacturer
            - Temperature
            - Power
            - Attachment type:
                - Disconnected
                - Hardwired/fixed/etched connector
                - Active copper
                - QSOP
                - AOC
--- #--------------------------------------------------------------------------
type: struct
desc: "Fabric port configuration"
class: $tSysmanFabricPort
name: $t_fabric_port_config_t
members:
    - type: $x_bool_t
      name: "enabled"
      desc: "[in,out] Port is configured up/down"
    - type: $x_bool_t
      name: "beaconing"
      desc: "[in,out] Beaconing is configured on/off"
--- #--------------------------------------------------------------------------
type: struct
desc: "Fabric port state"
class: $tSysmanFabricPort
name: $t_fabric_port_state_t
members:
    - type: $t_fabric_port_status_t
      name: "status"
      desc: "[out] The current status of the port"
    - type: $t_fabric_port_qual_issues_t
      name: "qualityIssues"
      desc: "[out] If status is $T_FABRIC_PORT_STATUS_YELLOW, this gives a bitfield of quality issues that have been detected"
    - type: $t_fabric_port_stab_issues_t
      name: "stabilityIssues"
      desc: "[out] If status is $T_FABRIC_PORT_STATUS_RED, this gives a bitfield of reasons for the connection instability"
    - type: $t_fabric_port_speed_t
      name: "rxSpeed"
      desc: "[out] Current maximum receive speed"
    - type: $t_fabric_port_speed_t
      name: "txSpeed"
      desc: "[out] Current maximum transmit speed"
--- #--------------------------------------------------------------------------
type: struct
desc: "Fabric port throughput"
class: $tSysmanFabricPort
name: $t_fabric_port_throughput_t
details:
    - "Percent throughput is calculated by taking two snapshots (s1, s2) and using the equation:"
    - "    %rx_bandwidth = 10^6 * (s2.rxCounter - s1.rxCounter) / (s2.rxMaxBandwidth * (s2.timestamp - s1.timestamp))"
    - "    %tx_bandwidth = 10^6 * (s2.txCounter - s1.txCounter) / (s2.txMaxBandwidth * (s2.timestamp - s1.timestamp))"
members:
    - type: uint64_t
      name: "timestamp"
      desc: |
            [out] Monotonic timestamp counter in microseconds when the measurement was made.
            No assumption should be made about the absolute value of the timestamp.
            It should only be used to calculate delta time between two snapshots of the same structure.
            Never take the delta of this timestamp with the timestamp from a different structure.
    - type: uint64_t
      name: "rxCounter"
      desc: "[out] Monotonic counter for the number of bytes received"
    - type: uint64_t
      name: "txCounter"
      desc: "[out] Monotonic counter for the number of bytes transmitted"
    - type: uint64_t
      name: "rxMaxBandwidth"
      desc: "[out] The current maximum bandwidth in bytes/sec for receiving packats"
    - type: uint64_t
      name: "txMaxBandwidth"
      desc: "[out] The current maximum bandwidth in bytes/sec for transmitting packets"
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of Fabric ports in a device"
class: $tSysman
name: FabricPortGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_fabric_port_handle_t*"
      name: phPort
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get Fabric port properties"
class: $tSysmanFabricPort
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_fabric_port_handle_t
      name: hPort
      desc: "[in] Handle for the component."
    - type: $t_fabric_port_properties_t*
      name: pProperties
      desc: "[in] Will contain properties of the Fabric Port."
--- #--------------------------------------------------------------------------
type: function
desc: "Get Fabric port link type"
class: $tSysmanFabricPort
name: GetLinkType
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_fabric_port_handle_t
      name: hPort
      desc: "[in] Handle for the component."
    - type: $x_bool_t
      name: verbose
      desc: "[in] Set to true to get a more detailed report."
    - type: $t_fabric_link_type_t*
      name: pLinkType
      desc: "[in] Will contain details about the link attached to the Fabric port."
--- #--------------------------------------------------------------------------
type: function
desc: "Get Fabric port configuration"
class: $tSysmanFabricPort
name: GetConfig
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_fabric_port_handle_t
      name: hPort
      desc: "[in] Handle for the component."
    - type: $t_fabric_port_config_t*
      name: pConfig
      desc: "[in] Will contain configuration of the Fabric Port."
--- #--------------------------------------------------------------------------
type: function
desc: "Set Fabric port configuration"
class: $tSysmanFabricPort
name: SetConfig
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_fabric_port_handle_t
      name: hPort
      desc: "[in] Handle for the component."
    - type: const $t_fabric_port_config_t*
      name: pConfig
      desc: "[in] Contains new configuration of the Fabric Port."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make these modifications."
--- #--------------------------------------------------------------------------
type: function
desc: "Get Fabric port state - status (green/yellow/red/black), reasons for link degradation or instability, current rx/tx speed"
class: $tSysmanFabricPort
name: GetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_fabric_port_handle_t
      name: hPort
      desc: "[in] Handle for the component."
    - type: $t_fabric_port_state_t*
      name: pState
      desc: "[in] Will contain the current state of the Fabric Port"
--- #--------------------------------------------------------------------------
type: function
desc: "Get Fabric port throughput"
class: $tSysmanFabricPort
name: GetThroughput
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_fabric_port_handle_t
      name: hPort
      desc: "[in] Handle for the component."
    - type: $t_fabric_port_throughput_t*
      name: pThroughput
      desc: "[in] Will contain the Fabric port throughput counters and maximum bandwidth."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to query this telemetry."
--- #--------------------------------------------------------------------------
type: enum
desc: "Temperature sensors"
class: $tSysmanTemperature
name: $t_temp_sensors_t
etors:
    - name: $T_TEMP_SENSORS_GLOBAL
      value: "0"
      desc: "The maximum temperature across all device sensors"
    - name: $T_TEMP_SENSORS_GPU
      desc: "The maximum temperature across all sensors in the GPU"
    - name: $T_TEMP_SENSORS_MEMORY
      desc: "The maximum temperature across all sensors in the local memory"
--- #--------------------------------------------------------------------------
type: struct
desc: "Temperature sensor properties"
class: $tSysmanTemperature
name: $t_temp_properties_t
members:
    - type: $t_temp_sensors_t
      name: "type"
      desc: "[out] Which part of the device the temperature sensor measures"
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $x_bool_t
      name: "isCriticalTempSupported"
      desc: "[out] Indicates if the critical temperature event $T_SYSMAN_EVENT_TYPE_TEMP_CRITICAL is supported"
    - type: $x_bool_t
      name: "isThreshold1Supported"
      desc: "[out] Indicates if the temperature threshold 1 event $T_SYSMAN_EVENT_TYPE_TEMP_THRESHOLD1 is supported"
    - type: $x_bool_t
      name: "isThreshold2Supported"
      desc: "[out] Indicates if the temperature threshold 2 event $T_SYSMAN_EVENT_TYPE_TEMP_THRESHOLD2 is supported"
--- #--------------------------------------------------------------------------
type: struct
desc: "Temperature sensor threshold"
class: $tSysmanTemperature
name: $t_temp_threshold_t
members:
    - type: $x_bool_t
      name: "enableLowToHigh"
      desc: "[in,out] Trigger an event when the temperature crosses from below the threshold to above."
    - type: $x_bool_t
      name: "enableHighToLow"
      desc: "[in,out] Trigger an event when the temperature crosses from above the threshold to below."
    - type: double
      name: "threshold"
      desc: "[in,out] The threshold in degrees Celcius."
--- #--------------------------------------------------------------------------
type: struct
desc: "Temperature configuration - which events should be triggered and the trigger conditions."
class: $tSysmanTemperature
name: $t_temp_config_t
members:
    - type: $x_bool_t
      name: "enableCritical"
      desc: "[in,out] Indicates if event $T_SYSMAN_EVENT_TYPE_TEMP_CRITICAL should be triggered by the driver."
    - type: $t_temp_threshold_t
      name: "threshold1"
      desc: "[in,out] Configuration controlling if and when event $T_SYSMAN_EVENT_TYPE_TEMP_THRESHOLD1 should be triggered by the driver."
    - type: $t_temp_threshold_t
      name: "threshold2"
      desc: "[in,out] Configuration controlling if and when event $T_SYSMAN_EVENT_TYPE_TEMP_THRESHOLD2 should be triggered by the driver."
    - type: uint32_t
      name: "processId"
      desc: "[out] Host processId that set this configuration (ignored when setting the configuration)."
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of temperature sensors"
class: $tSysman
name: TemperatureGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_temp_handle_t*"
      name: phTemperature
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get temperature sensor properties"
class: $tSysmanTemperature
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_temp_handle_t
      name: hTemperature
      desc: "[in] Handle for the component."
    - type: $t_temp_properties_t*
      name: pProperties
      desc: "[in] Will contain the temperature sensor properties."
--- #--------------------------------------------------------------------------
type: function
desc: "Get temperature configuration for this sensor - which events are triggered and the trigger conditions"
class: $tSysmanTemperature
name: GetConfig
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_temp_handle_t
      name: hTemperature
      desc: "[in] Handle for the component."
    - type: $t_temp_config_t*
      name: pConfig
      desc: "[in] Returns current configuration."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Temperature thresholds are not supported on this temperature sensor. Generally this is only supported for temperature sensor $T_TEMP_SENSORS_GLOBAL"
        - "One or both of the thresholds is not supported - check $t_temp_properties_t.isThreshold1Supported and $t_temp_properties_t.isThreshold2Supported"
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to request this feature."
--- #--------------------------------------------------------------------------
type: function
desc: "Set temperature configuration for this sensor - indicates which events are triggered and the trigger conditions"
class: $tSysmanTemperature
name: SetConfig
details:
    - "Events $T_SYSMAN_EVENT_TYPE_TEMP_CRITICAL will be triggered when temperature reaches the critical range. Use the function $tSysmanEventSetConfig() to start receiving this event."
    - "Events $T_SYSMAN_EVENT_TYPE_TEMP_THRESHOLD1 and $T_SYSMAN_EVENT_TYPE_TEMP_THRESHOLD2 will be generated when temperature cross the thresholds set using this function. Use the function $tSysmanEventSetConfig() to start receiving these events."
    - "Only one running process can set the temperature configuration at a time. If another process attempts to change the configuration, the error $X_RESULT_ERROR_NOT_AVAILABLE will be returned. The function $tSysmanTemperatureGetConfig() will return the process ID currently controlling these settings."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_temp_handle_t
      name: hTemperature
      desc: "[in] Handle for the component."
    - type: "const $t_temp_config_t*"
      name: pConfig
      desc: "[in] New configuration."
returns:
    - $X_RESULT_ERROR_UNSUPPORTED_FEATURE:
        - "Temperature thresholds are not supported on this temperature sensor. Generally they are only supported for temperature sensor $T_TEMP_SENSORS_GLOBAL"
        - "Enabling the critical temperature event is not supported - check $t_temp_properties_t.isCriticalTempSupported"
        - "One or both of the thresholds is not supported - check $t_temp_properties_t.isThreshold1Supported and $t_temp_properties_t.isThreshold2Supported"
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to request this feature."
    - $X_RESULT_ERROR_NOT_AVAILABLE:
        - "Another running process is controlling these settings."
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "One or both the thresholds is above TjMax (see $tSysmanFrequencyOcGetTjMax()). Temperature thresholds must be below this value."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the temperature from a specified sensor"
class: $tSysmanTemperature
name: GetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_temp_handle_t
      name: hTemperature
      desc: "[in] Handle for the component."
    - type: double*
      name: pTemperature
      desc: "[in] Will contain the temperature read from the specified sensor in degrees Celcius."
--- #--------------------------------------------------------------------------
type: enum
desc: "PSU voltage status"
class: $tSysmanPsu
name: $t_psu_voltage_status_t
etors:
    - name: $T_PSU_VOLTAGE_STATUS_NORMAL
      value: "0"
      desc: "No unusual voltages have been detected"
    - name: $T_PSU_VOLTAGE_STATUS_OVER
      desc: "Over-voltage has occurred"
    - name: $T_PSU_VOLTAGE_STATUS_UNDER
      desc: "Under-voltage has occurred"
--- #--------------------------------------------------------------------------
type: struct
desc: "Static properties of the power supply"
class: $tSysmanPsu
name: $t_psu_properties_t
members:
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $x_bool_t
      name: "haveFan"
      desc: "[out] True if the power supply has a fan"
    - type: uint32_t
      name: "ampLimit"
      desc: "[out] The maximum electrical current in amperes that can be drawn"
--- #--------------------------------------------------------------------------
type: struct
desc: "Dynamic state of the power supply"
class: $tSysmanPsu
name: $t_psu_state_t
members:
    - type: $t_psu_voltage_status_t
      name: "voltStatus"
      desc: "[out] The current PSU voltage status"
    - type: $x_bool_t
      name: "fanFailed"
      desc: "[out] Indicates if the fan has failed"
    - type: uint32_t
      name: "temperature"
      desc: "[out] Read the current heatsink temperature in degrees Celsius."
    - type: uint32_t
      name: "current"
      desc: "[out] The amps being drawn in amperes"
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of power supplies"
class: $tSysman
name: PsuGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_psu_handle_t*"
      name: phPsu
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get power supply properties"
class: $tSysmanPsu
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_psu_handle_t
      name: hPsu
      desc: "[in] Handle for the component."
    - type: $t_psu_properties_t*
      name: pProperties
      desc: "[in] Will contain the properties of the power supply."
--- #--------------------------------------------------------------------------
type: function
desc: "Get current power supply state"
class: $tSysmanPsu
name: GetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_psu_handle_t
      name: hPsu
      desc: "[in] Handle for the component."
    - type: $t_psu_state_t*
      name: pState
      desc: "[in] Will contain the current state of the power supply."

--- #--------------------------------------------------------------------------
type: enum
desc: "Fan resource speed mode"
class: $tSysmanFan
name: $t_fan_speed_mode_t
etors:
    - name: $T_FAN_SPEED_MODE_DEFAULT
      value: "0"
      desc: "The fan speed is operating using the hardware default settings"
    - name: $T_FAN_SPEED_MODE_FIXED
      desc: "The fan speed is currently set to a fixed value"
    - name: $T_FAN_SPEED_MODE_TABLE
      desc: "The fan speed is currently controlled dynamically by hardware based on a temp/speed table"
--- #--------------------------------------------------------------------------
type: enum
desc: "Fan speed units"
class: $tSysmanFan
name: $t_fan_speed_units_t
etors:
    - name: $T_FAN_SPEED_UNITS_RPM
      value: "0"
      desc: "The fan speed is in units of revolutions per minute (rpm)"
    - name: $T_FAN_SPEED_UNITS_PERCENT
      desc: "The fan speed is a percentage of the maximum speed of the fan"
--- #--------------------------------------------------------------------------
type: struct
desc: "Fan temperature/speed pair"
class: $tSysmanFan
name: $t_fan_temp_speed_t
members:
    - type: uint32_t
      name: "temperature"
      desc: "[in,out] Temperature in degrees Celsius."
    - type: uint32_t
      name: "speed"
      desc: "[in,out] The speed of the fan"
    - type: $t_fan_speed_units_t
      name: "units"
      desc: "[in,out] The units of the member speed"
--- #--------------------------------------------------------------------------
type: macro
desc: "Maximum number of fan temperature/speed pairs in the fan speed table."
name: $T_FAN_TEMP_SPEED_PAIR_COUNT
value: "32"
--- #--------------------------------------------------------------------------
type: struct
desc: "Fan properties"
class: $tSysmanFan
name: $t_fan_properties_t
members:
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $x_bool_t
      name: "canControl"
      desc: "[out] Indicates if software can control the fan speed assuming the user has permissions"
    - type: uint32_t
      name: "maxSpeed"
      desc: "[out] The maximum RPM of the fan"
    - type: uint32_t
      name: "maxPoints"
      desc: "[out] The maximum number of points in the fan temp/speed table"
--- #--------------------------------------------------------------------------
type: struct
desc: "Fan configuration"
class: $tSysmanFan
name: $t_fan_config_t
members:
    - type: $t_fan_speed_mode_t
      name: "mode"
      desc: "[in,out] The fan speed mode (fixed, temp-speed table)"
    - type: uint32_t
      name: "speed"
      desc: "[in,out] The fixed fan speed setting"
    - type: $t_fan_speed_units_t
      name: "speedUnits"
      desc: "[in,out] The units of the fixed fan speed setting"
    - type: uint32_t
      name: "numPoints"
      desc: "[in,out] The number of valid points in the fan speed table"
    - type: $t_fan_temp_speed_t
      name: "table[$T_FAN_TEMP_SPEED_PAIR_COUNT]"
      desc: "[in,out] Array of temperature/fan speed pairs"
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of fans"
class: $tSysman
name: FanGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_fan_handle_t*"
      name: phFan
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get fan properties"
class: $tSysmanFan
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_fan_handle_t
      name: hFan
      desc: "[in] Handle for the component."
    - type: $t_fan_properties_t*
      name: pProperties
      desc: "[in] Will contain the properties of the fan."
--- #--------------------------------------------------------------------------
type: function
desc: "Get current fan configuration"
class: $tSysmanFan
name: GetConfig
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_fan_handle_t
      name: hFan
      desc: "[in] Handle for the component."
    - type: $t_fan_config_t*
      name: pConfig
      desc: "[in] Will contain the current configuration of the fan."
--- #--------------------------------------------------------------------------
type: function
desc: "Set fan configuration"
class: $tSysmanFan
name: SetConfig
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_fan_handle_t
      name: hFan
      desc: "[in] Handle for the component."
    - type: const $t_fan_config_t*
      name: pConfig
      desc: "[in] New fan configuration."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make these modifications."
--- #--------------------------------------------------------------------------
type: function
desc: "Get current state of a fan - current mode and speed"
class: $tSysmanFan
name: GetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_fan_handle_t
      name: hFan
      desc: "[in] Handle for the component."
    - type: $t_fan_speed_units_t
      name: units
      desc: "[in] The units in which the fan speed should be returned."
    - type: uint32_t*
      name: pSpeed
      desc: "[in] Will contain the current speed of the fan in the units requested."

--- #--------------------------------------------------------------------------
type: struct
desc: "LED properties"
class: $tSysmanLed
name: $t_led_properties_t
members:
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: $x_bool_t
      name: "canControl"
      desc: "[out] Indicates if software can control the LED assuming the user has permissions"
    - type: $x_bool_t
      name: "haveRGB"
      desc: "[out] Indicates if the LED is RGB capable"
--- #--------------------------------------------------------------------------
type: struct
desc: "LED state"
class: $tSysmanLed
name: $t_led_state_t
members:
    - type: $x_bool_t
      name: isOn
      desc: "[in,out] Indicates if the LED is on or off"
    - type: uint8_t
      name: "red"
      desc: "[in,out][range(0, 255)] The LED red value"
    - type: uint8_t
      name: "green"
      desc: "[in,out][range(0, 255)] The LED green value"
    - type: uint8_t
      name: "blue"
      desc: "[in,out][range(0, 255)] The LED blue value"
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of LEDs"
class: $tSysman
name: LedGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_led_handle_t*"
      name: phLed
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get LED properties"
class: $tSysmanLed
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_led_handle_t
      name: hLed
      desc: "[in] Handle for the component."
    - type: $t_led_properties_t*
      name: pProperties
      desc: "[in] Will contain the properties of the LED."
--- #--------------------------------------------------------------------------
type: function
desc: "Get current state of a LED - on/off, color"
class: $tSysmanLed
name: GetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_led_handle_t
      name: hLed
      desc: "[in] Handle for the component."
    - type: $t_led_state_t*
      name: pState
      desc: "[in] Will contain the current state of the LED."
--- #--------------------------------------------------------------------------
type: function
desc: "Set state of a LED - on/off, color"
class: $tSysmanLed
name: SetState
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_led_handle_t
      name: hLed
      desc: "[in] Handle for the component."
    - type: const $t_led_state_t*
      name: pState
      desc: "[in] New state of the LED."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to make these modifications."
--- #--------------------------------------------------------------------------
type: enum
desc: "RAS error type"
class: $tSysmanRas
name: $t_ras_error_type_t
etors:
    - name: $T_RAS_ERROR_TYPE_CORRECTABLE
      value: "0"
      desc: "Errors were corrected by hardware"
    - name: $T_RAS_ERROR_TYPE_UNCORRECTABLE
      desc: "Error were not corrected"
--- #--------------------------------------------------------------------------
type: struct
desc: "RAS properties"
class: $tSysmanRas
name: $t_ras_properties_t
members:
    - type: $t_ras_error_type_t
      name: "type"
      desc: "[out] The type of RAS error"
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
--- #--------------------------------------------------------------------------
type: struct
desc: "RAS error details"
class: $tSysmanRas
name: $t_ras_details_t
members:
    - type: uint64_t
      name: "numResets"
      desc: "[out] The number of device resets that have taken place"
    - type: uint64_t
      name: "numProgrammingErrors"
      desc: "[out] The number of hardware exceptions generated by the way workloads have programmed the hardware"
    - type: uint64_t
      name: "numDriverErrors"
      desc: "[out] The number of low level driver communication errors have occurred"
    - type: uint64_t
      name: "numComputeErrors"
      desc: "[out] The number of errors that have occurred in the compute accelerator hardware"
    - type: uint64_t
      name: "numNonComputeErrors"
      desc: "[out] The number of errors that have occurred in the fixed-function accelerator hardware"
    - type: uint64_t
      name: "numCacheErrors"
      desc: "[out] The number of errors that have occurred in caches (L1/L3/register file/shared local memory/sampler)"
    - type: uint64_t
      name: "numDisplayErrors"
      desc: "[out] The number of errors that have occurred in the display"
--- #--------------------------------------------------------------------------
type: struct
desc: "RAS error configuration - thresholds used for triggering RAS events ($T_SYSMAN_EVENT_TYPE_RAS_CORRECTABLE_ERRORS, $T_SYSMAN_EVENT_TYPE_RAS_UNCORRECTABLE_ERRORS)"
class: $tSysmanRas
name: $t_ras_config_t
details:
    - "The driver maintains a total counter which is updated every time a hardware block covered by the corresponding RAS error set notifies that an error has occurred. When this total count goes above the totalThreshold specified below, a RAS event is triggered."
    - "The driver also maintains a counter for each category of RAS error (see $t_ras_details_t for a breakdown). Each time a hardware block of that category notifies that an error has occurred, that corresponding category counter is updated. When it goes above the threshold specified in detailedThresholds, a RAS event is triggered."
members:
    - type: uint64_t
      name: "totalThreshold"
      desc: "[in,out] If the total RAS errors exceeds this threshold, the event will be triggered. A value of 0ULL disables triggering the event based on the total counter."
    - type: $t_ras_details_t
      name: detailedThresholds
      desc: "[in,out] If the RAS errors for each category exceed the threshold for that category, the event will be triggered. A value of 0ULL will disable an event being triggered for that category."
    - type: uint32_t
      name: "processId"
      desc: "[out] Host processId that set this configuration (ignored when setting the configuration)."
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of all RAS error sets on a device"
class: $tSysman
name: RasGet
details:
    - "A RAS error set is a collection of RAS error counters of a given type (correctable/uncorrectable) from hardware blocks contained within a sub-device or within the device."
    - "A device without sub-devices will typically return two handles, one for correctable errors sets and one for uncorrectable error sets."
    - "A device with sub-devices will return RAS error sets for each sub-device and possibly RAS error sets for hardware blocks outside the sub-devices."
    - "If the function completes successfully but pCount is set to 0, RAS features are not available/enabled on this device."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_ras_handle_t*"
      name: phRas
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get RAS properties of a given RAS error set - this enables discovery of the type of RAS error set (correctable/uncorrectable) and if located on a sub-device"
class: $tSysmanRas
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_ras_handle_t
      name: hRas
      desc: "[in] Handle for the component."
    - type: $t_ras_properties_t*
      name: pProperties
      desc: "[in] Structure describing RAS properties"
--- #--------------------------------------------------------------------------
type: function
desc: "Get RAS error thresholds that control when RAS events are generated"
class: $tSysmanRas
name: GetConfig
details:
    - "The driver maintains counters for all RAS error sets and error categories. Events are generated when errors occur. The configuration enables setting thresholds to limit when events are sent."
    - "When a particular RAS correctable error counter exceeds the configured threshold, the event $T_SYSMAN_EVENT_TYPE_RAS_CORRECTABLE_ERRORS will be triggered."
    - "When a particular RAS uncorrectable error counter exceeds the configured threshold, the event $T_SYSMAN_EVENT_TYPE_RAS_UNCORRECTABLE_ERRORS will be triggered."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_ras_handle_t
      name: hRas
      desc: "[in] Handle for the component."
    - type: "$t_ras_config_t*"
      name: pConfig
      desc: "[in] Will be populed with the current RAS configuration - thresholds used to trigger events"
--- #--------------------------------------------------------------------------
type: function
desc: "Set RAS error thresholds that control when RAS events are generated"
class: $tSysmanRas
name: SetConfig
details:
    - "The driver maintains counters for all RAS error sets and error categories. Events are generated when errors occur. The configuration enables setting thresholds to limit when events are sent."
    - "When a particular RAS correctable error counter exceeds the specified threshold, the event $T_SYSMAN_EVENT_TYPE_RAS_CORRECTABLE_ERRORS will be generated."
    - "When a particular RAS uncorrectable error counter exceeds the specified threshold, the event $T_SYSMAN_EVENT_TYPE_RAS_UNCORRECTABLE_ERRORS will be generated."
    - "Call $tSysmanRasGetState() and set the clear flag to true to restart event generation once counters have exceeded thresholds."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_ras_handle_t
      name: hRas
      desc: "[in] Handle for the component."
    - type: "const $t_ras_config_t*"
      name: pConfig
      desc: "[in] Change the RAS configuration - thresholds used to trigger events"
returns:
    - $X_RESULT_ERROR_NOT_AVAILABLE:
        - "Another running process is controlling these settings."
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "Don't have permissions to set thresholds."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the current value of RAS error counters for a particular error set"
class: $tSysmanRas
name: GetState
details:
    - "Clearing errors will affect other threads/applications - the counter values will start from zero."
    - "Clearing errors requires write permissions."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_ras_handle_t
      name: hRas
      desc: "[in] Handle for the component."
    - type: $x_bool_t
      name: clear
      desc: "[in] Set to 1 to clear the counters of this type"
    - type: uint64_t*
      name: pTotalErrors
      desc: "[in] The number total number of errors that have occurred"
    - type: $t_ras_details_t*
      name: pDetails
      desc: "[in][optional] Breakdown of where errors have occurred"
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "Don't have permissions to clear error counters."
--- #--------------------------------------------------------------------------
type: enum
desc: "Event types"
class: $tSysman
name: $t_sysman_event_type_t
etors:
    - name: $T_SYSMAN_EVENT_TYPE_NONE
      value: "0"
      desc: "Specifies no events"
    - name: $T_SYSMAN_EVENT_TYPE_DEVICE_RESET
      value: "$X_BIT( 0 )"
      desc: "Event is triggered when the driver is going to reset the device"
    - name: $T_SYSMAN_EVENT_TYPE_DEVICE_SLEEP_STATE_ENTER
      value: "$X_BIT( 1 )"
      desc: "Event is triggered when the driver is about to put the device into a deep sleep state"
    - name: $T_SYSMAN_EVENT_TYPE_DEVICE_SLEEP_STATE_EXIT
      value: "$X_BIT( 2 )"
      desc: "Event is triggered when the driver is waking the device up from a deep sleep state"
    - name: $T_SYSMAN_EVENT_TYPE_FREQ_THROTTLED
      value: "$X_BIT( 3 )"
      desc: "Event is triggered when the frequency starts being throttled"
    - name: $T_SYSMAN_EVENT_TYPE_ENERGY_THRESHOLD_CROSSED
      value: "$X_BIT( 4 )"
      desc: "Event is triggered when the energy consumption threshold is reached (use $tSysmanPowerSetEnergyThreshold() to configure)."
    - name: $T_SYSMAN_EVENT_TYPE_TEMP_CRITICAL
      value: "$X_BIT( 5 )"
      desc: "Event is triggered when the critical temperature is reached (use $tSysmanTemperatureSetConfig() to configure - disabled by default)."
    - name: $T_SYSMAN_EVENT_TYPE_TEMP_THRESHOLD1
      value: "$X_BIT( 6 )"
      desc: "Event is triggered when the temperature crosses threshold 1 (use $tSysmanTemperatureSetConfig() to configure - disabled by default)."
    - name: $T_SYSMAN_EVENT_TYPE_TEMP_THRESHOLD2
      value: "$X_BIT( 7 )"
      desc: "Event is triggered when the temperature crosses threshold 2 (use $tSysmanTemperatureSetConfig() to configure - disabled by default)."
    - name: $T_SYSMAN_EVENT_TYPE_MEM_HEALTH
      value: "$X_BIT( 8 )"
      desc: "Event is triggered when the health of device memory changes."
    - name: $T_SYSMAN_EVENT_TYPE_FABRIC_PORT_HEALTH
      value: "$X_BIT( 9 )"
      desc: "Event is triggered when the health of fabric ports change."
    - name: $T_SYSMAN_EVENT_TYPE_PCI_LINK_HEALTH
      value: "$X_BIT( 10 )"
      desc: "Event is triggered when the health of the PCI link changes."
    - name: $T_SYSMAN_EVENT_TYPE_RAS_CORRECTABLE_ERRORS
      value: "$X_BIT( 11 )"
      desc: "Event is triggered when accelerator RAS correctable errors cross thresholds (use $tSysmanRasSetConfig() to configure - disabled by default)."
    - name: $T_SYSMAN_EVENT_TYPE_RAS_UNCORRECTABLE_ERRORS
      value: "$X_BIT( 12 )"
      desc: "Event is triggered when accelerator RAS uncorrectable errors cross thresholds (use $tSysmanRasSetConfig() to configure - disabled by default)."
    - name: $T_SYSMAN_EVENT_TYPE_ALL
      value: "0x0FFF"
      desc: "Specifies all events"
--- #--------------------------------------------------------------------------
type: struct
desc: "Event configuration for a device"
class: $tSysmanEvent
name: $t_event_config_t
members:
    - type: uint32_t
      name: "registered"
      desc: "[in,out] List of registered events (Bitfield of events $t_sysman_event_type_t). $T_SYSMAN_EVENT_TYPE_NONE indicates there are no registered events. $T_SYSMAN_EVENT_TYPE_ALL indicates that all events are registered."
--- #--------------------------------------------------------------------------
type: function
desc: "Get the event handle for the specified device"
class: $tSysman
name: EventGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle for the device"
    - type: "$t_sysman_event_handle_t*"
      name: phEvent
      desc: "[out] The event handle for the specified device."
--- #--------------------------------------------------------------------------
type: function
desc: "Find out which events are currently registered on the specified device event handler"
class: $tSysmanEvent
name: GetConfig
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_event_handle_t
      name: hEvent
      desc: "[in] The event handle for the device"
    - type: "$t_event_config_t*"
      name: pConfig
      desc: "[in] Will contain the current event configuration (list of registered events)."
--- #--------------------------------------------------------------------------
type: function
desc: "Set a new event configuration (list of registered events) on the specified device event handler"
class: $tSysmanEvent
name: SetConfig
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_event_handle_t
      name: hEvent
      desc: "[in] The event handle for the device"
    - type: "const $t_event_config_t*"
      name: pConfig
      desc: "[in] New event configuration (list of registered events)."
--- #--------------------------------------------------------------------------
type: function
desc: "Get events that have been triggered for a specific device"
class: $tSysmanEvent
name: GetState
details:
    - "If events have occurred on the specified device event handle, they are returned and the corresponding event status is cleared if the argument clear = true."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_event_handle_t
      name: hEvent
      desc: "[in] The event handle for the device."
    - type: $x_bool_t
      name: clear
      desc: "[in] Indicates if the event list for this device should be cleared."
    - type: "uint32_t*"
      name: pEvents
      desc: "[in] Bitfield of events $t_sysman_event_type_t that have been triggered by this device."
--- #--------------------------------------------------------------------------
type: macro
desc: "Don't wait - just check if there are any new events"
name: $T_EVENT_WAIT_NONE
value: "0x0"
--- #--------------------------------------------------------------------------
type: macro
desc: "Wait infinitely for events to arrive."
name: $T_EVENT_WAIT_INFINITE
value: "0xFFFFFFFF"
--- #--------------------------------------------------------------------------
type: function
desc: "Wait for the specified list of event handles to receive any registered events"
class: $tSysmanEvent
decl: static
name: Listen
details:
    - "If previous events arrived and were not cleared using $tSysmanEventGetState(), this call will return immediately."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $x_driver_handle_t
      name: hDriver
      desc: "[in] handle of the driver instance"
    - type: uint32_t
      name: timeout
      desc: "[in] How long to wait in milliseconds for events to arrive. Set to $T_EVENT_WAIT_NONE will check status and return immediately. Set to $T_EVENT_WAIT_INFINITE to block until events arrive."
    - type: uint32_t
      name: count
      desc: "[in] Number of handles in phEvents"
    - type: "$t_sysman_event_handle_t*"
      name: phEvents
      desc: "[in][range(0, count)] Handle of events that should be listened to"
    - type: "uint32_t*"
      name: pEvents
      desc: "[in] Bitfield of events $t_sysman_event_type_t that have been triggered by any of the supplied event handles. If timeout is not $T_EVENT_WAIT_INFINITE and this value is $T_SYSMAN_EVENT_TYPE_NONE, then a timeout has occurred."
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to listen to events."
    - $X_RESULT_ERROR_INVALID_ARGUMENT:
        - "One or more of the supplied event handles are for devices that belong to a different driver handle."
--- #--------------------------------------------------------------------------
type: enum
desc: "Diagnostic test suite type"
class: $tSysmanDiagnostics
name: $t_diag_type_t
etors:
    - name: $T_DIAG_TYPE_SCAN
      value: "0"
      desc: "Run SCAN diagnostics"
    - name: $T_DIAG_TYPE_ARRAY
      desc: "Run Array diagnostics"
--- #--------------------------------------------------------------------------
type: enum
desc: "Diagnostic results"
class: $tSysmanDiagnostics
name: $t_diag_result_t
etors:
    - name: $T_DIAG_RESULT_NO_ERRORS
      value: "0"
      desc: "Diagnostic completed without finding errors to repair"
    - name: $T_DIAG_RESULT_ABORT
      desc: "Diagnostic had problems running tests"
    - name: $T_DIAG_RESULT_FAIL_CANT_REPAIR
      desc: "Diagnostic had problems setting up repairs"
    - name: $T_DIAG_RESULT_REBOOT_FOR_REPAIR
      desc: "Diagnostics found errors, setup for repair and reboot is required to complete the process"
--- #--------------------------------------------------------------------------
type: macro
desc: "Diagnostic test index to use for the very first test."
name: $T_DIAG_FIRST_TEST_INDEX
value: "0x0"
--- #--------------------------------------------------------------------------
type: macro
desc: "Diagnostic test index to use for the very last test."
name: $T_DIAG_LAST_TEST_INDEX
value: "0xFFFFFFFF"
--- #--------------------------------------------------------------------------
type: struct
desc: "Diagnostic test"
class: $tSysmanDiagnostics
name: $t_diag_test_t
members:
    - type: uint32_t
      name: "index"
      desc: "[out] Index of the test"
    - type: char
      name: "name[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] Name of the test"
--- #--------------------------------------------------------------------------
type: struct
desc: "Diagnostics test suite properties"
class: $tSysmanDiagnostics
name: $t_diag_properties_t
members:
    - type: $t_diag_type_t
      name: "type"
      desc: "[out] The type of diagnostics test suite"
    - type: $x_bool_t
      name: "onSubdevice"
      desc: "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle"
    - type: uint32_t
      name: "subdeviceId"
      desc: "[out] If onSubdevice is true, this gives the ID of the sub-device"
    - type: char
      name: "name[$T_STRING_PROPERTY_SIZE]"
      desc: "[out] Name of the diagnostics test suite"
    - type: $x_bool_t
      name: "haveTests"
      desc: "[out] Indicates if this test suite has individual tests which can be run separately (use the function $SysmanDiagnosticsGetTests() to get the list of these tests)"
--- #--------------------------------------------------------------------------
type: function
desc: "Get handle of diagnostics test suites"
class: $tSysman
name: DiagnosticsGet
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_handle_t
      name: hSysman
      desc: "[in] Sysman handle of the device."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of components of this type.
            if count is zero, then the driver will update the value with the total number of components of this type.
            if count is non-zero, then driver will only retrieve that number of components.
            if count is larger than the number of components available, then the driver will update the value with the correct number of components that are returned.
    - type: "$t_sysman_diag_handle_t*"
      name: phDiagnostics
      desc: "[in,out][optional][range(0, *pCount)] array of handle of components of this type"
--- #--------------------------------------------------------------------------
type: function
desc: "Get properties of a diagnostics test suite"
class: $tSysmanDiagnostics
name: GetProperties
details:
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_diag_handle_t
      name: hDiagnostics
      desc: "[in] Handle for the component."
    - type: $t_diag_properties_t*
      name: pProperties
      desc: "[in] Structure describing the properties of a diagnostics test suite"
--- #--------------------------------------------------------------------------
type: function
desc: "Get individual tests that can be run separately. Not all test suites permit running individual tests - check $t_diag_properties_t.haveTests"
class: $tSysmanDiagnostics
name: GetTests
details:
    - "The list of available tests is returned in order of increasing test index $t_diag_test_t.index."
    - "The application may call this function from simultaneous threads."
    - "The implementation of this function should be lock-free."
params:
    - type: $t_sysman_diag_handle_t
      name: hDiagnostics
      desc: "[in] Handle for the component."
    - type: "uint32_t*"
      name: pCount
      desc: |
            [in,out] pointer to the number of tests.
            If count is zero, then the driver will update the value with the total number of tests available.
            If count is non-zero, then driver will only retrieve that number of tests.
            If count is larger than the number of tests available, then the driver will update the value with the correct number of tests available.
    - type: "$t_diag_test_t*"
      name: pTests
      desc: "[in,out][optional][range(0, *pCount)] Array of tests sorted by increasing value of $t_diag_test_t.index"
--- #--------------------------------------------------------------------------
type: function
desc: "Run a diagnostics test suite, either all tests or a subset of tests."
class: $tSysmanDiagnostics
name: RunTests
details:
    - "To run all tests in a test suite, set start = $T_DIAG_FIRST_TEST_INDEX and end = $T_DIAG_LAST_TEST_INDEX."
    - "If the test suite permits running individual tests, $t_diag_properties_t.haveTests will be true. In this case, the function $tSysmanDiagnosticsGetTests() can be called to get the list of tests and corresponding indices that can be supplied to the arguments start and end in this function."
    - "This function will block until the diagnostics have completed."
params:
    - type: $t_sysman_diag_handle_t
      name: hDiagnostics
      desc: "[in] Handle for the component."
    - type: uint32_t
      name: start
      desc: "[in] The index of the first test to run. Set to $T_DIAG_FIRST_TEST_INDEX to start from the beginning."
    - type: uint32_t
      name: end
      desc: "[in] The index of the last test to run. Set to $T_DIAG_LAST_TEST_INDEX to complete all tests after the start test."
    - type: $t_diag_result_t*
      name: pResult
      desc: "[in] The result of the diagnostics"
returns:
    - $X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS:
        - "User does not have permissions to perform diagnostics."
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device"
name: $tSysman
owner: $tDevice
members:
    - type: $t_sysman_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $tDevice*
      name: pDevice
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device power domain"
name: $tSysmanPower
owner: $tSysman
members:
    - type: $t_sysman_pwr_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device frequency domain"
name: $tSysmanFrequency
owner: $tSysman
members:
    - type: $t_sysman_freq_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device engine group"
name: $tSysmanEngine
owner: $tSysman
members:
    - type: $t_sysman_engine_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman standby control"
name: $tSysmanStandby
owner: $tSysman
members:
    - type: $t_sysman_standby_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device firmware"
name: $tSysmanFirmware
owner: $tSysman
members:
    - type: $t_sysman_firmware_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device memory module"
name: $tSysmanMemory
owner: $tSysman
members:
    - type: $t_sysman_mem_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device Fabric port"
name: $tSysmanFabricPort
owner: $tSysman
members:
    - type: $t_sysman_fabric_port_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device temperature sensor"
name: $tSysmanTemperature
owner: $tSysman
members:
    - type: $t_sysman_temp_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device power supply"
name: $tSysmanPsu
owner: $tSysman
members:
    - type: $t_sysman_psu_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device fan"
name: $tSysmanFan
owner: $tSysman
members:
    - type: $t_sysman_fan_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device LED"
name: $tSysmanLed
owner: $tSysman
members:
    - type: $t_sysman_led_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device RAS error set"
name: $tSysmanRas
owner: $tSysman
members:
    - type: $t_sysman_ras_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device diagnostic test suite"
name: $tSysmanDiagnostics
owner: $tSysman
members:
    - type: $t_sysman_diag_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
--- #--------------------------------------------------------------------------
type: class
desc: "C++ wrapper for a Sysman device event"
name: $tSysmanEvent
owner: $tSysman
members:
    - type: $t_sysman_event_handle_t
      name: handle
      desc: "[in] handle of Sysman object" 
      init: nullptr
    - type: $tSysman*
      name: pSysman
      desc: "[in] pointer to owner object"
